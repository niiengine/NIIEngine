/*
-----------------------------------------------------------------------------
A
     __      _   _   _   ______
    |   \   | | | | | | |  ____)                    _
    | |\ \  | | | | | | | |         ___      ___   (_)   ___
    | | \ \ | | | | | | | |____    / _ \   / ___ \  _   / _ \   ___
    | |  \ \| | | | | | |  ____)  | / \ | | |  | | | | | / \ | / _ )
    | |   \ | | | | | | | |_____  | | | | | |__| | | | | | | | | __/
    |_|    \ _| |_| |_| |_______) |_| |_|  \___| | |_| |_| |_| |___|
                                             __/ |                 
                                            \___/   
                                                
                                                
                                                                 F i l e


Copyright: NIIEngine Team Group

Home page: www.niiengine.com 

Email: niiengine@gmail.com OR niiengine@163.com

Licence: commerce(www.niiengine.com/license)(Three kinds)
------------------------------------------------------------------------------
*/

#include "PlayPenTests.h"
#include "OgreResourceLoadManager.h"
#include "OgreCodec.h"
#include "FileSystemLayer.h"

using namespace Ogre;

String VisualTest::TRANSIENT_RESOURCE_GROUP = "VisualTestTransient";

PlayPen_ManualLOD::PlayPen_ManualLOD()
{
    mInfo["Title"] = "PlayPen_ManualLOD";
    mInfo["Description"] = "Testing meshes with manual LODs assigned";
    addScreenshotFrame(75);
}
//---------------------------------------------------------------------------
void PlayPen_ManualLOD::setupContent()
{
    String meshName = getLODMesh();

    GeometrySpace *ent;
    for (int i = 0; i < 5; ++i)
    {
        ent = mSceneMgr->createGeo("robot" + StrConv::conv(i), meshName);
        // Add entity to the scene node
        static_cast<SpaceNode *>(mSceneMgr->getOriginNode()->create(
            Vector3(0,0,(i*50)-(5*50/2))))->attachObject(ent);
    }

    mAnimation = ent->getFusion("Walk");
    mAnimation->setEnabled(true);

    // Give it a little ambience with lights
    Light* l;
    l = mSceneMgr->createLight("BlueLight");
    l->setPos(Vecotr3f(-200,-80,-100));
    l->setDiffuse(0.5, 0.5, 1.0);

    l = mSceneMgr->createLight("GreenLight");
    l->setPos(Vecotr3f(0, 0, -100));
    l->setDiffuse(0.5, 1.0, 0.5);

    // Position the camera
    mCamera->setPos(NII::Vector3f(100, 50, 100));
    mCamera->lookAt(NII::Vector3f(-50, 50, 0));

    mSceneMgr->setAmbient(Colour::White);
}
//---------------------------------------------------------------------------
bool PlayPen_ManualLOD::onPreRender(const RenderFrameArgs * evt)
{
    mAnimation->addTime(evt->mCurrent);
    return true;
}
//-----------------------------------------------------------------------
String PlayPen_ManualLOD::getLODMesh()
{
    MeshPtr msh1 = (MeshPtr)N_Only(Mesh).load("robot.mesh", TRANSIENT_RESOURCE_GROUP);

    MeshLodScheme * mls = msh1->getLodScheme();
    mls->add(200, mls->getDest(200), "razor.mesh", GroupUnknow);
    mls->add(500, mls->getDest(500), "sphere.mesh", GroupUnknow);
    mls->sort();

    return msh1->getName();
}
//---------------------------------------------------------------------------
//---------------------------------------------------------------------------
PlayPen_ManualLODFromFile::PlayPen_ManualLODFromFile()
{
    mInfo["Title"] = "PlayPen_ManualLOD_File";
    mInfo["Description"] = "Testing meshes with manual LODs assigned, loaded from a file";
    addScreenshotFrame(75);
}
//---------------------------------------------------------------------------
String PlayPen_ManualLODFromFile::getLODMesh()
{
    MeshPtr msh1 = (MeshPtr)N_Only(Mesh).load("robot.mesh", TRANSIENT_RESOURCE_GROUP);
    MeshLodScheme * mls = msh1->getLodScheme();
    mls->add(200, "razor.mesh", GroupUnknow, 0, false);
    mls->add(500, "sphere.mesh", GroupUnknow, 0, false);
    mls->sort();

    // this time, we save this data to a file and re-load it

    MeshSerializer ser;

    String prefix;
    VFS * vfs = N_Only(ResourceScheme).getVFS("media", TRANSIENT_RESOURCE_GROUP);
    if(vfs)
    {
        if(StringUtil::endsWith(vfs->getName(), "media"))
        {
            prefix = vfs->getName();
            break;
        }
    }
    ser.exportMesh(msh1.get(), prefix + "/testlod.mesh");

    MeshManager::getSingleton().removeAll();

    return "testlod.mesh";
}
//---------------------------------------------------------------------------
//---------------------------------------------------------------------------
PlayPen_ManualBlend::PlayPen_ManualBlend()
{
    mInfo["Title"] = "PlayPen_ManualBlending";
    mInfo["Description"] = "Manual blending";
    addScreenshotFrame(10);
}
//---------------------------------------------------------------------------
void PlayPen_ManualBlend::setupContent()
{
    // create material
    MaterialPtr mat = MaterialManager::getSingleton().create("TestMat",
        TRANSIENT_RESOURCE_GROUP);
    ShaderCh * p = mat->get(0)->get(0);
    p->setLight(false);
    p->getTexture().create("Dirt.jpg");
    ShaderChTextureUnit * t = p->getTexture().create("ogrelogo.png");
    t->getColourBlend()->setBlend(TBS_TEXTURE, TBS_PRE_TEXTURE, 0.75);
    GeometrySpace * planeEnt = mSceneMgr->createGeo("Plane", GSP_Plane);
    static_cast<SpaceNode *>(mSceneMgr->getOriginNode()->create())->attachObject(planeEnt);
    planeEnt->setMaterial("TestMat");

    mCamera->setPos(NII::Vector3f(0,0,600));
    mCamera->lookAt(Vector3::ZERO);
}
//---------------------------------------------------------------------
//---------------------------------------------------------------------
PlayPen_ProjectSphere::PlayPen_ProjectSphere()
{
    mInfo["Title"] = "PlayPen_ProjectSphere";
    mInfo["Description"] = "Projecting a sphere's bounds onto the camera";
    addScreenshotFrame(10);
}
//---------------------------------------------------------------------------
void PlayPen_ProjectSphere::setupContent()
{
    mSceneMgr->setAmbient(Colour::White);

    Plane plane;
    plane.normal = Vector3::Y;
    plane.d = 0;
    MeshManager::getSingleton().createPlane("Myplane",
        TRANSIENT_RESOURCE_GROUP, plane,
        4500,4500,10,10,true,1,5,5,Vector3::Z);
    GeometrySpace* pPlaneEnt = mSceneMgr->createGeo( "plane", "Myplane" );
    pPlaneEnt->setMaterial("Examples/GrassFloor");
    pPlaneEnt->setCastShadow(false);
    static_cast<SpaceNode *>(mSceneMgr->getOriginNode()->create())->attachObject(pPlaneEnt);

    mProjectionSphere = new Sphere(Vector3(0, 2000, 0), 1500.0);

    CustomSpaceObj* debugSphere = mSceneMgr->createCustomGeo("debugSphere");
    debugSphere->begin(GeometryRaw::OT_LINE_STRIP, MaterialManager::WhiteColour->getOriginID());

    for (int i = 0; i <= 20; ++i)
    {
        Vector3 basePos(mProjectionSphere->getRadius(), 0, 0);
        Quaternion quat;
        quat.from(Radian(((float)i / (float)20) * Math::PI2X), Vector3::Y);
        basePos = quat * basePos;
        debugSphere->position(basePos);
    }
    for (int i = 0; i <= 20; ++i)
    {
        Vector3 basePos(mProjectionSphere->getRadius(), 0, 0);
        Quaternion quat;
        quat.from(Radian(((float)i / (float)20) * Math::PI2X), Vector3::Z);
        basePos = quat * basePos;
        debugSphere->position(basePos);
    }

    debugSphere->end();

    static_cast<SpaceNode *>(mSceneMgr->getOriginNode()->create(Vector3(0, 2000, 0)))->attachObject(debugSphere);

    MaterialPtr mat = MaterialManager::getSingleton().create("scissormat", TRANSIENT_RESOURCE_GROUP);
    ShaderCh * p = mat->get(0)->get(0);
    p->setStencil(ShaderCh::SOT_Set)->setDepthWrite(false);
    p->setBlend(ShaderCh::SOT_Set)->setBlend(FBM_INV_ALPHA);
    ShaderChTextureUnit * t = p->getTexture().create();
    t->getColourBlend()->setBlend(TBO_OPERAND1, Colour::Red, TBS_PRE_TEXTURE);
    t->getAlphaBlend()->setBlend(TBO_OPERAND1, 0.5f, TBS_PRE_TEXTURE);

    mScissorRect = mSceneMgr->createCustomGeo("mScissorRect");
    mScissorRect->on(GeometryObj::M_IdentityProj);
    mScissorRect->on(GeometryObj::M_IdentityView);
    mScissorRect->setCullType(CT_Always);
    mScissorRect->begin(GeometryRaw::OT_TRIANGLE_LIST, mat->getOriginID());
    mScissorRect->position(Vector3::ZERO);
    mScissorRect->position(Vector3::ZERO);
    mScissorRect->position(Vector3::ZERO);
    mScissorRect->quad(0, 1, 2, 3);
    mScissorRect->end();
    static_cast<SpaceNode *>(mSceneMgr->getOriginNode()->create())->attachObject(mScissorRect);

    mCamera->setPos(NII::Vector3f(0,3000,5000));
    mCamera->lookAt(mProjectionSphere->getCenter());
}
//---------------------------------------------------------------------------
bool PlayPen_ProjectSphere::onPreRender(const RenderFrameArgs * evt)
{
    Rectf rect;
    mCamera->project(*mProjectionSphere, rect);

    mScissorRect->beginModify(0);
    mScissorRect->position(rect.mLeft, rect.mTop, 0);
    mScissorRect->position(rect.mLeft, rect.mBottom, 0);
    mScissorRect->position(rect.mRight, rect.mBottom, 0);
    mScissorRect->position(rect.mRight, rect.mTop, 0);
    mScissorRect->quad(0,1,2,3);
    mScissorRect->end();
    return true;
}
//---------------------------------------------------------------------
//---------------------------------------------------------------------
PlayPen_CameraSetDirection::PlayPen_CameraSetDirection():
    mUseParentNode(false),
    mUseFixedYaw(true),
    mFocus(100, 200, -300)
{
    mInfo["Title"] = "PlayPen_CameraSetDirection";
    mInfo["Description"] = "Testing various settings for Camera::setDirection";
    addScreenshotFrame(10);
}
//---------------------------------------------------------------------
void PlayPen_CameraSetDirection::setupContent()
{
    mSceneMgr->setAmbient(Colour::White);

    GeometrySpace * e = mSceneMgr->createGeo("1", "knot.mesh");
    static_cast<SpaceNode *>(mSceneMgr->getOriginNode()->create(mFocus))->attachObject(e);


    mCamera->setPos(NII::Vector3f(200,1000,1000));
    mCamera->lookAt(mFocus);

    //mTrayMgr->createButton(OgreBites::TL_BOTTOM, "Look At", "Look At");
    //mTrayMgr->createCheckBox(OgreBites::TL_BOTTOM, "tglParent", "Use Parent Node");
    //OgreBites::CheckBox* chk = mTrayMgr->createCheckBox(OgreBites::TL_BOTTOM, "tglFixedYaw", "Use Fixed Yaw");
    //chk->setChecked(true, false);
    //mTrayMgr->showCursor();
    //setDragLook(true);

    mParentNode = mSceneMgr->getOriginNode()->create(Vector3(1000, 2000, -1000));

}
//---------------------------------------------------------------------

void PlayPen_CameraSetDirection::buttonHit(OgreBites::Button* button)
{
    mCamera->lookAt(mFocus);
}
//---------------------------------------------------------------------

void PlayPen_CameraSetDirection::checkBoxToggled(OgreBites::CheckBox* box)
{
    if (box->getName() == "tglParent")
    {
        mUseParentNode = !mUseParentNode;

        if(mUseParentNode)
            mParentNode->attachObject(mCamera);
        else
            mParentNode->detachAll();
    }
    else if(box->getName() == "tglFixedYaw")
    {
        mUseFixedYaw = !mUseFixedYaw;
        if(mUseFixedYaw)
            mCamera->setCustomYaw(true);
        else
            mCamera->setCustomYaw(false);
    }
}
//---------------------------------------------------------------------
//---------------------------------------------------------------------

PlayPen_MorphAnimationWithNormals::PlayPen_MorphAnimationWithNormals()
{
    mInfo["Title"] = "PlayPen_MorphAnimNormals";
    mInfo["Description"] = "Testing morph animation with normals";
    addScreenshotFrame(200);
}
//---------------------------------------------------------------------

void PlayPen_MorphAnimationWithNormals::setupContent()
{
    // explicitly disable stencil volume prep
    N_Only(Engine).getProcessSpace()->setShadowVolume(0, false);

    // Cannot change this to true, not possible to use software morph animation + normals with stencil shadows
    // because the former requires pos & normals to be in the same buffer, and the
    // latter requires positions to be on their own.
    //bool testStencil = false;

    //if (testStencil)
      //  mSceneMgr->setShadowTechnique(SHADOWTYPE_STENCIL_MODULATIVE);

    mSceneMgr->setAmbient(Colour(0.5, 0.5, 0.5));
    Vector3 dir(-1, -1, 0.5);
    dir.normalise();
    Light * l = mSceneMgr->createLight("light1");
    l->setType(LT_DIRECTIONAL);
    l->setDirection(dir);

    MeshPtr mesh = N_Only(Mesh).load("sphere.mesh", TRANSIENT_RESOURCE_GROUP);

    String morphName = "testmorphwithnormals.mesh";
    mesh = mesh->clone(morphName);

    SubMesh * sm = mesh->getSub(0);
    // Re-organise geometry since this mesh has no animation and all
    // vertex elements are packed into one buffer
    sm->getVertexData()->build(VertexData::M_Animation | VertexData::M_Normals, true);
    //if (testStencil)
      //  sm->getVertexData()->rebuild(M_ShadowVol); // need to re-prep since reorganised
    // get the position buffer (which should now be separate);
    const VertexUnit * posElem = sm->getVertexData()->get(VT_Pos);
    VertexBufferSPtr origbuf = sm->getVertexData()->getBuffer(posElem->getSource());

    // Create a new position & normal buffer with updated values
    VertexBuffer * newbuf;
    N_Only(GBuffer).create(newbuf,
        VertexUnit::getTypeSize(DT_Float3x) * 2,
            sm->getVertexData()->mCount, Buffer::Buffer::M_DEV | Buffer::M_HOST);

    float* pSrc = static_cast<float*>(origbuf->lock(Buffer::MM_READ));
    float* pDst = static_cast<float*>(newbuf->lock(Buffer::MM_WHOLE));

    // Make the sphere turn into a cube
    // Do this just by clamping each of the directions (we shrink it)
    float cubeDimension = 0.3f * mesh->getCenterRange();
    size_t srcSkip = origbuf->getUnitSize() / sizeof(float) - 3;
    for(size_t v = 0; v < sm->getVertexData()->mCount; ++v)
    {
        // x/y/z position
        Vector3 pos;

        if(*pSrc >= 0)
        {
            pos.x = std::min(cubeDimension, *pSrc++);
        }
        else
        {
            pos.x = std::max(-cubeDimension, *pSrc++);
        }
        *pDst++ = pos.x;

        if(*pSrc >= 0)
        {
            pos.y = std::min(cubeDimension, *pSrc++);
        }
        else
        {
            pos.y = std::max(-cubeDimension, *pSrc++);
        }
        *pDst++ = pos.y;

        if(*pSrc >= 0)
        {
            pos.z = std::min(cubeDimension, *pSrc++);
        }
        else
        {
            pos.z = std::max(-cubeDimension, *pSrc++);
        }
        *pDst++ = pos.z;

        // normal
        // this should point along the major axis
        // unfortunately since vertices are not duplicated at edges there will be
        // some inaccuracy here but the most important thing is to add sharp edges
        Vector3 norm;
        pos.normalise(norm);
        Real absx = Math::Abs(norm.x);
        Real absy = Math::Abs(norm.y);
        Real absz = Math::Abs(norm.z);
        if(absx > absy)
            if(absx > absz)
                norm = norm.x > 0 ? Vector3::X : Vector3::INV_X;
            else
                norm = norm.z > 0 ? Vector3::Z : Vector3::INV_Z;
        else // absx <= absy
            if(absy > absz)
                norm = norm.y > 0 ? Vector3::Y : Vector3::INV_Y;
            else
                norm = norm.z > 0 ? Vector3::Z : Vector3::INV_Z;

        *pDst++ = norm.x;
        *pDst++ = norm.y;
        *pDst++ = norm.z;

        pSrc += srcSkip;

    }

    origbuf->unlock();
    newbuf->unlock();

    // create a morph animation
    Animation * anim = mesh->createAnimation("testAnim", 10.0f);
    VertexUnitKeyFrameTrack * vt = N_new VertexUnitKeyFrameTrack(anim, 1);
    vt->setTarget(sm->getVertexData());
    // re-use start positions for frame 0
    VertexUnitKeyFrame * kf = vt->create(0);
    kf->setValue(origbuf);

    // Use translated buffer for mid frame
    kf = vt->create(4.0f);
    kf->setValue(newbuf);

    // Pause there
    kf = vt->create(6.0f);
    kf->setValue(newbuf);

    // re-use start positions for final frame
    kf = vt->create(10.0f);
    kf->setValue(origbuf);

    // Export the mesh
    DataStream * stream = Root::getSingleton().createFile(morphName, GroupDefault, true);
    MeshSerializer ser;
    ser.exportMesh(mesh.get(), stream);
    stream->close();
    N_delete stream;
    // Unload old mesh to force reload
    MeshManager::getSingleton().remove(mesh->getPrc());
    mesh->unload();
    mesh.setNull();

    GeometrySpace * e = mSceneMgr->createGeo("test", morphName);
    static_cast<SpaceNode *>(mSceneMgr->getOriginNode()->create())->attachObject(e);
    AnimationFusion * animState = e->getFusion("testAnim");
    animState->setEnabled(true);
    animState->setWeight(1.0f);
    mAnimations[0] = animState;

    e = mSceneMgr->createGeo("test2", morphName);
    static_cast<SpaceNode *>(mSceneMgr->getOriginNode()->create(Vector3(200,0,0)))->attachObject(e);
    // test hardware morph
    e->setMaterial("Examples/HardwareMorphAnimationWithNormals");
    animState = e->getFusion("testAnim");
    animState->setEnabled(true);
    animState->setWeight(1.0f);
    mAnimations[1] = animState;

    mCamera->setNearClipDistance(0.5);
    mCamera->setPos(NII::Vector3f(0, 100, -400));
    mCamera->lookAt(Vector3::ZERO);
    //mSceneMgr->getRenderPattern()->setDebugShadow(true);

    Plane plane;
    plane.normal = Vector3::Y;
    plane.d = 200;
    MeshManager::getSingleton().createPlane("Myplane",
        TRANSIENT_RESOURCE_GROUP, plane,
        1500,1500,10,10,true,1,5,5,Vector3::Z);
    GeometrySpace* pPlaneEnt = mSceneMgr->createGeo( "plane", "Myplane" );
    pPlaneEnt->setMaterial("2 - Default");
    pPlaneEnt->setCastShadow(false);
    static_cast<SpaceNode *>(mSceneMgr->getOriginNode()->create())->attachObject(pPlaneEnt);
}

bool PlayPen_MorphAnimationWithNormals::onPreRender(const RenderFrameArgs * evt)
{
    mAnimations[0]->addTime(evt->mCurrent);
    mAnimations[1]->addTime(evt->mCurrent);
    return true;
}
//---------------------------------------------------------------------
//---------------------------------------------------------------------

PlayPen_MorphAnimationWithoutNormals::PlayPen_MorphAnimationWithoutNormals()
{
    mInfo["Title"] = "PlayPen_MorphAnimNoNormals";
    mInfo["Description"] = "Testing morph animation without normals";
    addScreenshotFrame(200);
}
//---------------------------------------------------------------------

void PlayPen_MorphAnimationWithoutNormals::setupContent()
{
    //bool testStencil = false;

    //if (testStencil)
      //  mSceneMgr->setShadowTechnique(SHADOWTYPE_STENCIL_MODULATIVE);

    mSceneMgr->setAmbient(Colour(0.5, 0.5, 0.5));
    Vector3 dir(-1, -1, 0.5);
    dir.normalise();
    Light * l = mSceneMgr->createLight("light1");
    l->setType(LT_DIRECTIONAL);
    l->setDirection(dir);

    MeshPtr mesh = N_Only(Mesh).load("sphere.mesh", GroupDefault);

    String morphName = "testmorphnonormals.mesh";
    mesh = mesh->clone(morphName);

    SubMesh * sm = mesh->getSub(0);
    VertexData * smvd = sm->getVertexData();
    // Re-organise geometry since this mesh has no animation and all
    // vertex elements are packed into one buffer
    smvd->build(VertexData::M_Animation, true);
    //if(testStencil)
      //  smvd->rebuild(M_ShadowVol); // need to re-prep since reorganised
    // get the position buffer (which should now be separate);
    const VertexUnit * posElem = smvd->get(VT_Pos);
    VertexBufferSPtr origbuf = smvd->getBuffer(posElem->getSource());

    // Create a new position & normal buffer with updated values
    VertexBufferSPtr newbuf;
    N_Only(GBuffer).create(newbuf, VertexUnit::getTypeSize(DT_Float3x),
        smvd->mCount, Buffer::Buffer::M_DEV | Buffer::M_HOST);
    float * pSrc = static_cast<float*>(origbuf->lock(Buffer::MM_READ));
    float * pDst = static_cast<float*>(newbuf->lock(Buffer::MM_WHOLE));

    // Make the sphere turn into a cube
    // Do this just by clamping each of the directions (we shrink it)
    float cubeDimension = 0.3f * mesh->getCenterRange();
    for(size_t v = 0; v < smvd->mCount; ++v)
    {
        // x/y/z position
        Vector3 pos;

        if(*pSrc >= 0)
        {
            pos.x = std::min(cubeDimension, *pSrc++);
        }
        else
        {
            pos.x = std::max(-cubeDimension, *pSrc++);
        }
        *pDst++ = pos.x;

        if(*pSrc >= 0)
        {
            pos.y = std::min(cubeDimension, *pSrc++);
        }
        else
        {
            pos.y = std::max(-cubeDimension, *pSrc++);
        }
        *pDst++ = pos.y;

        if(*pSrc >= 0)
        {
            pos.z = std::min(cubeDimension, *pSrc++);
        }
        else
        {
            pos.z = std::max(-cubeDimension, *pSrc++);
        }
        *pDst++ = pos.z;
    }

    origbuf->unlock();
    newbuf->unlock();

    // create a morph animation
    Animation * anim = mesh->createAnimation("testAnim", 10.0f);
    VertexUnitKeyFrameTrack * vt = N_new VertexUnitKeyFrameTrack(anim, 1);
    vt->setTarget(smvd);
    // re-use start positions for frame 0
    VertexUnitKeyFrame * kf = vt->create(0);
    kf->setValue(origbuf);

    // Use translated buffer for mid frame
    kf = vt->create(4.0f);
    kf->setValue(newbuf);

    // Pause there
    kf = vt->create(6.0f);
    kf->setValue(newbuf);

    // re-use start positions for final frame
    kf = vt->create(10.0f);
    kf->setValue(origbuf);

    // Export the mesh
    DataStream * stream = Root::getSingleton().createFile(morphName, GroupDefault, true);
    MeshSerializer ser;
    ser.exportMesh(mesh.get(), stream);
    stream->close();
    N_delete stream;
    // Unload old mesh to force reload
    MeshManager::getSingleton().remove(mesh->getPrc());
    mesh->unload();
    mesh.setNull();

    GeometrySpace * e = mSceneMgr->createGeo("test", morphName);
    static_cast<SpaceNode *>(mSceneMgr->getOriginNode()->create())->attachObject(e);
    AnimationFusion * animState = e->getFusion("testAnim");
    animState->setEnabled(true);
    animState->setWeight(1.0f);
    mAnimations[0] = animState;

    e = mSceneMgr->createGeo("test2", morphName);
    static_cast<SpaceNode *>(mSceneMgr->getOriginNode()->create(Vector3(200,0,0)))->attachObject(e);
    // test hardware morph
    e->setMaterial("Examples/HardwareMorphAnimation");
    animState = e->getFusion("testAnim");
    animState->setEnabled(true);
    animState->setWeight(1.0f);
    mAnimations[1] = animState;

    mCamera->setNearClipDistance(0.5);
    mCamera->setPos(NII::Vector3f(0, 100, -400));
    mCamera->lookAt(Vector3::ZERO);
    //mSceneMgr->getRenderPattern()->setDebugShadow(true);

    Plane plane;
    plane.normal = Vector3::Y;
    plane.d = 200;
    MeshManager::getSingleton().createPlane("Myplane",
        TRANSIENT_RESOURCE_GROUP, plane,
        1500,1500,10,10,true,1,5,5,Vector3::Z);
    GeometrySpace* pPlaneEnt = mSceneMgr->createGeo( "plane", "Myplane" );
    pPlaneEnt->setMaterial("2 - Default");
    pPlaneEnt->setCastShadow(false);
    static_cast<SpaceNode *>(mSceneMgr->getOriginNode()->create())->attachObject(pPlaneEnt);

}

bool PlayPen_MorphAnimationWithoutNormals::onPreRender(const RenderFrameArgs * evt)
{
    mAnimations[0]->addTime(evt->mCurrent);
    mAnimations[1]->addTime(evt->mCurrent);
    return true;
}
//---------------------------------------------------------------------
//---------------------------------------------------------------------

PlayPen_PoseAnimationWithNormals::PlayPen_PoseAnimationWithNormals()
{
    mInfo["Title"] = "PlayPen_PoseAnimNormals";
    mInfo["Description"] = "Testing pose animation with normals";
    addScreenshotFrame(200);
}
//---------------------------------------------------------------------
void PlayPen_PoseAnimationWithNormals::setupContent()
{
    mSceneMgr->setAmbient(Colour(0.5, 0.5, 0.5));
    Vector3 dir(-1, -1, 0.5);
    dir.normalise();
    Light * l = mSceneMgr->createLight("light1");
    l->setType(LT_DIRECTIONAL);
    l->setDirection(dir);

    MeshPtr mesh = N_Only(Mesh).load("cube.mesh", TRANSIENT_RESOURCE_GROUP);

    String newName = "testposewithnormals.mesh";
    mesh = mesh->clone(newName);

    SubMesh * sm = mesh->getSub(0);
    VertexData * smvd = sm->getVertexData();
    // Re-organise geometry since this mesh has no animation and all
    // vertex elements are packed into one buffer
    smvd->build(VertexData::M_Animation | VertexData::M_Normals, true);
    // create 2 poses
    VertexOffset * pose = mesh->createOffset("pose1", 1);
    // Pose1 moves vertices 0, 1, 2 and 3 upward and pushes normals left
    Vector3 offset1(0, 50, 0);
    pose->add(0, offset1, Vector3::INV_X);
    pose->add(1, offset1, Vector3::INV_X);
    pose->add(2, offset1, Vector3::INV_X);
    pose->add(3, offset1, Vector3::INV_X);

    pose = mesh->createOffset("pose2", 1);
    // Pose2 moves vertices 3, 4, and 5 to the right and pushes normals right
    // Note 3 gets affected by both
    Vector3 offset2(100, 0, 0);
    pose->add(3, offset2, Vector3::X);
    pose->add(4, offset2, Vector3::X);
    pose->add(5, offset2, Vector3::X);


    Animation* anim = mesh->createAnimation("poseanim", 20.0f);
    VertexOffsetKeyFrameTrack * vt = N_new VertexOffsetKeyFrameTrack(anim, 1, type);
    vt->setTarget(smvd);
    // Frame 0 - no effect
    VertexPoseKeyFrame* kf = vt->createVertexPoseKeyFrame(0);

    // Frame 1 - bring in pose 1 (index 0)
    kf = vt->createVertexPoseKeyFrame(3);
    kf->add(0, 1.0f);

    // Frame 2 - remove all
    kf = vt->createVertexPoseKeyFrame(6);

    // Frame 3 - bring in pose 2 (index 1)
    kf = vt->createVertexPoseKeyFrame(9);
    kf->add(1, 1.0f);

    // Frame 4 - remove all
    kf = vt->createVertexPoseKeyFrame(12);


    // Frame 5 - bring in pose 1 at 50%, pose 2 at 100%
    kf = vt->createVertexPoseKeyFrame(15);
    kf->add(0, 0.5f);
    kf->add(1, 1.0f);

    // Frame 6 - bring in pose 1 at 100%, pose 2 at 50%
    kf = vt->createVertexPoseKeyFrame(18);
    kf->add(0, 1.0f);
    kf->add(1, 0.5f);

    // Frame 7 - reset
    kf = vt->createVertexPoseKeyFrame(20);

    // Export the mesh
    DataStream * stream = Root::getSingleton().createFile(newName, GroupDefault, true);
    MeshSerializer ser;
    ser.exportMesh(mesh.get(), stream);
    stream->close();
    N_delete stream;

    // Unload old mesh to force reload
    MeshManager::getSingleton().remove(mesh->getPrc());
    mesh->unload();
    mesh.setNull();

    GeometrySpace *  e;
    AnimationFusion * animState;
    // software pose
    e = mSceneMgr->createGeo("test2", newName);
    static_cast<SpaceNode *>(mSceneMgr->getOriginNode()->create(Vector3(150,0,0)))->attachObject(e);
    animState = e->getFusion("poseanim");
    animState->setEnabled(true);
    animState->setWeight(1.0f);
    mAnimations[0] = animState;

    // test hardware pose
    e = mSceneMgr->createGeo("test", newName);
    static_cast<SpaceNode *>(mSceneMgr->getOriginNode()->create())->attachObject(e);
    e->setMaterial("Examples/HardwarePoseAnimationWithNormals");
    animState = e->getFusion("poseanim");
    animState->setEnabled(true);
    animState->setWeight(1.0f);
    mAnimations[1] = animState;

    mCamera->setNearClipDistance(0.5);
    mSceneMgr->getRenderPattern()->setDebugShadow(true);

    Plane plane;
    plane.normal = Vector3::Y;
    plane.d = 200;
    MeshManager::getSingleton().createPlane("Myplane", TRANSIENT_RESOURCE_GROUP, plane, 
        1500,1500,10,10,true,1,5,5,Vector3::Z);
    GeometrySpace* pPlaneEnt = mSceneMgr->createGeo( "plane", "Myplane" );
    pPlaneEnt->setMaterial("2 - Default");
    pPlaneEnt->setCastShadow(false);
    static_cast<SpaceNode *>(mSceneMgr->getOriginNode()->create())->attachObject(pPlaneEnt);

    mCamera->setPos(NII::Vector3f(0, -200, -300));
    mCamera->lookAt(Ogre::Vector3f(0, 0, 0));
}
//---------------------------------------------------------------------

bool PlayPen_PoseAnimationWithNormals::onPreRender(const RenderFrameArgs * evt)
{
    mAnimations[0]->addTime(evt->mCurrent);
    mAnimations[1]->addTime(evt->mCurrent);
    return true;
}
//---------------------------------------------------------------------
//---------------------------------------------------------------------

PlayPen_PoseAnimationWithoutNormals::PlayPen_PoseAnimationWithoutNormals()
{
    mInfo["Title"] = "PlayPen_PoseAnimNoNormals";
    mInfo["Description"] = "Testing pose animation without normals";
    addScreenshotFrame(200);
}
//---------------------------------------------------------------------
void PlayPen_PoseAnimationWithoutNormals::setupContent()
{
    mSceneMgr->setAmbient(Colour(0.5, 0.5, 0.5));
    Vector3 dir(-1, -1, 0.5);
    dir.normalise();
    Light * l = mSceneMgr->createLight("light1");
    l->setType(LT_DIRECTIONAL);
    l->setDirection(dir);

    MeshPtr mesh = N_Only(Mesh).load("cube.mesh", TRANSIENT_RESOURCE_GROUP);

    String newName = "testposenonormals.mesh";
    mesh = mesh->clone(newName);

    SubMesh * sm = mesh->getSub(0);
    // Re-organise geometry since this mesh has no animation and all
    // vertex elements are packed into one buffer
    sm->getVertexData()->build(VertexData::M_Animation, true);
    // create 2 poses
    VertexOffset * pose = mesh->createOffset("pose1", 1);
    // Pose1 moves vertices 0, 1, 2 and 3 upward
    Vector3 offset1(0, 50, 0);
    pose->add(0, offset1);
    pose->add(1, offset1);
    pose->add(2, offset1);
    pose->add(3, offset1);

    pose = mesh->createOffset("pose2", 1);
    // Pose2 moves vertices 3, 4, and 5 to the right
    // Note 3 gets affected by both
    Vector3 offset2(100, 0, 0);
    pose->add(3, offset2);
    pose->add(4, offset2);
    pose->add(5, offset2);

    Animation* anim = mesh->createAnimation("poseanim", 20.0f);
    VertexOffsetKeyFrameTrack * vt = N_new VertexOffsetKeyFrameTrack(anim, 1);
    vt->setTarget(sm->getVertexData());
    // Frame 0 - no effect
    VertexPoseKeyFrame* kf = vt->createVertexPoseKeyFrame(0);

    // Frame 1 - bring in pose 1 (index 0)
    kf = vt->createVertexPoseKeyFrame(3);
    kf->add(0, 1.0f);

    // Frame 2 - remove all
    kf = vt->createVertexPoseKeyFrame(6);

    // Frame 3 - bring in pose 2 (index 1)
    kf = vt->createVertexPoseKeyFrame(9);
    kf->add(1, 1.0f);

    // Frame 4 - remove all
    kf = vt->createVertexPoseKeyFrame(12);


    // Frame 5 - bring in pose 1 at 50%, pose 2 at 100%
    kf = vt->createVertexPoseKeyFrame(15);
    kf->add(0, 0.5f);
    kf->add(1, 1.0f);

    // Frame 6 - bring in pose 1 at 100%, pose 2 at 50%
    kf = vt->createVertexPoseKeyFrame(18);
    kf->add(0, 1.0f);
    kf->add(1, 0.5f);

    // Frame 7 - reset
    kf = vt->createVertexPoseKeyFrame(20);

    // Export the mesh
    DataStream * stream = Root::getSingleton().createFile(newName, GroupDefault, true);
    MeshSerializer ser;
    ser.exportMesh(mesh.get(), stream);
    stream->close();
    N_delete stream;

    // Unload old mesh to force reload
    MeshManager::getSingleton().remove(mesh->getPrc());
    mesh->unload();
    mesh.setNull();

    GeometrySpace*  e;
    AnimationFusion* animState;
    // software pose
    e = mSceneMgr->createGeo("test2", newName);
    static_cast<SpaceNode *>(mSceneMgr->getOriginNode()->create(Vector3(150,0,0)))->attachObject(e);
    animState = e->getFusion("poseanim");
    animState->setEnabled(true);
    animState->setWeight(1.0f);
    mAnimations[0] = animState;

    // test hardware pose
    e = mSceneMgr->createGeo("test", newName);
    static_cast<SpaceNode *>(mSceneMgr->getOriginNode()->create())->attachObject(e);
    e->setMaterial("Examples/HardwarePoseAnimation");
    animState = e->getFusion("poseanim");
    animState->setEnabled(true);
    animState->setWeight(1.0f);
    mAnimations[1] = animState;


    mCamera->setNearClipDistance(0.5);

    Plane plane;
    plane.normal = Vector3::Y;
    plane.d = 200;
    MeshManager::getSingleton().createPlane("Myplane",
        TRANSIENT_RESOURCE_GROUP, plane,
        1500,1500,10,10,true,1,5,5,Vector3::Z);
    GeometrySpace* pPlaneEnt = mSceneMgr->createGeo( "plane", "Myplane" );
    pPlaneEnt->setMaterial("2 - Default");
    pPlaneEnt->setCastShadow(false);
    static_cast<SpaceNode *>(mSceneMgr->getOriginNode()->create())->attachObject(pPlaneEnt);

    mCamera->setPos(NII::Vector3f(0,-200,-300));
    mCamera->lookAt(Ogre::Vector3f(0,0,0));
}
//---------------------------------------------------------------------------

bool PlayPen_PoseAnimationWithoutNormals::onPreRender(const RenderFrameArgs * evt)
{
    mAnimations[0]->addTime(evt->mCurrent);
    mAnimations[1]->addTime(evt->mCurrent);
    return true;
}
//---------------------------------------------------------------------------

PlayPen_SceneNodeTracking::PlayPen_SceneNodeTracking()
{
    mInfo["Title"] = "PlayPen_SceneNodeTracking";
    mInfo["Description"] = "Testing scenenode tracking.";
    addScreenshotFrame(200);
}
//-----------------------------------------------------------------------

bool PlayPen_SceneNodeTracking::onPreRender(const RenderFrameArgs * evt)
{
    mAnimState->addTime(evt->mCurrent);
    return true;
}
//-----------------------------------------------------------------------

void PlayPen_SceneNodeTracking::setupContent()
{
    // Set ambient light
    mSceneMgr->setAmbient(Colour(0.2, 0.2, 0.2));
    DomeSky * mDomeSky = N_new DomeSky(mSceneMgr);
    mDomeSky->setMaterial("Examples/CloudySky");
    mDomeSky->setRenderGroup(RQG_Sky);
    // Create a skydome
    mDomeSky->buildGeo(5, 1000, 8, 8);
    mSceneMgr->addSky(mDomeSky);
    // Create a light
    Light* l = mSceneMgr->createLight("MainLight");
    // Accept default settings: point light, white diffuse, just set position
    // NB I could attach the light to a SpaceNode if I wanted it to move automatically with
    //  other objects, but I don't
    l->setPos(Vector3f(20, 80, 50));

    GeometrySpace *ent;

    // Define a floor plane mesh
    Plane p;
    p.normal = Vector3::Y;
    p.d = 200;
    MeshManager::getSingleton().createPlane("FloorPlane",
        TRANSIENT_RESOURCE_GROUP,
        p,200000,200000,20,20,true,1,50,50,Vector3::Z);

    // Create an entity (the floor)
    ent = mSceneMgr->createGeo("floor", "FloorPlane");
    ent->setMaterial("Examples/RustySteel");
    // Attach to child of root node, better for culling (otherwise bounds are the combination of the 2)
    static_cast<SpaceNode *>(mSceneMgr->getOriginNode()->create())->attachObject(ent);

    // Add a head, give it it's own node
    SpaceNode * headNode = mSceneMgr->getOriginNode()->create();
    ent = mSceneMgr->createGeo("head", "ogrehead.mesh");
    headNode->attachObject(ent);

    // Add another head, give it it's own node
    SpaceNode * headNode2 = mSceneMgr->getOriginNode()->create();
    ent = mSceneMgr->createGeo("head2", "ogrehead.mesh");
    headNode2->attachObject(ent);

    // Make sure the head node tracks the root
    headNode->setAutoFocus(true, headNode2, Vector3f::ZERO, Vector3::Z);
    //headNode->setCustomYaw(true);

    // Create the camera node & attach camera
    //SpaceNode* camNode = mSceneMgr->getOriginNode()->create();
    //camNode->attachObject(mCamera);

    // set up spline animation of node
    Animation * anim = mSceneMgr->createAnimation("CameraTrack", 10);
    // Spline it for nice curves
    anim->setInterpolationMode(NodeFusion::M_SPLINE);
    // Create a track to animate the head's node
    NodeKeyFrameTrack * track = N_new NodeKeyFrameTrack(anim, 0);
    track->setAssociatedNode(headNode);
    // Setup keyframes
    NodeKeyFrame * key = static_cast<NodeKeyFrame *>(track->create(0)); // startposition
    key = static_cast<NodeKeyFrame *>(track->create(2.5));
    key->setTranslate(Vector3(500,500,-1000));
    key = static_cast<NodeKeyFrame *>(track->create(5));
    key->setTranslate(Vector3(-1500,1000,-600));
    key = static_cast<NodeKeyFrame *>(track->create(7.5));
    key->setTranslate(Vector3(0,-100,0));
    key = static_cast<NodeKeyFrame *>(track->create(10));
    key->setTranslate(Vector3(0,0,0));
    track->buildSpline();
    // Create a track to animate the second head's node
    track = N_new NodeKeyFrameTrack(anim, 1);
    track->setAssociatedNode(headNode2);
    // Setup keyframes
    key = static_cast<NodeKeyFrame *>(track->create(0)); // startposition
    key = static_cast<NodeKeyFrame *>(track->create(2.5));
    key->setTranslate(Vector3(-500,600,-100));
    key = static_cast<NodeKeyFrame *>(track->create(5));
    key->setTranslate(Vector3(800,200,-600));
    key = static_cast<NodeKeyFrame *>(track->create(7.5));
    key->setTranslate(Vector3(200,-1000,0));
    key = static_cast<NodeKeyFrame *>(track->create(10));
    key->setTranslate(Vector3(30,70,110));
    track->buildSpline();
    // Create a new animation state to track this
    mAnimState = mSceneMgr->createFusion("CameraTrack");
    mAnimState->setEnabled(true);

    // Put in a bit of fog for the hell of it
    //mSceneMgr->setFog(ShaderChFog(FM_EXP, Colour::White, 0.0002, 0.0, 1.0));

    mCamera->setPos(NII::Vector3f(-300,600,2000));
}
//-----------------------------------------------------------------------
//-----------------------------------------------------------------------
PlayPen_NonUniqueResourceNames::PlayPen_NonUniqueResourceNames():
    mPlaneSky(0)
{
    mInfo["Title"] = "PlayPen_NonUniqueResourceNames";
    mInfo["Description"] = "Testing resources without unique names (in different resource groups).";
    addScreenshotFrame(50);
}
//-----------------------------------------------------------------------
PlayPen_NonUniqueResourceNames::~PlayPen_NonUniqueResourceNames()
{
    if(mPlaneSky != 0)
    {
        mSceneMgr->removeSky(mPlaneSky);
        N_delete mPlaneSky;
        mPlaneSky = 0;
    }
}
//-----------------------------------------------------------------------

void PlayPen_NonUniqueResourceNames::setupContent()
{
    // Set ambient light
    mSceneMgr->setAmbient(Colour(0.5, 0.5, 0.5));

    // Define the required skyplane
    Plane plane;
    // 5000 world units from the camera
    plane.d = 5000;
    // Above the camera, facing down
    plane.normal = -Vector3::Y;
    mPlaneSky = N_new PlaneSky(mSceneMgr);
    mPlaneSky->setMaterial("Examples/SpaceSkyPlane");
    mPlaneSky->setRenderGroup(RQG_Sky);
    // Create the plane 10000 units wide, tile the texture 3 times
    mPlaneSky->buildGeo(plane, 10000, 3, 3);
    mSceneMgr->addSky(mPlaneSky);
    // Create a light
    Light * l = mSceneMgr->createLight("MainLight");
    // Accept default settings: point light, white diffuse, just set position
    // NB I could attach the light to a SpaceNode if I wanted it to move automatically with
    //  other objects, but I don't
    l->setPos(Vector3f(20, 80, 50));

    createMeshEntity("Model1", Vector3(10, 10, 10));
    createMeshEntity("Model2", Vector3(-10, -10, -10));

    mCamera->setPos(NII::Vector3F(100, 0, -100));
    mCamera->lookAt(NII::Vector3f(0, 0, 0));
}
//-----------------------------------------------------------------------
void PlayPen_NonUniqueResourceNames::createMeshEntity(String group, Vector3 pos)
{
    // get path to test resources (ugly, but the only way I can think of to consistently get the
    // right path (since it's determined by cmake build location) without explicitly defining the
    // groups in resources.cfg)
    VFS * vfs = N_Only(ResourceScheme).getVFS("", "Tests");
    Ogre::String testResourcePath = vfs->getName();

    Ogre::String meshFilePath = testResourcePath + "/" + group;

    NII::ResourceSchemeManager & resMgr = NII::ResourceSchemeManager::getSingleton();
    String newGroup = meshFilePath;
    resMgr.create(group, false);
    resMgr.add(meshFilePath, "FileSystem", group);
    resMgr.setup(group);

    Ogre::MeshPtr newMesh = NII::N_Only(Mesh).load("UniqueModel.MESH", group);
    GeometrySpace *newEnt = mSceneMgr->createGeo(group, "UniqueModel.MESH", group);

    SpaceNode* newNode = mSceneMgr->getOriginNode()->create();
    newNode->attachObject(newEnt);
    newNode->setPos(pos);

    // I was getting an assertion on some part of the skeleton loading
    //AnimationFusion* aniState =newEnt->getFusion(newEnt->getMesh()->getSkeleton()->getAnimation(0)->getName());
    //mAnimStateList.push_back(aniState);
    //aniState->setEnabled(true);
    //aniState->setPlayMode(RM_Loop);
}
//-----------------------------------------------------------------------
//-----------------------------------------------------------------------

PlayPen_16Textures::PlayPen_16Textures()
{
    mInfo["Title"] = "PlayPen_16Textures";
    mInfo["Description"] = "Tests applying 16 textures in a single material.";
    addScreenshotFrame(10);
}
//----------------------------------------------------------------------------

void PlayPen_16Textures::setupContent()
{

    HighLevelGpuProgramPtr frag;
    if (StringUtil::match(Root::getSingleton().getRender()->getName(), "*GL*"))
    {
        frag = HighLevelGpuProgramManager::getSingleton().createProgram("frag16", TRANSIENT_RESOURCE_GROUP,
        "glsl", GPT_FRAGMENT_PROGRAM);
        frag->setProgramCode(" \
        uniform sampler2D tex0; \
        uniform sampler2D tex1; \
        uniform sampler2D tex2; \
        uniform sampler2D tex3; \
        uniform sampler2D tex4; \
        uniform sampler2D tex5; \
        uniform sampler2D tex6; \
        uniform sampler2D tex7; \
        uniform sampler2D tex8; \
        uniform sampler2D tex9; \
        uniform sampler2D tex10; \
        uniform sampler2D tex11; \
        uniform sampler2D tex12; \
        uniform sampler2D tex13; \
        uniform sampler2D tex14; \
        uniform sampler2D tex15; \
        void main() \
        { \
            gl_FragColor = texture2D(tex15, gl_TexCoord[0].xy); \
        } \
        ");

    }
    else
    {
        // DirectX
        frag = HighLevelGpuProgramManager::getSingleton().createProgram("frag16", TRANSIENT_RESOURCE_GROUP,
        "hlsl", GPT_FRAGMENT_PROGRAM);
        frag->set("target", "ps_2_0");
        frag->set("entry_point", "main");
        frag->setProgramCode(" \
        float4 main( \
        float2 uv : TEXCOORD0, \
        uniform sampler2D tex0 : register(s0), \
        uniform sampler2D tex1 : register(s1), \
        uniform sampler2D tex2 : register(s2), \
        uniform sampler2D tex3 : register(s3), \
        uniform sampler2D tex4 : register(s4), \
        uniform sampler2D tex5 : register(s5), \
        uniform sampler2D tex6 : register(s6), \
        uniform sampler2D tex7 : register(s7), \
        uniform sampler2D tex8 : register(s8), \
        uniform sampler2D tex9 : register(s9), \
        uniform sampler2D tex10 : register(s10), \
        uniform sampler2D tex11 : register(s11), \
        uniform sampler2D tex12 : register(s12), \
        uniform sampler2D tex13 : register(s13), \
        uniform sampler2D tex14 : register(s14), \
        uniform sampler2D tex15 : register(s15) \
        ) : COLOR \
        { \
            return tex2D(tex15, uv); \
        } \
        ");
    }
    frag->load();

    MaterialPtr mat = MaterialManager::getSingleton().create("test16", TRANSIENT_RESOURCE_GROUP);
    ShaderCh * p = mat->get(0)->get(0);
    p->getProgram().set(ST_VS, 0, "Ogre/BasicVertexPrograms/AmbientOneTextureUnified");
    p->getProgram().set(ST_FS, 0, frag->getName());
    // create 15 textures the same
    for(int i = 0; i < 15; ++i)
    {
        p->getTexture().create("Dirt.jpg");
    }
    // create 16th texture differently
    p->getTexture().create("ogrelogo.png");
    if (StringUtil::match(Root::getSingleton().getRender()->getName(), "*GL*"))
    {
        // map samplers
        GpuProgramParam * params;
        p->getProgram().get(0, ST_FS, NULL, params);
        for(int i = 0; i < 16; ++i)
        {
            params->set(String("tex") + StrConv::conv(i), i);
        }

    }

    mat->load();

    GeometrySpace * e = mSceneMgr->createGeo("1", "knot.mesh");
    e->setMaterial(mat->getName());
    static_cast<SpaceNode *>(mSceneMgr->getOriginNode()->create())->attachObject(e);

    mCamera->setPos(NII::Vector3f(0, 0, 250));
    mCamera->lookAt(NII::Vector3f(0, 0, 0));


}
//----------------------------------------------------------------------------
//----------------------------------------------------------------------------

PlayPen_2bppAlphaPVR::PlayPen_2bppAlphaPVR()
{
    mInfo["Title"] = "PlayPen_2bppAlphaPVR";
    mInfo["Description"] = "Tests 2bpp pvr w/ alpha.";
    addScreenshotFrame(10);
}
//----------------------------------------------------------------------------
void PlayPen_2bppAlphaPVR::setupContent()
{
    NII::ResourceSchemeManager::getSingleton().setup("Tests");

    MaterialPtr mat = MaterialManager::getSingleton().create("testpvr",
        TRANSIENT_RESOURCE_GROUP);
    ShaderCh * p = mat->get(0)->get(0);
    p->setLight(false);
    p->setCullingMode(CM_None);
    p->setBlend(ShaderCh::SOT_Set)->setBlend(FBM_INV_ALPHA);
    ShaderChTextureUnit * t = p->getTexture().create("ogreborderUp_pvr2a.pvr");
    GeometrySpace * e = mSceneMgr->createGeo("Plane", GSP_Plane);
    e->setMaterial(mat->getName());
    static_cast<SpaceNode *>(mSceneMgr->getOriginNode()->create())->attachObject(e);
    mWindow->getViewport(0)->setBgColour(Colour::Red);

    mCamera->setPos(NII::Vector3f(0,0,300));
    mCamera->lookAt(Vector3::ZERO);
}
//----------------------------------------------------------------------------
void PlayPen_2bppAlphaPVR::testCapabilities(const Ogre::RenderSysFeature * caps)
{
    Codec* codec = Codec::getCodec("pvr");
    if (!codec)
        throw Ogre::Exception(999, "No support for PVR textures.", "testCapabilities");
}
//----------------------------------------------------------------------------
//----------------------------------------------------------------------------

PlayPen_2bppPVR::PlayPen_2bppPVR()
{
    mInfo["Title"] = "PlayPen_2bppPVR";
    mInfo["Description"] = "Tests 2 bpp pvr.";
    addScreenshotFrame(10);
}
//----------------------------------------------------------------------------

void PlayPen_2bppPVR::setupContent()
{
    NII::ResourceSchemeManager::getSingleton().setup("Tests");

    MaterialPtr mat = MaterialManager::getSingleton().create("testpvr",
        TRANSIENT_RESOURCE_GROUP);
    ShaderCh * p = mat->get(0)->get(0);
    p->setLight(false);
    p->setCullingMode(CM_None);
    p->setBlend(ShaderCh::SOT_Set)->setBlend(FBM_INV_ALPHA);
    ShaderChTextureUnit* t = p->getTexture().create("ogreborderUp_pvr2.pvr");
    GeometrySpace *e = mSceneMgr->createGeo("Plane", GSP_Plane);
    e->setMaterial(mat->getName());
    static_cast<SpaceNode *>(mSceneMgr->getOriginNode()->create())->attachObject(e);
    mWindow->getViewport(0)->setBgColour(Colour::Red);

    mCamera->setPos(NII::Vector3f(0,0,300));
    mCamera->lookAt(Vector3::ZERO);
}
//----------------------------------------------------------------------------

void PlayPen_2bppPVR::testCapabilities(const Ogre::RenderSysFeature* caps)
{
    Codec * codec = Codec::getCodec("pvr");
    if(!codec)
        throw Ogre::Exception(999, "No support for PVR textures.", "testCapabilities");
}
//----------------------------------------------------------------------------
//----------------------------------------------------------------------------

PlayPen_2Spotlights::PlayPen_2Spotlights()
{
    mInfo["Title"] = "PlayPen_2Spotlights";
    mInfo["Description"] = "Tests 2 spotlights on one mesh.";
    addScreenshotFrame(10);
}
//----------------------------------------------------------------------------

void PlayPen_2Spotlights::setupContent()
{
    SpaceNode* mTestNode[5];
    mSceneMgr->setAmbient(Colour(0.3, 0.3, 0.3));

    Light* mLight = mSceneMgr->createLight("MainLight");
    // Spotlight test
    mLight->setType(LT_SPOT);
    mLight->setDiffuse(1.0, 0.0, 0.8);
    mLight->setSpotlightInner(Angle(30));
    mLight->setSpotlightOuter(Angle(40));
    mLight->setSpotlightFalloff(1.0);
    mTestNode[0] = mSceneMgr->getOriginNode()->create();
    mTestNode[0]->setPos(Vector3f(800, 600, 0));
    mTestNode[0]->lookAt(Vector3(800,0,0), PosNode::SM_Space, Vector3::Z);
    mTestNode[0]->attachObject(mLight);

    mTestNode[1] = mSceneMgr->getOriginNode()->create();
    mLight = mSceneMgr->createLight("AnotherLight");
    // Spotlight test
    mLight->setType(LT_SPOT);
    mLight->setDiffuse(0, 1.0, 0.8);
    mLight->setSpotlightInner(Angle(30));
    mLight->setSpotlightOuter(Angle(40));
    mLight->setSpotlightFalloff(1.0);
    mTestNode[1] = mSceneMgr->getOriginNode()->create();
    mTestNode[1]->setPos(Vector3f(0, 600, 800));
    mTestNode[1]->lookAt(Vector3(0,0,800), PosNode::SM_Space, Vector3::Z);
    mTestNode[1]->attachObject(mLight);


    Plane plane;
    plane.normal = Vector3::Y;
    plane.d = 100;
    MeshManager::getSingleton().createPlane("Myplane",
    TRANSIENT_RESOURCE_GROUP, plane,
    3500,3500,100,100,true,1,5,5,Vector3::Z);
    GeometrySpace* pPlaneEnt;
    pPlaneEnt = mSceneMgr->createGeo( "plane", "Myplane" );
    pPlaneEnt->setMaterial("2 - Default");
    static_cast<SpaceNode *>(mSceneMgr->getOriginNode()->create())->attachObject(pPlaneEnt);

    mCamera->setPos(NII::Vector3f(-600,300,-600));
    mCamera->lookAt(NII::Vector3f(300, 0, 300));

}
//----------------------------------------------------------------------------
//----------------------------------------------------------------------------

PlayPen_4bppAlphaPVR::PlayPen_4bppAlphaPVR()
{
    mInfo["Title"] = "PlayPen_4bppAlphaPVR";
    mInfo["Description"] = "Tests 4bpp pvr with alpha.";
    addScreenshotFrame(10);
}
//----------------------------------------------------------------------------

void PlayPen_4bppAlphaPVR::setupContent()
{
    NII::ResourceSchemeManager::getSingleton().setup("Tests");

    MaterialPtr mat = MaterialManager::getSingleton().create("testpvr",
        TRANSIENT_RESOURCE_GROUP);
    ShaderCh * p = mat->get(0)->get(0);
    p->setLight(false);
    p->setCullingMode(CM_None);
    p->setBlend(ShaderCh::SOT_Set)->setBlend(FBM_INV_ALPHA);
    ShaderChTextureUnit* t = p->getTexture().create("ogreborderUp_pvr4a.pvr");
    GeometrySpace *e = mSceneMgr->createGeo("Plane", GSP_Plane);
    e->setMaterial(mat->getName());
    static_cast<SpaceNode *>(mSceneMgr->getOriginNode()->create())->attachObject(e);
    mWindow->getViewport(0)->setBgColour(Colour::Red);

    mCamera->setPos(NII::Vector3f(0,0,300));
    mCamera->lookAt(Vector3::ZERO);
}
//----------------------------------------------------------------------------

void PlayPen_4bppAlphaPVR::testCapabilities(const Ogre::RenderSysFeature* caps)
{
    Codec* codec = Codec::getCodec("pvr");
    if (!codec)
        throw Ogre::Exception(999, "No support for PVR textures.", "testCapabilities");
}
//----------------------------------------------------------------------------
//----------------------------------------------------------------------------

PlayPen_4bppPVR::PlayPen_4bppPVR()
{
    mInfo["Title"] = "PlayPen_4bppPVR";
    mInfo["Description"] = "Tests 4bpp pvr.";
    addScreenshotFrame(10);
}
//----------------------------------------------------------------------------

void PlayPen_4bppPVR::setupContent()
{
    Ogre::ResourceSchemeManager::getSingleton().setup("Tests");

    MaterialPtr mat = MaterialManager::getSingleton().create("testpvr",
        TRANSIENT_RESOURCE_GROUP);
    ShaderCh * p = mat->get(0)->get(0);
    p->setLight(false);
    p->setCullingMode(CM_None);
    p->setBlend(ShaderCh::SOT_Set)->setBlend(FBM_INV_ALPHA);
    ShaderChTextureUnit* t = p->getTexture().create("ogreborderUp_pvr4.pvr");
    GeometrySpace *e = mSceneMgr->createGeo("Plane", GSP_Plane);
    e->setMaterial(mat->getName());
    static_cast<SpaceNode *>(mSceneMgr->getOriginNode()->create())->attachObject(e);
    mWindow->getViewport(0)->setBgColour(Colour::Red);

    mCamera->NiiRenderFrameListener(NII::Vector3f(0,0,300));
    mCamera->lookAt(Vector3::ZERO);
}
//----------------------------------------------------------------------------

void PlayPen_4bppPVR::testCapabilities(const Ogre::RenderSysFeature* caps)
{
    Codec* codec = Codec::getCodec("pvr");
    if (!codec)
        throw Ogre::Exception(999, "No support for PVR textures.", "testCapabilities");
}
//----------------------------------------------------------------------------
//----------------------------------------------------------------------------

PlayPen_AlphaToCoverage::PlayPen_AlphaToCoverage()
{
    mInfo["Title"] = "PlayPen_AlphaToCoverage";
    mInfo["Description"] = "Tests alpha to coverage support.";
    addScreenshotFrame(10);
}
//----------------------------------------------------------------------------
void PlayPen_AlphaToCoverage::setupContent()
{
    MaterialPtr mat = MaterialManager::getSingleton().create("testa2c", TRANSIENT_RESOURCE_GROUP);
    ShaderCh * p = mat->get(0)->get(0);
    p->setColour(ShaderCh::SOT_Set)->setAlphaReject(CM_GREATER);
    p->setColour(ShaderCh::SOT_Set)->setValue(96);
    p->setColour(ShaderCh::SOT_Set)->setAlphaCoverage(false);
    p->setLight(false);
    p->setCullingMode(CM_None);
    p->setColour(ShaderCh::SOT_Set)->setAlphaCoverage(true);
    ShaderChTextureUnit* t = p->getTexture().create("leaf.png");
    t->setUAddressing(TAM_CLAMP);
    t->setVAddressing(TAM_CLAMP);
    t->setWAddressing(TAM_CLAMP);
    GeometrySpace *e = mSceneMgr->createGeo("PlaneA2C", GSP_Plane);
    e->setMaterial(mat->getName());
    static_cast<SpaceNode *>(mSceneMgr->getOriginNode()->create(Vector3(100, 0, 0)))->attachObject(e);

    mat = MaterialManager::getSingleton().create("testnoa2c", TRANSIENT_RESOURCE_GROUP);
    p = mat->get(0)->get(0);
    p->setColour(ShaderCh::SOT_Set)->setAlphaReject(CM_GREATER);
    p->setColour(ShaderCh::SOT_Set)->setValue(96);
    p->setColour(ShaderCh::SOT_Set)->setAlphaCoverage(false);
    p->setLight(false);
    p->setCullingMode(CM_None);
    p->getStencil().setAlphaCoverage(false);
    t = p->getTexture().create("leaf.png");
    t->setUAddressing(TAM_CLAMP);
    t->setVAddressing(TAM_CLAMP);
    t->setWAddressing(TAM_CLAMP);
    e = mSceneMgr->createGeo("PlaneNoA2C", GSP_Plane);
    e->setMaterial(mat->getName());
    static_cast<SpaceNode *>(mSceneMgr->getOriginNode()->create(Vector3(-100, 0, 0)))->attachObject(e);

    mat = MaterialManager::getSingleton().create("bg", TRANSIENT_RESOURCE_GROUP);
    p = mat->get(0)->get(0);
    p->setLight(false);
    p->setCullingMode(CM_None);
    t = p->getTexture().create();
    t->getColourBlend()->setBlend(TBO_OPERAND1, Colour::White, TBS_PRE_TEXTURE);
    e = mSceneMgr->createGeo("PlaneBg", GSP_Plane);
    e->setMaterial(mat->getName());
    e->setRenderGroup(RQG_Bg);
    SpaceNode * s = mSceneMgr->getOriginNode()->create(Vector3(0, 0, -10));
    s->setScale(Vector3f(5, 5, 5));
    s->attachObject(e);

    mCamera->setPos(NII::Vector3f(0, 0, 300));
    mCamera->lookAt(Vector3::ZERO);
}
//----------------------------------------------------------------------------
//----------------------------------------------------------------------------

PlayPen_AttachObjectsToBones::PlayPen_AttachObjectsToBones()
{
    mInfo["Title"] = "PlayPen_AttachObjectsToBones";
    mInfo["Description"] = "Tests attaching objectes to bones.";
    addScreenshotFrame(120);
}
//----------------------------------------------------------------------------

void PlayPen_AttachObjectsToBones::setupContent()
{
    GeometrySpace *ent;
    for (int i = 0; i < 12; ++i)
    {
        ent = mSceneMgr->createGeo("robot" + StrConv::conv(i), "robot.mesh");
        if (i % 2)
        {
            GeometrySpace * ent2 = mSceneMgr->createGeo("plane" + StrConv::conv(i), "razor.mesh");
            ent->attach("Joint8", ent2);
        }
        else
        {
            ParticleSpace * psys = mSceneMgr->createParticleSpace("psys" + StrConv::conv(i), "Examples/PurpleFountain");
            psys->getSpread(0)->setMinTTL(0.2);
            psys->getSpread(0)->setMaxTTL(0.2);
            ent->attach("Joint15", psys);
        }
        // Add entity to the scene node
        static_cast<SpaceNode *>(mSceneMgr->getOriginNode()->create(
            Vector3(0, 0, (i * 200) - (12 * 200 / 2))))->attachObject(ent);

        ent->getSpaceNode()->yaw(Angle(i * 45));

        AnimationFusion * animState = ent->getFusion("Walk");
        animState->setEnabled(true);
        mAnimStateList.push_back(animState);
    }

    // Give it a little ambience with lights
    Light * l;
    l = mSceneMgr->createLight("BlueLight");
    l->setPos(Vecotr3f(-200, -80, -100));
    l->setDiffuse(0.5, 0.5, 1.0);

    l = mSceneMgr->createLight("GreenLight");
    l->setPos(Vecotr3f(0, 0, -100));
    l->setDiffuse(0.5, 1.0, 0.5);

    // Position the camera
    mCamera->setPos(NII::Vector3f(400,120,500));
    mCamera->lookAt(NII::Vector3f(-50,50,0));

    mSceneMgr->setAmbient(Colour(1, 1, 1, 1));
    //mSceneMgr->setAABBView(true);
}
//----------------------------------------------------------------------------
//----------------------------------------------------------------------------

PlayPen_BasicPlane::PlayPen_BasicPlane()
{
    mInfo["Title"] = "PlayPen_BasicPlane";
    mInfo["Description"] = "Tests basic planes.";
    addScreenshotFrame(10);
}
//----------------------------------------------------------------------------
void PlayPen_BasicPlane::setupContent()
{
    /*
    // Create a light
    Light* l = mSceneMgr->createLight("MainLight");
    // Accept default settings: point light, white diffuse, just set position
    // NB I could attach the light to a SpaceNode if I wanted it to move automatically with
    //  other objects, but I don't
    l->setPos(Vecotr3f(20, 80, 50));
    */

    // Create a point light
    Light * l = mSceneMgr->createLight("MainLight");
    l->setType(LT_DIRECTIONAL);
    l->setDirection(-Vector3::Y);
    GeometrySpace * ent;

    // Define a floor plane mesh
    Plane p;
    p.normal = Vector3::Y;
    p.d = 200;
    MeshManager::getSingleton().createPlane("FloorPlane",
    TRANSIENT_RESOURCE_GROUP,
    p,2000,2000,1,1,true,1,5,5,Vector3::Z);

    // Create an entity (the floor)
    ent = mSceneMgr->createGeo("floor", "FloorPlane");
    ent->setMaterial("Examples/RustySteel");

    mSceneMgr->getOriginNode()->attachObject(ent);

    GeometrySpace* sphereEnt = mSceneMgr->createGeo("ogre", "ogrehead.mesh");

    SpaceNode* mRootNode = mSceneMgr->getOriginNode();
    SpaceNode* node = mSceneMgr->createSpaceNode(0);
    node->attachObject(sphereEnt);
    mRootNode->add(node);

}
//----------------------------------------------------------------------------
//----------------------------------------------------------------------------

PlayPen_BillboardAccurateFacing::PlayPen_BillboardAccurateFacing()
{
    mInfo["Title"] = "PlayPen_BillboardAccurateFacing";
    mInfo["Description"] = "Tests billboard facing.";
    addScreenshotFrame(10);
}
//----------------------------------------------------------------------------

void PlayPen_BillboardAccurateFacing::setupContent()
{
    mSceneMgr->setAmbient(Colour(0.5, 0.5, 0.5));
    Vector3 dir(-1, -1, 0.5);
    dir.normalise();
    Light* l = mSceneMgr->createLight("light1");
    l->setType(LT_DIRECTIONAL);
    l->setDirection(dir);

    Plane plane;
    plane.normal = Vector3::Y;
    plane.d = 100;
    MeshManager::getSingleton().createPlane("Myplane",
    TRANSIENT_RESOURCE_GROUP, plane,
    1500,1500,10,10,true,1,5,5,Vector3::Z);
    GeometrySpace* pPlaneEnt = mSceneMgr->createGeo( "plane", "Myplane" );
    pPlaneEnt->setMaterial("2 - Default");
    pPlaneEnt->setCastShadow(false);
    static_cast<SpaceNode *>(mSceneMgr->getOriginNode()->create())->attachObject(pPlaneEnt);

    ParticleCtrl * bbs = mSceneMgr->createParticleCtrl("1", 20);
    bbs->setParticleWidth(50);
    bbs->setParticleHeight(50);
    bbs->create(Vector3f(-100, 25, 0));
    bbs->setCtrlMode(CM_Parallel_Ctrl);
    bbs->setCtrlDirection(Vector3::Y);
    static_cast<SpaceNode *>(mSceneMgr->getOriginNode()->create())->attachObject(bbs);

    bbs = mSceneMgr->createParticleCtrl("2", 20);
    bbs->setParticleWidth(50);
    bbs->setParticleHeight(50);
    bbs->create(Vector3f(100, 25, 0));
    bbs->setParallelView(true);
    bbs->setCtrlMode(CM_Parallel_Ctrl);
    bbs->setCtrlDirection(Vector3::Y);
    static_cast<SpaceNode *>(mSceneMgr->getOriginNode()->create())->attachObject(bbs);

    mCamera->setPos(NII::Vector3f(200,120,300));
    mCamera->lookAt(NII::Vector3f(0,0,0));
}
//----------------------------------------------------------------------------
//----------------------------------------------------------------------------

PlayPen_BillboardChain::PlayPen_BillboardChain()
{
    mInfo["Title"] = "PlayPen_BillboardChain";
    mInfo["Description"] = "Tests billboard chains.";
    addScreenshotFrame(10);
}
//----------------------------------------------------------------------------

void PlayPen_BillboardChain::setupContent()
{
    mSceneMgr->setAmbient(Colour(0.5, 0.5, 0.5));
    Vector3 dir(-1, -1, 0.5);
    dir.normalise();
    Light* l = mSceneMgr->createLight("light1");
    l->setType(LT_DIRECTIONAL);
    l->setDirection(dir);

    Plane plane;
    plane.normal = Vector3::Y;
    plane.d = 100;
    MeshManager::getSingleton().createPlane("Myplane",
    TRANSIENT_RESOURCE_GROUP, plane,
    1500,1500,10,10,true,1,5,5,Vector3::Z);
    GeometrySpace* pPlaneEnt = mSceneMgr->createGeo( "plane", "Myplane" );
    pPlaneEnt->setMaterial("2 - Default");
    pPlaneEnt->setCastShadow(false);
    static_cast<SpaceNode *>(mSceneMgr->getOriginNode()->create())->attachObject(pPlaneEnt);

    PixelChain* chain = static_cast<PixelChain*>(
        mSceneMgr->createSpace(1, N_FACTORY_PIXELCHAIN));
    chain->setTextureCoord(true);
    chain->setVertexColour(false);

    Pixel elem;
    elem.width = 10;
    elem.mCoord = 0;
    elem.mPos = Vector3(0,20,0);
    chain->add(0, elem);
    elem.mPos = Vector3(20,0,0);
    elem.mCoord = 1.0;
    chain->add(0, elem);
    elem.mPos = Vector3(40,10,0);
    elem.mCoord = 2.0;
    chain->add(0, elem);
    elem.mPos = Vector3(60,20,0);
    elem.mCoord = 3.0;
    chain->add(0, elem);
    elem.mPos = Vector3(80,40,0);
    elem.mCoord = 4.0;
    chain->add(0, elem);
    elem.mPos = Vector3(100,70,0);
    elem.mCoord = 5.0;
    chain->add(0, elem);

    chain->setMaterial("Examples/RustySteel");
    static_cast<SpaceNode *>(mSceneMgr->getOriginNode()->create())->attachObject(chain);

    mSceneMgr->setAABBView(true);

    mCamera->setPos(Ogre::Vector3f(-20,60,200));
    mCamera->lookAt(Ogre::Vector3f(60,40,0));
}
//----------------------------------------------------------------------------
//----------------------------------------------------------------------------

PlayPen_BillboardOrigins::PlayPen_BillboardOrigins()
{
    mInfo["Title"] = "PlayPen_BillboardOrigins";
    mInfo["Description"] = "Tests setting billboard origins.";
    addScreenshotFrame(10);
}
//----------------------------------------------------------------------------

void PlayPen_BillboardOrigins::setupContent()
{
    mSceneMgr->setAmbient(Colour(0.5, 0.5, 0.5));
    Vector3 dir(-1, -1, 0.5);
    dir.normalise();
    Light* l = mSceneMgr->createLight("light1");
    l->setType(LT_DIRECTIONAL);
    l->setDirection(dir);

    ParticleCtrl* bbs = mSceneMgr->createParticleCtrl("1", 20);
    bbs->setParticleWidth(50);
    bbs->setParticleHeight(50);
    bbs->create(Vector3f(0, 0, 0));
    bbs->setOriginType(OT_Top_Left);
    bbs->setMaterial("2 - Default");
    //bbs->setCtrlMode(CM_Parallel_Ctrl);
    bbs->setCtrlDirection(Vector3::Y);
    static_cast<SpaceNode *>(mSceneMgr->getOriginNode()->create())->attachObject(bbs);

    bbs = mSceneMgr->createParticleCtrl("2", 20);
    bbs->setParticleWidth(50);
    bbs->setParticleHeight(50);
    bbs->create(Vector3f(0, -10, 0));
    bbs->setOriginType(OT_Center);
    bbs->setMaterial("Examples/RustySteel");
    //bbs->setCtrlMode(CM_Parallel_Ctrl);
    bbs->setCtrlDirection(Vector3::Y);
    static_cast<SpaceNode *>(mSceneMgr->getOriginNode()->create())->attachObject(bbs);

    bbs = mSceneMgr->createParticleCtrl("3", 20);
    bbs->setParticleWidth(50);
    bbs->setParticleHeight(50);
    bbs->create(Vector3f(0, -20, 0));
    bbs->setOriginType(OT_Bottom_Right);
    bbs->setMaterial("Examples/OgreLogo");
    //bbs->setCtrlMode(CM_Parallel_Ctrl);
    bbs->setCtrlDirection(Vector3::Y);
    static_cast<SpaceNode *>(mSceneMgr->getOriginNode()->create())->attachObject(bbs);

    mCamera->setPos(Ogre::Vector3f(0,160,1));
    mCamera->lookAt(Ogre::Vector3f(0,0,0));
}
//----------------------------------------------------------------------------
//----------------------------------------------------------------------------

PlayPen_BillboardTextureCoords::PlayPen_BillboardTextureCoords()
{
    mInfo["Title"] = "PlayPen_BillboardTextureCoords";
    mInfo["Description"] = "Tests setting billboard texture coordinates.";
    addScreenshotFrame(10);
}
//----------------------------------------------------------------------------

void PlayPen_BillboardTextureCoords::setupContent()
{
    mSceneMgr->setAmbient(Colour::White);

    ParticleCtrl* bbs = mSceneMgr->createParticleCtrl("test", 20);
    ParticleCtrl* bbs2 = mSceneMgr->createParticleCtrl("test2", 20);
    float xsegs = 3;
    float ysegs = 3;
    float width = 300;
    float height = 300;
    float gap = 20;

    // set up texture coords
    bbs->setTexCoordGrid(ysegs, xsegs);
    bbs->setParticleWidth(width/xsegs);
    bbs->setParticleHeight(height/xsegs);
    bbs2->setParticleWidth(width/xsegs);
    bbs2->setParticleHeight(height/xsegs);
    for (float y = 0; y < ysegs; ++y)
    {
        for (float x = 0; x < xsegs; ++x)
        {
            Vector3 midPoint;
            midPoint.x = (x * width / xsegs) + ((x-1) * gap);
            midPoint.y = (y * height / ysegs) + ((y-1) * gap);
            midPoint.z = 0;
            SyncParticle* bb = bbs->create(midPoint);
            bb->setCtrlTexCoord((ysegs - y - 1) * xsegs + x);
            SyncParticle* bb2 = bbs2->create(midPoint);
            bb2->setTexCoordRect(Rectf((x + 0) / xsegs, (ysegs - y - 1) / ysegs,
                (x + 1) / xsegs, (ysegs - y - 0) / ysegs));
        }
    }

    bbs->setMaterial("Examples/OgreLogo");
    bbs2->setMaterial("Examples/OgreLogo");
    static_cast<SpaceNode *>(mSceneMgr->getOriginNode()->create())->attachObject(bbs);
    static_cast<SpaceNode *>(mSceneMgr->getOriginNode()->create(Vector3(- (width + xsegs * gap), 0, 0)))
    ->attachObject(bbs2);

    mCamera->setPos(NII::Vector3f(-100,150,900));
}
//----------------------------------------------------------------------------
//----------------------------------------------------------------------------

PlayPen_BlendDiffuseColour::PlayPen_BlendDiffuseColour()
{
    mInfo["Title"] = "PlayPen_BlendDiffuseColour";
    mInfo["Description"] = "Tests diffuse blending.";
    addScreenshotFrame(10);
}
//----------------------------------------------------------------------------
void PlayPen_BlendDiffuseColour::setupContent()
{
    MaterialPtr mat = MaterialManager::getSingleton().create(
    "testBlendDiffuseColour", TRANSIENT_RESOURCE_GROUP);
    ShaderCh * pass = mat->get(0)->get(0);
    // no lighting, it will mess up vertex colours
    pass->setLight(false);
    // Make sure we pull in vertex colour as diffuse
    pass->setColour(ShaderCh::SOT_Set)->setColourTracking(CM_T_DIFFUSE);
    // Base layer
    ShaderChTextureUnit* t = pass->getTexture().create("BeachStones.jpg");
    // don't want to bring in vertex diffuse on base layer
    t->getColourBlend()->setColourBlend(TBM_Src_Replace_Dst);
    // Second layer (lerp based on colour)
    t = pass->getTexture().create("terr_dirt-grass.jpg");
    t->getColourBlend()->setBlend(TBO_ADD_SPECULAR, TBS_TEXTURE, TBS_PRE_TEXTURE);
    // third layer (lerp based on alpha)
    CustomSpaceObj* man = mSceneMgr->createCustomGeo("quad");
    man->begin(GeometryRaw::OT_TRIANGLE_LIST, "testBlendDiffuseColour");
    man->position(-100, 100, 0);
    man->textureCoord(0,0);
    man->colour(0, 0, 0);
    man->position(-100, -100, 0);
    man->textureCoord(0,1);
    man->colour(0.5, 0.5, 0.5);
    man->position(100, -100, 0);
    man->textureCoord(1,1);
    man->colour(1, 1, 1);
    man->position(100, 100, 0);
    man->textureCoord(1,0);
    man->colour(0.5, 0.5, 0.5);
    man->quad(0, 1, 2, 3);
    man->end();

    mSceneMgr->getOriginNode()->attachObject(man);

    mCamera->setPos(NII::Vector3f(0, 0, 250));

}
//----------------------------------------------------------------------------
//----------------------------------------------------------------------------

PlayPen_BlitSubTextures::PlayPen_BlitSubTextures()
{
    mInfo["Title"] = "PlayPen_BlitSubTextures";
    mInfo["Description"] = "Tests blitting textures onto on another.";
    addScreenshotFrame(10);
}
//----------------------------------------------------------------------------

void PlayPen_BlitSubTextures::setupContent()
{
    Image img;
    img.load("ogrelogo.png", TRANSIENT_RESOURCE_GROUP);

    TexturePtr tex = N_Only(TextureManager).createTexture( "testblitdst",
        TRANSIENT_RESOURCE_GROUP, TEX_TYPE_2D, 1024, 1024, 1, 0, PF_R8G8B8A8ui);

    PixelBlock srcBox;
    // this box should select from halfway through the head, to the 'OG' part of the logo
    srcBox.left = 376;
    srcBox.top = 379;
    srcBox.right = 376 + 224;
    srcBox.bottom = 379 + 278;
    srcBox.back = 1;
    srcBox.front = 0;
    srcBox.format = img.getFormat();
    srcBox.data = img.getData();
    srcBox.rowPitch = img.getWidth();
    srcBox.slicePitch = img.getWidth() * img.getHeight();

    Box dstBox;
    dstBox.left = srcBox.left;
    dstBox.top = srcBox.top;
    dstBox.right = srcBox.right;
    dstBox.bottom = srcBox.bottom;
    dstBox.back = 1;
    dstBox.front = 0;

    // I was getting uninitialized memory written to the texture buffer, so clear it explicitly
    memset(tex->getBuffer()->lock(0, tex->getBuffer()->getSize(),
        Buffer::MM_READ | Buffer::MM_WRITE), 0, tex->getBuffer()->getSize());
    tex->getBuffer()->unlock();

    tex->getBuffer()->write(srcBox, dstBox);

    MaterialPtr mat = MaterialManager::getSingleton().create("testblit",
        TRANSIENT_RESOURCE_GROUP);
    ShaderCh * p = mat->get(0)->get(0);
    p->setLight(false);
    p->setCullingMode(CM_None);
    ShaderChTextureUnit* t = p->getTexture().create(tex->getName());
    GeometrySpace *e = mSceneMgr->createGeo("Plane", GSP_Plane);
    e->setMaterial(mat->getName());
    static_cast<SpaceNode *>(mSceneMgr->getOriginNode()->create())->attachObject(e);

    mCamera->setPos(NII::Vector3f(0, 0, 300));
    mCamera->lookAt(Vector3::ZERO);

    mWindow->getViewport(0)->setBgColour(Colour::Green);


}
//----------------------------------------------------------------------------
//----------------------------------------------------------------------------

PlayPen_Bsp::PlayPen_Bsp()
{
    mInfo["Title"] = "PlayPen_Bsp";
    mInfo["Description"] = "Tests BSP plugin.";
    addScreenshotFrame(10);
}
//----------------------------------------------------------------------------

void PlayPen_Bsp::setupContent()
{
    // Load Quake3 locations from a file
    ConfigFile cf;

    cf.load(mFSLayer->getConfigFilePath("quakemap.cfg"));

    String quakePk3 = cf.getSetting("Archive");
    String quakeLevel = cf.getSetting("Map");

    ResourceSchemeManager::getSingleton().add(quakePk3, "Zip");

    // Load world geometry
    mSceneMgr->setSceneGeo(quakeLevel);

    // modify camera for close work
    mCamera->setNearClipDistance(4);
    mCamera->setFarClipDistance(4000);

    // Also change position, and set Quake-type orientation
    // Get random player start point
    ViewPoint vp = static_cast<BspSceneManager *>(mSceneMgr)->getSuggestedViewpoint(true);
    mCamera->setPos(vp.position);
    mCamera->pitch(Angle(90)); // Quake uses X/Y horizon, Z up
    mCamera->rotate(vp.orientation);
    // Don't yaw along variable axis, causes leaning
    mCamera->setCustomYaw(true, Vector3::Z);

    mCamera->yaw(Ogre::Angle(-90.f));
}
//----------------------------------------------------------------------------
//----------------------------------------------------------------------------

PlayPen_BuildTangentOnAnimatedMesh::PlayPen_BuildTangentOnAnimatedMesh()
{
    mInfo["Title"] = "PlayPen_BuildTangentOnAnimatedMesh";
    mInfo["Description"] = "Tests building tangents for an animated mesh.";
    addScreenshotFrame(50);
}
//----------------------------------------------------------------------------

void PlayPen_BuildTangentOnAnimatedMesh::setupContent()
{
    SpaceNode* mTestNode[2];
    Light* mLight = 0;
    //mSceneMgr->getRenderPattern()->setTextureDim(512);
    //mSceneMgr->setShadowTechnique(SHADOWTYPE_STENCIL_ADDITIVE);
    //mSceneMgr->getRenderPattern()->setMaxExtent(1500);
    //mSceneMgr->setShadowColour(Colour(0.35, 0.35, 0.35));
    //mSceneMgr->getRenderPattern()->setMaxExtent(800);
    // Set ambient light
    mSceneMgr->setAmbient(Colour(0.3, 0.3, 0.3));

    mLight = mSceneMgr->createLight("MainLight");

    /*/
    // Directional test
    mLight->setType(LT_DIRECTIONAL);
    Vector3 vec(-1,-1,0);
    vec.normalise();
    mLight->setDirection(vec);
    /*/
    // Point test
    mLight->setType(LT_POINT);
    mLight->setPos(Vecotr3f(0, 200, 0));
    //*/
    MeshPtr pMesh = N_Only(Mesh).load("ninja.mesh", TRANSIENT_RESOURCE_GROUP
    /*,
    Buffer::M_WRITE,
    Buffer::Buffer::M_DEV | Buffer::M_WRITE,
    true, true*/); //so we can still read it
    // Build tangent vectors, all our meshes use only 1 texture coordset
    unsigned short src, dest;
    if(!pMesh->checkTangentBuffer(false))
    {
        pMesh->buildTangentBuffer(VT_Tangent);
    }

    GeometrySpace* pEnt = mSceneMgr->createGeo("Ninja", "ninja.mesh");

    /*/
    mAnimState = pEnt->getFusion("Walk");
    mAnimState->setEnabled(true);
    /*/
    pEnt->getFusion("Walk")->setEnabled(true);
    //*/
    mTestNode[1] = mSceneMgr->getOriginNode()->create();
    mTestNode[1]->attachObject( pEnt );
    mTestNode[1]->translate(Vector3f(-100, -100, 0));


    Plane plane;
    plane.normal = Vector3::Y;
    plane.d = 100;
    MeshManager::getSingleton().createPlane("Myplane",
    TRANSIENT_RESOURCE_GROUP, plane,
    1500,1500,10,10,true,1,5,5,Vector3::Z);
    GeometrySpace* pPlaneEnt;
    pPlaneEnt = mSceneMgr->createGeo( "plane", "Myplane" );
    pPlaneEnt->setMaterial("2 - Default");
    pPlaneEnt->setCastShadow(false);
    static_cast<SpaceNode *>(mSceneMgr->getOriginNode()->create())->attachObject(pPlaneEnt);

    mCamera->setPos(NII::Vector3f(0,0,400));
}
//----------------------------------------------------------------------------
//----------------------------------------------------------------------------

PlayPen_ClearScene::PlayPen_ClearScene()
    :mFramesElapsed(0)
{
    mInfo["Title"] = "PlayPen_ClearScene";
    mInfo["Description"] = "Tests clearing a running scene.";
    addScreenshotFrame(25);
}
//----------------------------------------------------------------------------

bool PlayPen_ClearScene::onPreRender(const Ogre::RenderFrameArgs * evt)
{
    ++mFramesElapsed;
    if(mFramesElapsed == 20)
        mSceneMgr->destroyAllCreateObj();
    return true;
}
//----------------------------------------------------------------------------

void PlayPen_ClearScene::setupContent()
{
    // Define a floor plane mesh
    Plane p;
    p.normal = Vector3::Y;
    p.d = 200;
    MeshManager::getSingleton().createPlane("FloorPlane",
    TRANSIENT_RESOURCE_GROUP,
    p,200000,200000,20,20,true,1,50,50,Vector3::Z);

    GeometrySpace* planeEnt;
    planeEnt = mSceneMgr->createGeo( "plane", "FloorPlane" );
    planeEnt->setMaterial("Examples/Rockwall");
    mSceneMgr->getOriginNode()->attachObject(planeEnt);

    mCamera->setPos(Ogre::Vector3f(0, 500, 100));
    mCamera->lookAt(Ogre::Vector3f(0, 0, 0));
}
//----------------------------------------------------------------------------
//----------------------------------------------------------------------------

PlayPen_CompositorTechniqueSwitch::PlayPen_CompositorTechniqueSwitch()
{
    mInfo["Title"] = "PlayPen_CompositorTechniqueSwitch";
    mInfo["Description"] = "Tests switching compositor techniques rapidly.";
    addScreenshotFrame(15);
}
//----------------------------------------------------------------------------

void PlayPen_CompositorTechniqueSwitch::cleanupContent()
{
    CompositorManager::getSingleton().removeCompositorChain(mViewport);
}
//----------------------------------------------------------------------------

bool PlayPen_CompositorTechniqueSwitch::onPreRender(const RenderFrameArgs * evt)
{
    mTimeUntilNextToggle -= evt->mCurrent;

    if(mTimeUntilNextToggle <= 0.f)
    {
        ++mCompositorIndex;
        mCompositorIndex = mCompositorIndex % mCompositorSchemeList.size();
        mCompositorToSwitch->setScheme(mCompositorSchemeList[mCompositorIndex]);
        mTimeUntilNextToggle = 0.1;
    }

    return true;
}
//----------------------------------------------------------------------------

void PlayPen_CompositorTechniqueSwitch::setupContent()
{
    mTimeUntilNextToggle = 0.1f;// swap compositors every 10 frames
    CompositorManager& cmgr = CompositorManager::getSingleton();
    CompositorPtr compositor = cmgr.create("testtechswitch",
    TRANSIENT_RESOURCE_GROUP);
    // technique 1 (Invert)
    CompositionTechnique* ctech1 = compositor->createTechnique();
    CompositionTechnique::FrameDefine* tdef =    ctech1->createTextureDefinition("rt0");
    tdef->formatList.push_back(PF_A8B8G8R8);
    tdef->width = tdef->height = 0;
    tdef->pooled = true;

    CompositionTargetPass * tpass = ctech1->createTargetPass();
    tpass->setOutputName("rt0");
    tpass->setInputMode(CompositionTargetPass::IM_PREVIOUS);
    CompositionTargetPass * tout = ctech1->getOutputTargetPass();
    tout->setInputMode(CompositionTargetPass::IM_NONE);
    CompositionPass * pass = tout->create();
    pass->setType(CompositionPass::PT_RENDERQUAD);
    pass->setMaterial("Ogre/Compositor/Invert");
    pass->setInput(0, "rt0");

    // technique 2 (Tiling)
    ctech1 = compositor->createTechnique();
    ctech1->setSchemeID("Tiling");
    tdef = ctech1->createTextureDefinition("rt0");
    tdef->formatList.push_back(PF_A8B8G8R8);
    tdef->width = tdef->height = 0;
    tdef->pooled = true;

    tpass = ctech1->createTargetPass();
    tpass->setOutputName("rt0");
    tpass->setInputMode(CompositionTargetPass::IM_PREVIOUS);
    tout = ctech1->getOutputTargetPass();
    tout->setInputMode(CompositionTargetPass::IM_NONE);
    pass = tout->create();
    pass->setType(CompositionPass::PT_RENDERQUAD);
    pass->setMaterial("Ogre/Compositor/Tiling");
    pass->setInput(0, "rt0");

    compositor->load();

    GeometrySpace* e = mSceneMgr->createGeo("1", "knot.mesh");
    static_cast<SpaceNode *>(mSceneMgr->getOriginNode()->create())->attachObject(e);
    BoxSky * mBoxSky = N_new BoxSky(mSceneMgr);
    mBoxSky->setMaterial();

    BoxSky * mBoxSky = N_new BoxSky(mSceneMgr);
    mBoxSky->setMaterial();
    mBoxSky->setRenderGroup(RQG_Sky);
    mSceneMgr->setSkyBox(true, "Examples/CloudyNoonSkyBox", 1000);

    // enable compositor (should pick first technique)
    Viewport* vp = mWindow->getViewport(0);

    mCompositorToSwitch = cmgr.addCompositor(vp, compositor->getName());
    mCompositorSchemeList.push_back("");
    mCompositorSchemeList.push_back("Tiling");

    cmgr.setCompositorEnabled(vp, compositor->getName(), true);

    mCamera->setPos(Ogre::Vector3f(0, 0, -300));
    mCamera->lookAt(Vector3::ZERO);

    mCompositorIndex = 0;

}
//----------------------------------------------------------------------------
//----------------------------------------------------------------------------

PlayPen_CompositorTextureShadows::PlayPen_CompositorTextureShadows()
{
    mInfo["Title"] = "PlayPen_CompositorTextureShadows";
    mInfo["Description"] = "Tests applying a compositor to a texture shadow manager.";
    addScreenshotFrame(10);
}
//----------------------------------------------------------------------------

void PlayPen_CompositorTextureShadows::cleanupContent()
{
    TexturePtr shadowTex = mSceneMgr->getRenderPattern()->getTexture(0);
    FrameObj * shadowRtt = shadowTex->getBuffer()->getBuffer();
    Viewport * vp = shadowRtt->getViewport(0);
    CompositorManager::getSingleton().removeCompositorChain(vp);
    clearDebugTextureOverlays();
}
//----------------------------------------------------------------------------

void PlayPen_CompositorTextureShadows::setupContent()
{
    SpaceNode* mTestNode[10];

    mSceneMgr->getRenderPattern()->setTextureDim(512);
    mSceneMgr->setShadowTechnique(SHADOWTYPE_TEXTURE_MODULATIVE);
    mSceneMgr->getRenderPattern()->setMaxExtent(1500);
    mSceneMgr->setShadowColour(Colour(0.35, 0.35, 0.35));
    //mSceneMgr->getRenderPattern()->setMaxExtent(800);
    // Set ambient light
    mSceneMgr->setAmbient(Colour(0.3, 0.3, 0.3));

    Light* mLight = mSceneMgr->createLight("MainLight");

    /*
    // Directional test
    mLight->setType(LT_DIRECTIONAL);
    Vector3 vec(-1,-1,0);
    vec.normalise();
    mLight->setDirection(vec);

    */
    // Spotlight test
    mLight->setType(LT_SPOT);
    mLight->setDiffuse(1.0, 1.0, 0.8);
    mTestNode[0] = mSceneMgr->getOriginNode()->create();
    mTestNode[0]->setPos(Vecotr3f(800, 600, 0));
    mTestNode[0]->lookAt(Vector3(0,0,0), PosNode::SM_Space, Vector3::Z);
    mTestNode[0]->attachObject(mLight);


    mTestNode[1] = mSceneMgr->getOriginNode()->create();


    GeometrySpace* pEnt;
    pEnt = mSceneMgr->createGeo( "1", "robot.mesh" );
    //pEnt->setVisibleDistanceLimit(100);
    AnimationFusion* mAnimState = pEnt->getFusion("Walk");
    mAnimState->setEnabled(true);
    mAnimStateList.push_back(mAnimState);
    //pEnt->setMaterial("2 - Default");
    mTestNode[1]->attachObject( pEnt );
    mTestNode[1]->translate(Vector3f(0,-100,0));

    pEnt = mSceneMgr->createGeo( "3", "knot.mesh" );
    mTestNode[2] = mSceneMgr->getOriginNode()->create(Vector3(-200, 0, -200));
    mTestNode[2]->attachObject( pEnt );

    // Transparent object (can force cast shadows)
    pEnt = mSceneMgr->createGeo( "3.5", "knot.mesh" );
    MaterialPtr tmat = MaterialManager::getSingleton().create("TestAlphaTransparency",
        TRANSIENT_RESOURCE_GROUP);
    tmat->setAlphaShadowCast(true);
    ShaderCh * tpass = tmat->get(0)->get(0);
    tpass->setColour(ShaderCh::SOT_Set)->setAlphaReject(CM_GREATER);
    tpass->setColour(ShaderCh::SOT_Set)->setValue(150);
    tpass->setColour(ShaderCh::SOT_Set)->setAlphaCoverage(false);
    tpass->setBlend(ShaderCh::SOT_Set)->setBlend(FBM_INV_ALPHA);
    tpass->getTexture().create("gras_02.png");
    tpass->setCullingMode(CM_None);

    pEnt->setMaterial("TestAlphaTransparency");
    mTestNode[3] = mSceneMgr->getOriginNode()->create(Vector3(350, 0, -200));
    mTestNode[3]->attachObject( pEnt );

    MeshPtr msh = N_Only(Mesh).load("knot.mesh", TRANSIENT_RESOURCE_GROUP);
    msh->buildTangentBuffer(VT_Tangent);
    pEnt = mSceneMgr->createGeo( "4", "knot.mesh" );
    //pEnt->setMaterial("Examples/BumpMapping/MultiLightSpecular");
    mTestNode[2] = mSceneMgr->getOriginNode()->create(Vector3(100, 0, 200));
    mTestNode[2]->attachObject( pEnt );

    BoxSky * mBoxSky = N_new BoxSky(mSceneMgr);
    mBoxSky->setMaterial();
    mBoxSky->setRenderGroup(RQG_Sky);
    mSceneMgr->setSkyBox(true, "Examples/CloudyNoonSkyBox");

    Plane plane;
    plane.normal = Vector3::Y;
    plane.d = 100;
    MeshManager::getSingleton().createPlane("Myplane",
    TRANSIENT_RESOURCE_GROUP, plane,
    1500,1500,10,10,true,1,5,5,Vector3::Z);
    GeometrySpace* pPlaneEnt;
    pPlaneEnt = mSceneMgr->createGeo( "plane", "Myplane" );
    pPlaneEnt->setMaterial("2 - Default");
    pPlaneEnt->setCastShadow(false);
    static_cast<SpaceNode *>(mSceneMgr->getOriginNode()->create())->attachObject(pPlaneEnt);

    // Set up a debug panel to display the shadow
    addTextureShadowDebugOverlay(1, mSceneMgr);



    ParticleSpace* pSys2 = mSceneMgr->createParticleSpace("smoke", "Examples/Smoke");
    mTestNode[4] = mSceneMgr->getOriginNode()->create(Vector3(-300, -100, 200));
    mTestNode[4]->attachObject(pSys2);

    TexturePtr shadowTex = mSceneMgr->getRenderPattern()->getTexture(0);
    FrameObj* shadowRtt = shadowTex->getBuffer()->getBuffer();
    Viewport* vp = shadowRtt->getViewport(0);
    // This originally used gaussian blur, but since compositor logic stuff has changed since the test
    // was originally written and I'm not especially familiar with it, I just swapped to a random
    // compositor (it still tests the required functionality)
    Ogre::CompositorInstance *instance =
    CompositorManager::getSingleton().addCompositor(vp, "Laplace");
    CompositorManager::getSingleton().setCompositorEnabled(
    vp, "Laplace", true);

    mCamera->setPos(Ogre::Vector3f(400, 250, 350));
    mCamera->lookAt(Ogre::Vector3f(0,0,0));
}
//----------------------------------------------------------------------------
//----------------------------------------------------------------------------

PlayPen_CubeDDS::PlayPen_CubeDDS()
{
    mInfo["Title"] = "PlayPen_CubeDDS";
    mInfo["Description"] = "Tests DDS cubemaps.";
    addScreenshotFrame(10);
}
//----------------------------------------------------------------------------

void PlayPen_CubeDDS::setupContent()
{
    Ogre::ResourceSchemeManager::getSingleton().setup("Tests");

    MaterialPtr mat = MaterialManager::getSingleton().create("testcube",
    TRANSIENT_RESOURCE_GROUP);
    ShaderCh * p = mat->get(0)->get(0);
    p->setLight(false);
    ShaderChTextureUnit * t = p->getTexture().create();
    t->setSrc("grace_cube.dds", TEX_TYPE_CUBE_MAP);
    t->setUAddressing(TAM_CLAMP);
    t->setVAddressing(TAM_CLAMP);
    t->setWAddressing(TAM_CLAMP);
    t->setEnvMap(true);
    t->setEnvMapType(ShaderChTextureUnit::ENM_Reflection);
    GeometrySpace * e = mSceneMgr->createGeo("1", "sphere.mesh");
    e->setMaterial(mat->getName());
    static_cast<SpaceNode *>(mSceneMgr->getOriginNode()->create())->attachObject(e);

    mCamera->setPos(Ogre::Vector3f(300,0,0));
    mCamera->lookAt(Vector3::ZERO);

}
//----------------------------------------------------------------------------
//----------------------------------------------------------------------------

PlayPen_CustomProjectionMatrix::PlayPen_CustomProjectionMatrix()
{
    mInfo["Title"] = "PlayPen_CustomProjectionMatrix";
    mInfo["Description"] = "Tests custom projection matrix.";
}
//----------------------------------------------------------------------------
void PlayPen_CustomProjectionMatrix::setupContent()
{
    PlayPen_LotsAndLotsOfEntities::setupContent();
    Matrix4 mat = mCamera->getProjMatrix();
    mCamera->setCustomProjMatrix(true);
    mCamera->setCustomProjMatrix(mat);
    mat = mCamera->getProjMatrix();
}
//----------------------------------------------------------------------------
//----------------------------------------------------------------------------
PlayPen_DepthBias::PlayPen_DepthBias()
{
    mInfo["Title"] = "PlayPen_DepthBias";
    mInfo["Description"] = "Tests depth biasing.";
    addScreenshotFrame(10);
}
//----------------------------------------------------------------------------
void PlayPen_DepthBias::setupContent()
{
    Ogre::ResourceSchemeManager::getSingleton().setup("Tests");

    mSceneMgr->setAmbient(Colour::White);

    MaterialPtr mat = N_Only(Material).create("mat1", TRANSIENT_RESOURCE_GROUP);
    ShaderCh * p = mat->get(0)->get(0);
    p->getTexture().create("BumpyMetal.jpg");

    const String meshName("cube.mesh");
    GeometrySpace * entity = mSceneMgr->createGeo("base", meshName);
    entity->setMaterial("mat1");
    mSceneMgr->getOriginNode()->attachObject(entity);

    entity = mSceneMgr->createGeo("base2", meshName);
    entity->setMaterial("Examples/SphereMappedRustySteel");
    SpaceNode* n = mSceneMgr->getOriginNode()->create();
    n->setPos(Vecotr3f(-30, 0, 0));
    n->yaw(Angle(45));
    n->attachObject(entity);

    for(size_t i = 0; i <= 6;++i)
    {
        String name("decal");
        name += StrConv::conv(i);

        MaterialPtr pMat = static_cast<MaterialPtr>(N_Only(Material).create(
        name, TRANSIENT_RESOURCE_GROUP));
        ShaderCh * temp = pMat->get(0)->get(0);
        temp->setLight(false);
        temp->setColour(ShaderCh::SOT_Set)->setAlphaReject(CM_GREATER_EQUAL);
        temp->setColour(ShaderCh::SOT_Set)->setValue(128);
        temp->setColour(ShaderCh::SOT_Set)->setAlphaCoverage(false);
        temp->setStencil(ShaderCh::SOT_Set)->setBiasConstant(i);
        temp->setStencil(ShaderCh::SOT_Set)->setBiasSlopeScale(0.0f);
        temp->getTexture().create(name + ".png");

        entity = mSceneMgr->createGeo(name, meshName);
        entity->setMaterial(name);
        mSceneMgr->getOriginNode()->attachObject(entity);
    }
    mCamera->setPos(Ogre::Vector3f(0,0,200));
    mCamera->lookAt(Vector3::ZERO);
}
//----------------------------------------------------------------------------
//----------------------------------------------------------------------------
PlayPen_DepthShadowMap::PlayPen_DepthShadowMap()
{
    mInfo["Title"] = "PlayPen_DepthShadowMap";
    mInfo["Description"] = "Tests depth shadowmapping.";
    addScreenshotFrame(10);
}
//----------------------------------------------------------------------------
void PlayPen_DepthShadowMap::setupContent()
{
    mSceneMgr->getRenderPattern()->setTextureCount(1);
    mSceneMgr->getRenderPattern()->setTexture(0, 1024, 1024, PF_R32);
    mSceneMgr->setSelfShadow(true);
    mSceneMgr->setShadowTechnique(SHADOWTYPE_TEXTURE_ADDITIVE);
    mSceneMgr->setBackFaceInCast(false);

    mSceneMgr->getRenderPattern()->setTextureCasterMaterial("Ogre/DepthShadowmap/Caster/Float");

    LiSPSMShadowSetup * mLiSPSMSetup = N_new LiSPSMShadowSetup();
    //mLiSPSMSetup->setUseAggressiveFocusRegion(false);
    CameraSetup * mCurrentShadowGenCamera = mLiSPSMSetup;
    //CameraSetup * mCurrentShadowGenCamera = N_new PlaneOptimalShadowGenCamera(mPlane);
    mSceneMgr->setShadowGenCamera(mCurrentShadowGenCamera);

    // Single light
    Light * l = mSceneMgr->createLight("l1");
    l->setType(LT_SPOT);
    //l->setPos(Vecotr3f(500, 500, -100));
    l->setPos(Vecotr3f(0, 300, 0));
    Vector3 dir = -l->getPos();
    dir.normalise();
    l->setDirection(dir);
    l->setSpotlightOuter(Angle(40));
    l->setSpotlightInner(Angle(35));

    // ground plane
    MovablePlane movablePlane = MovablePlane(Vector3::Y, 0.f);

    MeshManager::getSingleton().createPlane("Myplane", TRANSIENT_RESOURCE_GROUP,
        movablePlane, 500, 500, 10, 10, true, 1, 5, 5, Vector3::Z);
    GeometrySpace * pPlaneEnt;
    pPlaneEnt = mSceneMgr->createGeo( "plane", "Myplane" );
    pPlaneEnt->setMaterial("Ogre/DepthShadowmap/Receiver/RockWall");
    static_cast<SpaceNode *>(mSceneMgr->getOriginNode()->create())->attachObject(pPlaneEnt);

    // box
    CustomSpaceObj * man = mSceneMgr->createCustomGeo("box");
    NIIf boxsize = 50;
    NIIf boxsizehalf = boxsize / 2.0;
    man->begin(GeometryRaw::OT_TRIANGLE_LIST,"Ogre/DepthShadowmap/Receiver/Float");
    man->position(-boxsizehalf, 0, boxsizehalf);
    man->position(boxsizehalf, 0, boxsizehalf);
    man->position(boxsizehalf, 0, -boxsizehalf);
    man->position(-boxsizehalf, 0, -boxsizehalf);
    man->position(-boxsizehalf, boxsize, boxsizehalf);
    man->position(boxsizehalf, boxsize, boxsizehalf);
    man->position(boxsizehalf, boxsize, -boxsizehalf);
    man->position(-boxsizehalf, boxsize, -boxsizehalf);
    man->quad(3, 2, 1, 0);
    man->quad(4, 5, 6, 7);
    man->quad(0, 1, 5, 4);
    man->quad(1, 2, 6, 5);
    man->quad(2, 3, 7, 6);
    man->quad(3, 0, 4, 7);
    man->end();

    static_cast<SpaceNode *>(mSceneMgr->getOriginNode()->create())->attachObject(man);

    mCamera->setPos(Ogre::Vector3f(150, 100, 150));
    mCamera->lookAt(Vector3::ZERO);

    // Create RTT
    //TexturePtr rtt = N_Only(TextureManager).createTexture( "rtt1", TRANSIENT_RESOURCE_GROUP,
    //    TEX_TYPE_2D, 1024, 1024, 1, 0, PF_R32);
}
//----------------------------------------------------------------------------
//----------------------------------------------------------------------------

GeometrySpace * pPlaneEnt = 0;// yucky global...
Camera * theCam = 0;

class RefractionTextureListener : public FrameObjListener
{
public:
    void onPreFlush(const FrameObjArgs * evt)
    {
        pPlaneEnt->setVisible(false);

    }
    void onEndFlush(const FrameObjArgs * evt)
    {
        pPlaneEnt->setVisible(true);
    }
};

class ReflectionTextureListener : public FrameObjListener
{
public:
    void onPreFlush(const FrameObjArgs * evt)
    {
        static Plane reflectPlane(Vector3::Y, -100);
        pPlaneEnt->setVisible(false);
        theCam->setReflection(true, reflectPlane);
    }
    void onEndFlush(const FrameObjArgs * evt)
    {
        pPlaneEnt->setVisible(true);
        theCam->setReflection(false);
    }
};

PlayPen_Distortion::PlayPen_Distortion()
{
    mInfo["Title"] = "PlayPen_Distortion";
    mInfo["Description"] = "Tests distortion.";
    addScreenshotFrame(15);

    mRefractionListener = N_new RefractionTextureListener();
    mReflectionListener = N_new ReflectionTextureListener();
}
//----------------------------------------------------------------------------
PlayPen_Distortion::~PlayPen_Distortion()
{
    delete mRefractionListener;
    delete mReflectionListener;
}
//----------------------------------------------------------------------------
void PlayPen_Distortion::cleanupContent()
{
    TexturePtr rttTex = TextureManager::getSingleton().getByName("Refraction");
    rttTex->getBuffer()->getBuffer()->removeAllListener();
    TextureManager::getSingleton().unload(rttTex->getPrc());
    rttTex = TextureManager::getSingleton().getByName("Reflection");
    rttTex->getBuffer()->getBuffer()->removeAllListener();
    TextureManager::getSingleton().unload(rttTex->getPrc());
}
//----------------------------------------------------------------------------

void PlayPen_Distortion::setupContent()
{
    SpaceNode* mTestNode[5];
    theCam = mCamera;
    // Set ambient light
    mSceneMgr->setAmbient(Colour(0.5, 0.5, 0.5));

    // Create a point light
    Light* l = mSceneMgr->createLight("MainLight");
    l->setType(LT_DIRECTIONAL);
    l->setDirection(-Vector3::Y);

    GeometrySpace* pEnt;

    TexturePtr rttTex = N_Only(TextureManager).createTexture( "Refraction", TRANSIENT_RESOURCE_GROUP,
        TEX_TYPE_2D, 512, 512, 1, 0, PF_R8G8B8, Texture::MM_FRAME_RGB);
    {
        Viewport * v = rttTex->getBuffer()->getBuffer()->createViewport(mCamera);
        MaterialPtr mat = MaterialManager::getSingleton().getByName("Examples/FresnelReflectionRefraction");
        mat->get(0)->get(0)->getTexture().get(2)->setSrc("Refraction", Texture::T_2D);
        v->setOverlayEnable(false);
        rttTex->getBuffer()->getBuffer()->add(mRefractionListener);
    }

    rttTex = N_Only(TextureManager).createTexture("Reflection", TRANSIENT_RESOURCE_GROUP,
        TEX_TYPE_2D, 512, 512, 1, 0, PF_R8G8B8, Texture::MM_FRAME_RGB);
    {
        Viewport *v = rttTex->getBuffer()->getBuffer()->createViewport(mCamera);
        MaterialPtr mat = MaterialManager::getSingleton().getByName("Examples/FresnelReflectionRefraction");
        mat->get(0)->get(0)->getTexture().get(1)->setSrc("Reflection", Texture::T_2D);
        v->setOverlayEnable(false);
        rttTex->getBuffer()->getBuffer()->add(mReflectionListener);
    }
    // Define a floor plane mesh
    Plane p;
    p.normal = Vector3::Y;
    p.d = 100;
    MeshManager::getSingleton().createPlane("WallPlane",
    TRANSIENT_RESOURCE_GROUP,
    p,1500,1500,10,10,true,1,5,5,Vector3::Z);
    pPlaneEnt = mSceneMgr->createGeo( "5", "WallPlane" );
    pPlaneEnt->setMaterial("Examples/FresnelReflectionRefraction");
    static_cast<SpaceNode *>(mSceneMgr->getOriginNode()->create())->attachObject(pPlaneEnt);

    BoxSky * mBoxSky = N_new BoxSky(mSceneMgr);
    mBoxSky->setMaterial();
    mBoxSky->setRenderGroup(RQG_Sky);
    mSceneMgr->setSkyBox(true, "Examples/CloudyNoonSkyBox");

    mTestNode[0] = mSceneMgr->getOriginNode()->create();
    int i;
    for (i = 0; i < 10; ++i)
    {
        pEnt = mSceneMgr->createGeo( "ogre" + StrConv::conv(i), "ogrehead.mesh" );
        static_cast<SpaceNode *>(mSceneMgr->getOriginNode()->create(Vector3(i*100 - 500, -75, 0)))->attachObject(pEnt);
        pEnt = mSceneMgr->createGeo( "knot" + StrConv::conv(i), "knot.mesh" );
        static_cast<SpaceNode *>(mSceneMgr->getOriginNode()->create(Vector3(i*100 - 500, 140, 0)))->attachObject(pEnt);
    }

    mCamera->setPos(Ogre::Vector3f(100,200,300));
    mCamera->lookAt(Ogre::Vector3f(0,0,0));

}
//----------------------------------------------------------------------------
//----------------------------------------------------------------------------

PlayPen_Dxt1Alpha::PlayPen_Dxt1Alpha()
{
    mInfo["Title"] = "PlayPen_Dxt1Alpha";
    mInfo["Description"] = "Tests dxt1 loading with alpha.";
    addScreenshotFrame(10);
}
//----------------------------------------------------------------------------

void PlayPen_Dxt1Alpha::setupContent()
{
    Ogre::ResourceSchemeManager::getSingleton().setup("Tests");

    MaterialPtr mat = MaterialManager::getSingleton().create("testdxt",
    TRANSIENT_RESOURCE_GROUP);
    ShaderCh * p = mat->get(0)->get(0);
    p->setBlend(ShaderCh::SOT_Set)->setBlend(FBM_INV_ALPHA);
    p->setColour(ShaderCh::SOT_Set)->setAlphaReject(CM_GREATER);
    p->setColour(ShaderCh::SOT_Set)->setValue(128);
    p->setColour(ShaderCh::SOT_Set)->setAlphaCoverage(false);
    p->setLight(false);
    p->setCullingMode(CM_None);
    ShaderChTextureUnit* t = p->getTexture().create("gras_02_dxt1.dds");
    GeometrySpace *e = mSceneMgr->createGeo("Plane", GSP_Plane);
    e->setMaterial(mat->getName());
    static_cast<SpaceNode *>(mSceneMgr->getOriginNode()->create())->attachObject(e);

    mCamera->setPos(Ogre::Vector3f(0,0,300));
    mCamera->lookAt(Vector3::ZERO);

}
//----------------------------------------------------------------------------
//----------------------------------------------------------------------------

PlayPen_Dxt1::PlayPen_Dxt1()
{
    mInfo["Title"] = "PlayPen_Dxt1";
    mInfo["Description"] = "Tests dxt1 loading.";
    addScreenshotFrame(10);
}
//----------------------------------------------------------------------------

void PlayPen_Dxt1::setupContent()
{
    Ogre::ResourceSchemeManager::getSingleton().setup("Tests");

    MaterialPtr mat = MaterialManager::getSingleton().create("testdxt",
    TRANSIENT_RESOURCE_GROUP);
    ShaderCh * p = mat->get(0)->get(0);
    p->setLight(false);
    p->setCullingMode(CM_None);
    ShaderChTextureUnit* t = p->getTexture().create("BumpyMetal_dxt1.dds");
    GeometrySpace *e = mSceneMgr->createGeo("Plane", GSP_Plane);
    e->setMaterial(mat->getName());
    static_cast<SpaceNode *>(mSceneMgr->getOriginNode()->create())->attachObject(e);

    mCamera->setPos(Ogre::Vector3(0,0,-300));
    mCamera->lookAt(Vector3::ZERO);

}
//----------------------------------------------------------------------------
//----------------------------------------------------------------------------

PlayPen_Dxt1FromMemory::PlayPen_Dxt1FromMemory()
{
    mInfo["Title"] = "PlayPen_Dxt1FromMemory";
    mInfo["Description"] = "Tests dxt1 loading from memory.";
    addScreenshotFrame(10);
}
//----------------------------------------------------------------------------

void PlayPen_Dxt1FromMemory::setupContent()
{
    Ogre::ResourceSchemeManager::getSingleton().setup("Tests");

    DataStream * stream = ResourceSchemeManager::getSingleton().openResource("BumpyMetal_dxt1.dds");
    // manually load into image
    Image img;
    img.load(stream, "dds");
    N_delete stream;
    N_Only(Texture).load("testdxtfrommem", TRANSIENT_RESOURCE_GROUP, img);

    MaterialPtr mat = MaterialManager::getSingleton().create("testdxt",
    TRANSIENT_RESOURCE_GROUP);
    Pass* p = mat->get(0)->get(0);
    p->setLight(false);
    p->setCullingMode(CM_None);
    ShaderChTextureUnit* t = p->getTexture().create("testdxtfrommem");
    GeometrySpace *e = mSceneMgr->createGeo("Plane", GSP_Plane);
    e->setMaterial(mat->getName());
    static_cast<SpaceNode *>(mSceneMgr->getOriginNode()->create())->attachObject(e);

    mCamera->setPos(Ogre::Vector3f(0,0,-300));
    mCamera->lookAt(Vector3::ZERO);

}
//----------------------------------------------------------------------------
//----------------------------------------------------------------------------

PlayPen_Dxt3::PlayPen_Dxt3()
{
    mInfo["Title"] = "PlayPen_Dxt3";
    mInfo["Description"] = "Tests dxt3 loading.";
    addScreenshotFrame(10);
}
//----------------------------------------------------------------------------
void PlayPen_Dxt3::setupContent()
{
    Ogre::ResourceSchemeManager::getSingleton().setup("Tests");

    MaterialPtr mat = MaterialManager::getSingleton().create("testdxt",
    TRANSIENT_RESOURCE_GROUP);
    ShaderCh * p = mat->get(0)->get(0);
    p->setLight(false);
    p->setCullingMode(CM_None);
    p->setBlend(ShaderCh::SOT_Set)->setBlend(FBM_INV_ALPHA);
    ShaderChTextureUnit* t = p->getTexture().create("ogreborderUp_dxt3.dds");
    GeometrySpace *e = mSceneMgr->createGeo("Plane", GSP_Plane);
    e->setMaterial(mat->getName());
    static_cast<SpaceNode *>(mSceneMgr->getOriginNode()->create())->attachObject(e);
    mWindow->getViewport(0)->setBgColour(Colour::Red);

    mCamera->setPos(Ogre::Vector3f(0,0,300));
    mCamera->lookAt(Vector3::ZERO);
}
//----------------------------------------------------------------------------
//----------------------------------------------------------------------------
PlayPen_Dxt3FromMemory::PlayPen_Dxt3FromMemory()
{
    mInfo["Title"] = "PlayPen_Dxt3FromMemory";
    mInfo["Description"] = "Tests dxt3 loading from memory.";
    addScreenshotFrame(10);
}
//----------------------------------------------------------------------------
void PlayPen_Dxt3FromMemory::setupContent()
{
    Ogre::ResourceSchemeManager::getSingleton().setup("Tests");

    DataStream * stream = ResourceSchemeManager::getSingleton().openResource("ogreborderUp_dxt3.dds");
    // manually load into image
    Image img;
    img.load(stream, "dds");
    N_delete stream;
    N_Only(Texture).load("testdxtfrommem", TRANSIENT_RESOURCE_GROUP, img);

    MaterialPtr mat = MaterialManager::getSingleton().create("testdxt",
    TRANSIENT_RESOURCE_GROUP);
    ShaderCh * p = mat->get(0)->get(0);
    p->setLight(false);
    p->setCullingMode(CM_None);
    p->setBlend(ShaderCh::SOT_Set)->setBlend(FBM_INV_ALPHA);
    p->setColour(ShaderCh::SOT_Set)->setAlphaReject(CM_GREATER);
    p->setColour(ShaderCh::SOT_Set)->setValue(128);
    p->setColour(ShaderCh::SOT_Set)->setAlphaCoverage(false);
    mat->setReceiveShadow(false);
    ShaderChTextureUnit * t = p->getTexture().create("testdxtfrommem");
    t->setUScale(0.5);
    t->setVScale(0.5);
    GeometrySpace *e = mSceneMgr->createGeo("Plane", GSP_Plane);
    e->setMaterial(mat->getName());
    SpaceNode* n = mSceneMgr->getOriginNode()->create();
    n->setPos(Vecotr3f(-50, 0, 35));
    n->yaw(Angle(90));
    n->attachObject(e);
    mWindow->getViewport(0)->setBgColour(Colour::Red);

    mCamera->setPos(Ogre::Vector3f(0,0,300));
    mCamera->lookAt(Vector3::ZERO);

}
//----------------------------------------------------------------------------
//----------------------------------------------------------------------------

PlayPen_Dxt5::PlayPen_Dxt5()
{
    mInfo["Title"] = "PlayPen_Dxt5";
    mInfo["Description"] = "Tests dxt5 loading.";
    addScreenshotFrame(10);
}
//----------------------------------------------------------------------------
void PlayPen_Dxt5::setupContent()
{
    Ogre::ResourceSchemeManager::getSingleton().setup("Tests");

    MaterialPtr mat = MaterialManager::getSingleton().create("testdxt",
        TRANSIENT_RESOURCE_GROUP);
    ShaderCh * p = mat->get(0)->get(0);
    p->setLight(false);
    p->setCullingMode(CM_None);
    p->setBlend(ShaderCh::SOT_Set)->setBlend(FBM_INV_ALPHA);
    ShaderChTextureUnit * t = p->getTexture().create("ogreborderUp_dxt5.dds");
    GeometrySpace * e = mSceneMgr->createGeo("Plane", GSP_Plane);
    e->setMaterial(mat->getName());
    static_cast<SpaceNode *>(mSceneMgr->getOriginNode()->create())->attachObject(e);
    mWindow->getViewport(0)->setBgColour(Colour::Red);

    mCamera->setPos(NII::Vector3f(0,0,300));
    mCamera->lookAt(Vector3::ZERO);
}
//----------------------------------------------------------------------------
//----------------------------------------------------------------------------
PlayPen_FarFromOrigin::PlayPen_FarFromOrigin()
{
    mInfo["Title"] = "PlayPen_FarFromOrigin";
    mInfo["Description"] = "Tests rending far from the origin.";
    addScreenshotFrame(10);
}
//----------------------------------------------------------------------------

void PlayPen_FarFromOrigin::cleanupContent()
{
    //clearDebugTextureOverlays();
}

void PlayPen_FarFromOrigin::setupContent()
{
    SpaceNode * mTestNode[5];
    mSceneMgr->setShadowTechnique(SHADOWTYPE_TEXTURE_MODULATIVE);
    mSceneMgr->setTextureConfig(1024, 1024, 2);

    Vector3 offset(100000, 0, 100000);
    //Vector3 offset(0, 0, 0);

    mSceneMgr->setAmbient(Colour(0.1, 0.1, 0.1));

    // Directional test
    Light* mLight = mSceneMgr->createLight("MainLight");
    mLight->setType(LT_DIRECTIONAL);
    Vector3 vec(-1,-1,0);
    vec.normalise();
    mLight->setDirection(vec);
    mLight->setDiffuse(Colour(0.5, 0.5, 1.0));

    // Spotlight test
    mLight = mSceneMgr->createLight("SpotLight");
    mLight->setType(LT_SPOT);
    mLight->setRange(10000);
    mLight->setAttenuationConstant(1);
    mLight->setAttenuationLinear(0);
    mLight->setAttenuationQuadric(0);
    mLight->setDiffuse(1.0, 1.0, 0.5);

    mTestNode[0] = mSceneMgr->getOriginNode()->create();
    mTestNode[0]->setPos(offset + Vector3(-400,300,1000));
    mTestNode[0]->lookAt(offset, PosNode::SM_Space, Vector3::Z);
    mTestNode[0]->attachObject(mLight);

    mTestNode[1] = mSceneMgr->getOriginNode()->create();
    mTestNode[1]->setPos(offset);

    GeometrySpace * pEnt;
    pEnt = mSceneMgr->createGeo( "1", "knot.mesh" );
    mTestNode[1]->attachObject( pEnt );
    BoxSky * mBoxSky = N_new BoxSky(mSceneMgr);
    mBoxSky->setMaterial();
    mBoxSky->setRenderGroup(RQG_Sky);
    mSceneMgr->setSkyBox(true, "Examples/CloudyNoonSkyBox");

    Plane plane;
    plane.normal = Vector3::Y;
    plane.d = 100;
    MeshManager::getSingleton().createPlane("Myplane",
    TRANSIENT_RESOURCE_GROUP, plane,
    2500,2500,10,10,true,1,5,5,Vector3::Z);
    GeometrySpace* pPlaneEnt;
    pPlaneEnt = mSceneMgr->createGeo( "plane", "Myplane" );
    pPlaneEnt->setMaterial("2 - Default");
    pPlaneEnt->setCastShadow(false);
    static_cast<SpaceNode *>(mSceneMgr->getOriginNode()->create(offset))->attachObject(pPlaneEnt);

    ParticleSpace * pSys2 = mSceneMgr->createParticleSpace("smoke", "Examples/Smoke");
    mTestNode[4] = mSceneMgr->getOriginNode()->create(offset + Vector3(-300, -100, 200));
    mTestNode[4]->attachObject(pSys2);

    mCamera->setPos(offset + Vector3(0, 1000, 500));
    mCamera->lookAt(offset);
    mCamera->setFarClipDistance(10000);

    mSceneMgr->setCameraOrigin(true);

    FocusedShadowSetup * camSetup = N_new FocusedShadowSetup();
    mSceneMgr->setShadowGenCamera(camSetup);
    //addTextureShadowDebugOverlay(1, mSceneMgr);
}
//----------------------------------------------------------------------------
//----------------------------------------------------------------------------
PlayPen_Float128DDS::PlayPen_Float128DDS()
{
    mInfo["Title"] = "PlayPen_Float128DDS";
    mInfo["Description"] = "Tests 128bit floating point dds textures.";
    addScreenshotFrame(250);
}
//----------------------------------------------------------------------------
void PlayPen_Float128DDS::setupContent()
{
    Ogre::ResourceSchemeManager::getSingleton().setup("Tests");

    MaterialPtr mat = MaterialManager::getSingleton().create("testdds",
    TRANSIENT_RESOURCE_GROUP);
    Pass* p = mat->get(0)->get(0);
    p->setLight(false);
    p->setCullingMode(CM_None);
    p->setBlend(ShaderCh::SOT_Set)->setBlend(FBM_INV_ALPHA);
    ShaderChTextureUnit* t = p->getTexture().create("ogreborderUp_float128.dds");
    GeometrySpace *e = mSceneMgr->createGeo("Plane", GSP_Plane);
    e->setMaterial(mat->getName());
    static_cast<SpaceNode *>(mSceneMgr->getOriginNode()->create())->attachObject(e);
    mWindow->getViewport(0)->setBgColour(Colour::Red);

    mCamera->setPos(NII::Vector3f(0,0,300));
    mCamera->lookAt(Vector3::ZERO);

}
//----------------------------------------------------------------------------
//----------------------------------------------------------------------------
PlayPen_Float16DDS::PlayPen_Float16DDS()
{
    mInfo["Title"] = "PlayPen_Float16DDS";
    mInfo["Description"] = "Tests 16bit floating point dds textures.";
    addScreenshotFrame(250);
}
//----------------------------------------------------------------------------

void PlayPen_Float16DDS::setupContent()
{
    Ogre::ResourceSchemeManager::getSingleton().setup("Tests");

    MaterialPtr mat = MaterialManager::getSingleton().create("testdds",
    TRANSIENT_RESOURCE_GROUP);
    Pass* p = mat->get(0)->get(0);
    p->setLight(false);
    p->setCullingMode(CM_None);
    ShaderChTextureUnit* t = p->getTexture().create("BumpyMetal_float16.dds");
    GeometrySpace *e = mSceneMgr->createGeo("Plane", GSP_Plane);
    e->setMaterial(mat->getName());
    static_cast<SpaceNode *>(mSceneMgr->getOriginNode()->create())->attachObject(e);
    mWindow->getViewport(0)->setBgColour(Colour::Red);

    mCamera->setPos(NII::Vector3f(0, 0, 300));
    mCamera->lookAt(Vector3::ZERO);

}
//----------------------------------------------------------------------------
//----------------------------------------------------------------------------

PlayPen_Float32DDS::PlayPen_Float32DDS()
{
    mInfo["Title"] = "PlayPen_Float32DDS";
    mInfo["Description"] = "Tests 32bit floating point dds textures.";
    addScreenshotFrame(250);
}
//----------------------------------------------------------------------------

void PlayPen_Float32DDS::setupContent()
{
    Ogre::ResourceSchemeManager::getSingleton().setup("Tests");

    MaterialPtr mat = MaterialManager::getSingleton().create("testdds",
    TRANSIENT_RESOURCE_GROUP);
    Pass* p = mat->get(0)->get(0);
    p->setLight(false);
    p->setCullingMode(CM_None);
    ShaderChTextureUnit* t = p->getTexture().create("BumpyMetal_float32.dds");
    GeometrySpace *e = mSceneMgr->createGeo("Plane", GSP_Plane);
    e->setMaterial(mat->getName());
    static_cast<SpaceNode *>(mSceneMgr->getOriginNode()->create())->attachObject(e);
    mWindow->getViewport(0)->setBgColour(Colour::Red);

    mCamera->setPos(NII::Vector3f(0, 0, 300));
    mCamera->lookAt(Vector3::ZERO);

    // try saving
    TexturePtr tx = TextureManager::getSingleton().getByName("BumpyMetal_float32.dds");
    float* dataBuf = new float[tx->getWidth() * tx->getHeight() * 4];
    PixelBlock pb(tx->getWidth(), tx->getHeight(), 1, PF_R32G32B32, dataBuf);

    tx->getBuffer()->read(Box(0,0,0,mWidth,mHeight,mDepth), pb);

    Image img;
    img.load((uchar*)dataBuf, tx->getWidth(), tx->getHeight(), 1, 1, PF_R32G32B32);
    img.save("test.hdr");
}
//----------------------------------------------------------------------------
//----------------------------------------------------------------------------
PlayPen_Float64DDS::PlayPen_Float64DDS()
{
    mInfo["Title"] = "PlayPen_Float64DDS";
    mInfo["Description"] = "Tests 64bit floating point dds textures.";
    addScreenshotFrame(250);
}
//----------------------------------------------------------------------------
void PlayPen_Float64DDS::setupContent()
{
    Ogre::ResourceSchemeManager::getSingleton().setup("Tests");

    MaterialPtr mat = MaterialManager::getSingleton().create("testdds",
    TRANSIENT_RESOURCE_GROUP);
    Pass* p = mat->get(0)->get(0);
    p->setLight(false);
    p->setCullingMode(CM_None);
    p->setBlend(ShaderCh::SOT_Set)->setBlend(FBM_INV_ALPHA);
    ShaderChTextureUnit* t = p->getTexture().create("ogreborderUp_float64.dds");
    GeometrySpace *e = mSceneMgr->createGeo("Plane", GSP_Plane);
    e->setMaterial(mat->getName());
    static_cast<SpaceNode *>(mSceneMgr->getOriginNode()->create())->attachObject(e);
    mWindow->getViewport(0)->setBgColour(Colour::Red);

    mCamera->setPos(NII::Vector3f(0, 0, 300));
    mCamera->lookAt(Vector3::ZERO);
}
//----------------------------------------------------------------------------
//----------------------------------------------------------------------------
PlayPen_GeometryShaders::PlayPen_GeometryShaders()
{
    mInfo["Title"] = "PlayPen_GeometryShaders";
    mInfo["Description"] = "Tests geometry shaders.";
    addScreenshotFrame(10);
}
//----------------------------------------------------------------------------
void PlayPen_GeometryShaders::testCapabilities(const Ogre::RenderSysFeature* caps)
{
    if(!caps->hasCapability(GF_Program_Geometry))
        throw Ogre::Exception(999, "Video card doesn't support geometry shaders.", "testCapabilities");
}
//----------------------------------------------------------------------------
void PlayPen_GeometryShaders::setupContent()
{
    const String GLSL_MATERIAL_NAME = "Ogre/GPTest/SwizzleGLSL";
    const String ASM_MATERIAL_NAME = "Ogre/GPTest/SwizzleASM";
    const String CG_MATERIAL_NAME = "Ogre/GPTest/SwizzleCG";

    // Check capabilities
    const RenderSysFeature* caps = Root::getSingleton().getRender()->getFeature();
    if (!caps->hasCapability(GF_Program_Geometry))
    {
        N_EXCEPT(Ogre::Exception::ERR_NOT_IMPLEMENTED, "Your card does not support geometry programs, so cannot run this demo. Sorry!");
    }

    int maxOutputVertices = caps->getMaxGeometryOutput();
    Ogre::LogManager::getSingleton().getDefaultLog()->stream() <<
    "Num output vertices per geometry shader run : " << maxOutputVertices;

    GeometrySpace * ent = mSceneMgr->createGeo("head", "ogrehead.mesh");
    mCamera->setPos(NII::Vector3f(20, 0, 100));
    mCamera->lookAt(Ogre::Vector3f(0,0,0));

    //String materialName = GLSL_MATERIAL_NAME;
    String materialName = ASM_MATERIAL_NAME;
    //String materialName = CG_MATERIAL_NAME;

    // Set all of the material's sub entities to use the new material
    for(unsigned int i = 0; i<ent->getNumSubEntities(); ++i)
    {
        ent->getCom(i)->setMaterial(materialName);
    }

    // Add entity to the root scene node
    static_cast<SpaceNode *>(mSceneMgr->getOriginNode()->create())->attachObject(ent);

    mWindow->getViewport(0)->setBgColour(Colour::Green);
}
//----------------------------------------------------------------------------
//----------------------------------------------------------------------------
PlayPen_ImageCombine::PlayPen_ImageCombine()
{
    mInfo["Title"] = "PlayPen_ImageCombine";
    mInfo["Description"] = "Tests image combining.";
    addScreenshotFrame(10);
}
//----------------------------------------------------------------------------
void PlayPen_ImageCombine::setupContent()
{
    Image combined;

    // pick 2 files that are the same size, alpha texture will be made greyscale
    combined.combine("rockwall.tga", "flare.png", PF_BYTE_RGBA, TRANSIENT_RESOURCE_GROUP);

    TexturePtr tex = N_Only(TextureManager).createTexture( "1", TRANSIENT_RESOURCE_GROUP,
        TEX_TYPE_2D, 256, 256, 1, 0, PF_BYTE_RGBA);
    tex->load(combined);

    MaterialManager& mmgr = MaterialManager::getSingleton();
    MaterialPtr mat = mmgr.create("m1", TRANSIENT_RESOURCE_GROUP);
    Pass* pass = mat->get(0)->get(0);
    pass->setLight(false);
    pass->setCullingMode(CM_None);
    pass->setBlend(ShaderCh::SOT_Set)->setBlend(FBM_INV_ALPHA);
    pass->setStencil(ShaderCh::SOT_Set)->setDepthWrite(false);
    pass->getTexture().create(tex->getName());

    GeometrySpace *e = mSceneMgr->createGeo("test", GSP_Plane);
    e->setMaterial(mat->getName());
    static_cast<SpaceNode *>(mSceneMgr->getOriginNode()->create())->attachObject(e);

    mCamera->setPos(NII::Vector3f(0, 0, 200));
    mCamera->lookAt(Vector3::ZERO);

    mWindow->getViewport(0)->setBgColour(Colour::Blue);
}
//----------------------------------------------------------------------------
//----------------------------------------------------------------------------
PlayPen_InfiniteAAB::PlayPen_InfiniteAAB()
{
    mInfo["Title"] = "PlayPen_InfiniteAAB";
    mInfo["Description"] = "Tests finite/infinite AABBs.";
    addScreenshotFrame(15);
}
//----------------------------------------------------------------------------
void PlayPen_InfiniteAAB::setupContent()
{
    // When using the BspSceneManager
    mSceneMgr->setSceneGeo("ogretestmap.bsp");

    // When using the TerrainSceneManager
    //mSceneMgr->setSceneGeo("terrain.cfg");

    AABox b1; // null
    assert(b1.isNull());

    {
        // Create background material
        MaterialPtr material = MaterialManager::getSingleton().create("Background", "General");
        material->get(0)->get(0)->setTexture(ShaderCh::SOT_Set).create("rockwall.tga");
        material->get(0)->get(0)->setStencil(ShaderCh::SOT_Set)->setDepthEnable(false);
        material->get(0)->get(0)->setStencil(ShaderCh::SOT_Set)->setDepthWrite(false);
        material->get(0)->get(0)->setLight(false);

        // Create left background rectangle
        // NOTE: Uses finite aab
        RectGeo * rect1 = N_new RectGeo(true);
        rect1->setRect(-0.5, 0.1, -0.1, -0.1);
        // Hacky, set small bounding box, to show problem
        rect1->setAABB(AABox(-10.0 * Vector3::UNIT, 10.0 * Vector3::UNIT));
        rect1->setMaterial("Background");
        rect1->setRenderGroup(RQG_Overlay - 1);
        SpaceNode * node = mSceneMgr->getOriginNode()->create("Background1");
        node->attachObject(rect1);

        // Create right background rectangle
        // NOTE: Uses infinite aab
        RectGeo * rect2 = new RectGeo(true);
        rect2->setRect(0.1, 0.1, 0.5, -0.1);
        rect2->setCullType(CT_Always);
        rect2->setMaterial("Background");
        rect2->setRenderGroup(RQG_Overlay - 1);
        node = mSceneMgr->getOriginNode()->create("Background2");
        node->attachObject(rect2);

        // Create a manual object for 2D
        CustomSpaceObj* manual = mSceneMgr->createCustomGeo("manual");
        manual->on(GeometryObj::M_IdentityProj);
        manual->on(GeometryObj::M_IdentityView);
        manual->begin(GeometryRaw::OT_LINE_STRIP, MaterialManager::WhiteColour->getOriginID());
        manual->position(-0.2, -0.2, 0.0);
        manual->position( 0.2, -0.2, 0.0);
        manual->position( 0.2,  0.2, 0.0);
        manual->position(-0.2,  0.2, 0.0);
        manual->index(0);
        manual->index(1);
        manual->index(2);
        manual->index(3);
        manual->index(0);
        manual->end();
        manual->setCullType(CT_Always); // Use infinite aab to always stay visible
        rect2->setRenderGroup(RQG_Overlay - 1);
        static_cast<SpaceNode *>(mSceneMgr->getOriginNode()->create())->attachObject(manual);
    }

    mSceneMgr->setAABBView(true);

    GeometrySpace* ent = mSceneMgr->createGeo("test", "ogrehead.mesh");
    static_cast<SpaceNode *>(mSceneMgr->getOriginNode()->create("test", 50.0 * Vector3::X))->attachObject(ent);

    mCamera->setPos(Ogre::Vector3f(100, 50, 350));
    mCamera->lookAt(Ogre::Vector3f(0, 0, 0));
}
//----------------------------------------------------------------------------
//----------------------------------------------------------------------------

PlayPen_IntersectionSpaceQuery::PlayPen_IntersectionSpaceQuery()
{
    mInfo["Title"] = "PlayPen_IntersectionSpaceQuery";
    mInfo["Description"] = "Tests intersection query.";
    addScreenshotFrame(10);
}
//----------------------------------------------------------------------------
bool PlayPen_IntersectionSpaceQuery::onPreRender(const RenderFrameArgs * evt)
{
    intersectionQuery->execute();
    const QueryList & results = intersectionQuery->getQuery();
    for(QueryList::iterator i = results.begin(); i != results.end(); ++i)
    {
        CollisionQueryDetail * thepair = static_cast<CollisionQueryDetail *>(*i);
        if(thepair->mSpaceObj1->getFactoryID() == N_FACTORY_GEOSPACE)
        {
            GeometrySpace * ent = static_cast<GeometrySpace *>(thepair->mSpaceObj1);
            ent->setMaterial("Examples/RustySteel");
        }
        if(thepair->mSpaceObj2->getFactoryID() == N_FACTORY_GEOSPACE)
        {
            GeometrySpace * ent = static_cast<GeometrySpace *>(thepair->mSpaceObj2);
            ent->setMaterial("Examples/RustySteel");
        }
    }
    return true;
}
//----------------------------------------------------------------------------
void PlayPen_IntersectionSpaceQuery::setupContent()
{
    // Set ambient light
    mSceneMgr->setAmbient(Colour(0.5, 0.5, 0.5));

    // Create a point light
    Light * l = mSceneMgr->createLight("MainLight");
    l->setType(LT_DIRECTIONAL);
    l->setDirection(-Vector3::Y);

    // Create a set of random balls
    GeometrySpace * ent = mSceneMgr->createGeo("Ball", "sphere.mesh");
    static_cast<SpaceNode *>(mSceneMgr->getOriginNode()->create())->attachObject(ent);
    createRandomEntityClones(ent, 500, Vector3(-2500,-2500,-2500), Vector3(2500,2500,2500), mSceneMgr);

    intersectionQuery = mSceneMgr->createIntersectQuery();

    mCamera->setPos(NII::Vector3f(0, 0, 2600));
}
//----------------------------------------------------------------------------
//----------------------------------------------------------------------------
PlayPen_LightClipPlanes::PlayPen_LightClipPlanes()
{
    mInfo["Title"] = "PlayPen_LightClipPlanes";
    mInfo["Description"] = "Tests light clipping planes.";
    addScreenshotFrame(10);
}
//----------------------------------------------------------------------------
void PlayPen_LightClipPlanes::setupContent()
{
    mSceneMgr->setAmbient(Colour::White);

    Plane plane;
    plane.normal = Vector3::Y;
    plane.d = 0;
    MeshManager::getSingleton().createPlane("Myplane",
    TRANSIENT_RESOURCE_GROUP, plane,
    4500,4500,10,10,true,1,5,5,Vector3::Z);
    GeometrySpace * pPlaneEnt = mSceneMgr->createGeo( "plane", "Myplane" );
    pPlaneEnt->setMaterial("Examples/GrassFloor");
    pPlaneEnt->setCastShadow(false);
    static_cast<SpaceNode *>(mSceneMgr->getOriginNode()->create(Vector3(150,0,100)))->attachObject(pPlaneEnt);

    NIIf lightRange = 1000;
    NIIf spotWidth = 300;

    CustomSpaceObj * debugSphere = mSceneMgr->createCustomGeo("debugSphere");
    debugSphere->begin(GeometryRaw::OT_LINE_STRIP, MaterialManager::WhiteColour->getOriginID());
    for (int i = 0; i <= 20; ++i)
    {
        Vector3 basePos(spotWidth, 0, 0);
        Quaternion quat;
        quat.from(Radian(((float)i/(float)20)*Math::PI2X), Vector3::Y);
        basePos = quat * basePos;
        debugSphere->position(basePos);
    }
    debugSphere->end();

    Light * l = mSceneMgr->createLight("l1");
    l->setRange(lightRange);
    l->setAttenuationConstant(1);
    l->setAttenuationLinear(0);
    l->setAttenuationQuadric(0);
    SpaceNode * n = mSceneMgr->getOriginNode()->create(Vector3(100,0,0));
    n->attachObject(debugSphere);
    /* SPOT LIGHT
    */
    // match spot width to groud
    NIIf spotHeight = lightRange * 0.5;
    n = mSceneMgr->getOriginNode()->create(Vector3(100,spotHeight,0));
    l->setType(LT_SPOT);
    Radian spotAngle = Math::ATan(spotWidth / spotHeight) * 2;
    l->setSpotlightOuter(spotAngle);
    l->setSpotlightInner(spotAngle * 0.75);
    Vector3 dir(0, -1, 0);
    dir.normalise();
    l->setDirection(dir);

    /* END SPOT LIGHT */
    n->attachObject(l);

    // Modify the plane material so that it clips to the light
    // Normally you'd only clip a secondary pass but this is engineered so you
    // can actually see the scissoring effect
    MaterialPtr mat = MaterialManager::getSingleton().getByName("Examples/GrassFloor");
    Pass* p = mat->get(0)->get(0);
    p->setLightClipPlane(true);
    //if (scissortoo)
    //p->setLightClip(true);

    mCamera->setPos(Ogre::Vector3f(0, 200, 300));
    mCamera->lookAt(Vector3::ZERO);



}
//----------------------------------------------------------------------------
//----------------------------------------------------------------------------

PlayPen_LightClipPlanesMoreLights::PlayPen_LightClipPlanesMoreLights()
{
    mInfo["Title"] = "PlayPen_LightClipPlanesMoreLights";
    mInfo["Description"] = "Tests light clip planes with more lights.";
    addScreenshotFrame(10);
}
//----------------------------------------------------------------------------

void PlayPen_LightClipPlanesMoreLights::setupContent()
{
    mSceneMgr->setAmbient(Colour(0.3, 0.25, 0.2, 0));
    mSceneMgr->setShadowTechnique(SHADOWTYPE_TEXTURE_ADDITIVE);
    mSceneMgr->getRenderPattern()->setTextureCount(3);

    Plane plane;
    plane.normal = Vector3::Y;
    plane.d = 0;
    MeshManager::getSingleton().createPlane("Myplane",
    TRANSIENT_RESOURCE_GROUP, plane,
    4500,4500,100,100,true,1,5,5,Vector3::Z);
    GeometrySpace* pPlaneEnt = mSceneMgr->createGeo( "plane", "Myplane" );
    pPlaneEnt->setMaterial("Examples/GrassFloor");
    pPlaneEnt->setCastShadow(false);
    static_cast<SpaceNode *>(mSceneMgr->getOriginNode()->create())->attachObject(pPlaneEnt);

    NIIf lightRange = 1000;
    NIIf spotWidth = 300;

    int numLights = 8;
    NIIf xoff = -numLights * spotWidth * 0.5;

    for(int i = 0; i < numLights; ++i)
    {
        Light * l = mSceneMgr->createLight("l" + StrConv::conv(i));
        l->setRange(lightRange);
        l->setAttenuationConstant(1);
        l->setAttenuationLinear(0);
        l->setAttenuationQuadric(0);
        /* SPOT LIGHT
        */
        // match spot width to groud
        NIIf spotHeight = lightRange * 0.5;
        SpaceNode * n = mSceneMgr->getOriginNode()->create(Vector3((spotWidth+50)*i + xoff,spotHeight,0));
        l->setType(LT_SPOT);
        Radian spotAngle = Math::ATan(spotWidth / spotHeight) * 2;
        l->setSpotlightOuter(spotAngle);
        l->setSpotlightInner(spotAngle * 0.75);
        Vector3 dir(0, -1, 0);
        dir.normalise();
        l->setDirection(dir);

        /* END SPOT LIGHT */
        n->attachObject(l);

        GeometrySpace * e = mSceneMgr->createGeo("e" + StrConv::conv(i), "robot.mesh");
        SpaceNode * en = n->create(Vector3(0, -200, 0));
        en->attachObject(e);
    }

    // Modify the plane material so that it clips to the light on the second pass, post ambient

    MaterialPtr mat = MaterialManager::getSingleton().getByName("Examples/GrassFloor");
    ShaderCh * p = mat->get(0)->get(0);
    ResourceID texname = p->getTexture().get(0)->getResourceID();
    p->getTexture().removeAll();
    p->setShaderStep(SS_Global);
    p->setColour(ShaderCh::SOT_Set)->setDiffuse(Colour::Black);
    p = mat->get(0)->create();
    p->setShaderStep(SS_Detail_Light);
    p->setEachLight(true);
    p->setLightTypeLimit(LT_NONE);
    p->setColour(ShaderCh::SOT_Set)->setAmbient(Colour::Black);
    p->setLightClipPlane(true);
    p->setBlend(ShaderCh::SOT_Set)->setBlend(FBM_ADD);
    //if (scissortoo)
    p->setLightClip(true);
    p = mat->get(0)->create();
    p->setShaderStep(SS_Decal);
    p->getTexture().create(texname);
    p->setLight(false);
    p->setBlend(ShaderCh::SOT_Set)->setBlend(FBM_MODULATE);

    mCamera->setPos(Ogre::Vector3f(0, 200, 300));
    mCamera->lookAt(Vector3::ZERO);
}
//----------------------------------------------------------------------------
//----------------------------------------------------------------------------
PlayPen_LightScissoring::PlayPen_LightScissoring()
{
    mInfo["Title"] = "PlayPen_LightScissoring";
    mInfo["Description"] = "Tests light scissoring.";
    addScreenshotFrame(10);
}
//----------------------------------------------------------------------------
void PlayPen_LightScissoring::setupContent()
{
    mSceneMgr->setAmbient(Colour::White);

    Plane plane;
    plane.normal = Vector3::Y;
    plane.d = 0;
    MeshManager::getSingleton().createPlane("Myplane",
    TRANSIENT_RESOURCE_GROUP, plane,
    4500,4500,10,10,true,1,5,5,Vector3::Z);
    GeometrySpace* pPlaneEnt = mSceneMgr->createGeo( "plane", "Myplane" );
    pPlaneEnt->setMaterial("Examples/GrassFloor");
    pPlaneEnt->setCastShadow(false);
    static_cast<SpaceNode *>(mSceneMgr->getOriginNode()->create())->attachObject(pPlaneEnt);

    NIIf lightRange = 100;

    CustomSpaceObj* debugSphere = mSceneMgr->createCustomGeo("debugSphere");
    debugSphere->begin(GeometryRaw::OT_LINE_STRIP, MaterialManager::WhiteColour->getOriginID());
    for (int i = 0; i <= 20; ++i)
    {
        Vector3 basePos(lightRange, 0, 0);
        Quaternion quat;
        quat.from(Radian(((float)i/(float)20) * Math::PI2X), Vector3::Y);
        basePos = quat * basePos;
        debugSphere->position(basePos);
    }
    for (int i = 0; i <= 20; ++i)
    {
        Vector3 basePos(lightRange, 0, 0);
        Quaternion quat;
        quat.from(Radian(((float)i/(float)20) * Math::PI2X), Vector3::Z);
        basePos = quat * basePos;
        debugSphere->position(basePos);
    }
    debugSphere->end();

    CustomSpaceObj* debugSphere2 = mSceneMgr->createCustomGeo("debugSphere2");
    debugSphere2->begin(GeometryRaw::OT_LINE_STRIP, MaterialManager::WhiteColour->getOriginID());
    for (int i = 0; i <= 20; ++i)
    {
        Vector3 basePos(lightRange, 0, 0);
        Quaternion quat;
        quat.from(Radian(((float)i/(float)20)*Math::PI2X), Vector3::Y);
        basePos = quat * basePos;
        debugSphere2->position(basePos);
    }
    for (int i = 0; i <= 20; ++i)
    {
        Vector3 basePos(lightRange, 0, 0);
        Quaternion quat;
        quat.from(Radian(((float)i/(float)20)*Math::PI2X), Vector3::Z);
        basePos = quat * basePos;
        debugSphere2->position(basePos);
    }
    debugSphere2->end();

    Light * l = mSceneMgr->createLight("l1");
    l->setRange(lightRange);
    l->setAttenuationConstant(1);
    l->setAttenuationLinear(0);
    l->setAttenuationQuadric(0);
    SpaceNode * n = mSceneMgr->getOriginNode()->create(Vector3(0,95,0));
    n->attachObject(debugSphere);
    n->attachObject(l);

    Light * l2 = mSceneMgr->createLight("l2");
    l2->setRange(lightRange);
    l2->setAttenuationConstant(1);
    l2->setAttenuationLinear(0);
    l2->setAttenuationQuadric(0);
    SpaceNode * n2 = mSceneMgr->getOriginNode()->create(Vector3(100,50,0));
    n2->attachObject(debugSphere2);
    n2->attachObject(l2);

    // Modify the plane material so that it clips to the light
    // Normally you'd only clip a secondary pass but this is engineered so you
    // can actually see the scissoring effect
    MaterialPtr mat = MaterialManager::getSingleton().getByName("Examples/GrassFloor");
    Pass * p = mat->get(0)->get(0);
    p->setLightClip(true);
    //if (cliptoo)
    p->setLightClipPlane(true);

    mCamera->setPos(Ogre::Vector3f(0, 200, 300));
    mCamera->lookAt(Vector3::ZERO);

}
//----------------------------------------------------------------------------
//----------------------------------------------------------------------------
PlayPen_LiSPSM::PlayPen_LiSPSM()
{
    mInfo["Title"] = "PlayPen_LiSPSM";
    mInfo["Description"] = "Tests light-space shadow mapping camera setup.";
    addScreenshotFrame(10);
}
//----------------------------------------------------------------------------
void PlayPen_LiSPSM::cleanupContent()
{
    clearDebugTextureOverlays();
}
//----------------------------------------------------------------------------
void PlayPen_LiSPSM::setupContent()
{
    SpaceNode* mTestNode[10];

    mSceneMgr->getRenderPattern()->setTextureDim(1024);
    mSceneMgr->setShadowTechnique(SHADOWTYPE_TEXTURE_MODULATIVE);

    //FocusedShadowSetup* lispsmSetup = new FocusedShadowSetup();
    LiSPSMShadowSetup * lispsmSetup = N_new LiSPSMShadowSetup();
    lispsmSetup->setOptimalAdjustFactor(2);
    mSceneMgr->setShadowGenCamera(lispsmSetup);

    mSceneMgr->getRenderPattern()->setMaxExtent(3000);
    mSceneMgr->setShadowColour(Colour(0.35, 0.35, 0.35));
    mSceneMgr->setAmbient(Colour(0.3, 0.3, 0.3));

    Light* mLight = mSceneMgr->createLight("MainLight");
    mLight->setType(LT_DIRECTIONAL);
    Vector3 vec(-1,-1,0);
    vec.normalise();
    mLight->setDirection(vec);

    mTestNode[1] = mSceneMgr->getOriginNode()->create();

    GeometrySpace* pEnt;
    pEnt = mSceneMgr->createGeo( "1", "robot.mesh" );
    //pEnt->setVisibleDistanceLimit(100);
    AnimationFusion* mAnimState = pEnt->getFusion("Walk");
    mAnimState->setEnabled(true);
    mAnimStateList.push_back(mAnimState);
    //pEnt->setMaterial("2 - Default");
    mTestNode[1]->attachObject( pEnt );
    mTestNode[1]->translate(Vector3f(0, -100, 0));

    pEnt = mSceneMgr->createGeo( "3", "knot.mesh" );
    mTestNode[2] = mSceneMgr->getOriginNode()->create(Vector3(-200, 0, -200));
    mTestNode[2]->attachObject( pEnt );

    createRandomEntityClones(pEnt, 20, Vector3(-1000,0,-1000), Vector3(1000,0,1000), mSceneMgr);

    // Transparent object (can force cast shadows)
    pEnt = mSceneMgr->createGeo( "3.5", "knot.mesh" );
    MaterialPtr tmat = MaterialManager::getSingleton().create("TestAlphaTransparency",
        TRANSIENT_RESOURCE_GROUP);
    tmat->setAlphaShadowCast(true);
    Pass * tpass = tmat->get(0)->get(0);
    tpass->setColour(ShaderCh::SOT_Set)->setAlphaReject(CM_GREATER);
    tpass->setColour(ShaderCh::SOT_Set)->setValue(150);
    tpass->setColour(ShaderCh::SOT_Set)->setAlphaCoverage(false);
    tpass->setBlend(ShaderCh::SOT_Set)->setBlend(FBM_INV_ALPHA);
    tpass->getTexture().create("gras_02.png");
    tpass->setCullingMode(CM_None);

    pEnt->setMaterial("TestAlphaTransparency");
    mTestNode[3] = mSceneMgr->getOriginNode()->create(Vector3(350, 0, -200));
    mTestNode[3]->attachObject( pEnt );

    MeshPtr msh = MeshManager::getSingleton().load("knot.mesh", TRANSIENT_RESOURCE_GROUP);
    msh->buildTangentBuffer(VT_Tangent);
    pEnt = mSceneMgr->createGeo( "4", "knot.mesh" );
    //pEnt->setMaterial("Examples/BumpMapping/MultiLightSpecular");
    mTestNode[2] = mSceneMgr->getOriginNode()->create(Vector3(100, 0, 200));
    mTestNode[2]->attachObject( pEnt );
    BoxSky * mBoxSky = N_new BoxSky(mSceneMgr);
    mBoxSky->setMaterial();
    mBoxSky->setRenderGroup(RQG_Sky);
    mSceneMgr->setSkyBox(true, "Examples/CloudyNoonSkyBox");

    MovablePlane movablePlane = MovablePlane(Vector3::Y, 100);
    MeshManager::getSingleton().createPlane("Myplane",
        TRANSIENT_RESOURCE_GROUP, movablePlane, 2500,2500,10,10,true,1,5,5,Vector3::Z);
    GeometrySpace * pPlaneEnt;
    pPlaneEnt = mSceneMgr->createGeo( "plane", "Myplane" );
    pPlaneEnt->setMaterial("2 - Default");
    pPlaneEnt->setCastShadow(false);
    static_cast<SpaceNode *>(mSceneMgr->getOriginNode()->create())->attachObject(pPlaneEnt);

    addTextureShadowDebugOverlay(1, mSceneMgr);
    mCamera->setPos(Ogre::Vector3f(0, 1000, 500));
    mCamera->lookAt(Ogre::Vector3f(0, 0, 0));
    mCamera->setFarClipDistance(10000);
}
//----------------------------------------------------------------------------
//----------------------------------------------------------------------------
void createRandomEntityClones(GeometrySpace* ent, size_t cloneCount,
    const Vector3& min, const Vector3& max, SpaceManager* mgr)
{
    GeometrySpace *cloneEnt;
    for (size_t n = 0; n < cloneCount; ++n)
    {
        // Create a new node under the root
        SpaceNode* node = mgr->createSpaceNode(0);
        // Random translate
        Vector3 nodePos;
        nodePos.x = Math::random(min.x, max.x);
        nodePos.y = Math::random(min.y, max.y);
        nodePos.z = Math::random(min.z, max.z);
        node->setPos(nodePos);
        mgr->getOriginNode()->add(node);
        cloneEnt = ent->clone(ent->getName() + "_clone" + StrConv::conv(n));
        // Attach to new node
        node->attachObject(cloneEnt);

    }
}

PlayPen_LotsAndLotsOfEntities::PlayPen_LotsAndLotsOfEntities()
{
    mInfo["Title"] = "PlayPen_LotsAndLotsOfEntities";
    mInfo["Description"] = "Tests setting up and rendering a lot of entities.";
    addScreenshotFrame(3);// only go a couple frames, this one is slow (and static)
}
//----------------------------------------------------------------------------

void PlayPen_LotsAndLotsOfEntities::setupContent()
{
    // Set ambient light
    mSceneMgr->setAmbient(Colour(0.5, 0.5, 0.5));

    // Create a point light
    Light* l = mSceneMgr->createLight("MainLight");
    l->setType(LT_DIRECTIONAL);
    l->setDirection(-Vector3::Y);

    // Create a set of random balls
    GeometrySpace* ent = mSceneMgr->createGeo("Ball", "cube.mesh");
    static_cast<SpaceNode *>(mSceneMgr->getOriginNode()->create())->attachObject(ent);
    createRandomEntityClones(ent, 3000, Vector3(-1000,-1000,-1000), Vector3(1000,1000,1000), mSceneMgr);

    //bool val = true;
    //mSceneMgr->setProperty("ShowOctree", &val);

    mCamera->setPos(Ogre::Vector3f(0, 0, -4000));
    mCamera->lookAt(Vector3::ZERO);

    // enable the profiler
    //Profiler* prof = Profiler::getSingletonPtr();
    //if (prof)
    //prof->setEnabled(true);


}
//----------------------------------------------------------------------------
//----------------------------------------------------------------------------

PlayPen_ManualBoneMovement::PlayPen_ManualBoneMovement()
{
    mInfo["Title"] = "PlayPen_ManualBoneMovement";
    mInfo["Description"] = "Tests manually controlling a skeletal animation bone.";
    addScreenshotFrame(50);
}
//----------------------------------------------------------------------------

bool PlayPen_ManualBoneMovement::onPreRender(const RenderFrameArgs * evt)
{
    mBone->yaw(Angle(evt->mCurrent*100));
    return true;
}
//----------------------------------------------------------------------------
void PlayPen_ManualBoneMovement::setupContent()
{
    GeometrySpace * ent = mSceneMgr->createGeo("robot", "robot.mesh");
    static_cast<SpaceNode *>(mSceneMgr->getOriginNode()->create())->attachObject(ent);
    mSceneMgr->setAmbient(Colour(0.8, 0.8, 0.8));

    //ent->setMaterial("Examples/Rocky");

    SkeletonFusion* skel = ent->getSkeleton();
    Animation* anim = skel->getAnimation("Walk");
    mBone = skel->get("Joint10");
    mBone->setManual(true);
    anim->destroyNodeTrack(mBone->getID());

    //AnimationFusion* animState = ent->getFusion("Walk");
    //animState->setEnabled(true);

    mCamera->setPos(Ogre::Vector3f(100, 50, 200));
    mCamera->lookAt(Ogre::Vector3f(0, 25, 0));
}
//----------------------------------------------------------------------------
//----------------------------------------------------------------------------

PlayPen_ManualIlluminationStage::PlayPen_ManualIlluminationStage()
{
    mInfo["Title"] = "PlayPen_ManualIlluminationStage";
    mInfo["Description"] = "Tests manual illumination stages.";
    addScreenshotFrame(10);
}
//----------------------------------------------------------------------------

void PlayPen_ManualIlluminationStage::setupContent()
{
    mSceneMgr->setShadowTechnique(SHADOWTYPE_STENCIL_ADDITIVE);
    mSceneMgr->getRenderPattern()->setExtent(1000);
    MaterialManager::getSingleton().setTextureFilter(TFM_ANISOTROPIC);
    MaterialManager::getSingleton().setTextureAniso(5);

    // Set ambient light
    mSceneMgr->setAmbient(Colour(0.0, 0.0, 0.0));

    Light * mLight = mSceneMgr->createLight("MainLight");
    mLight->setPos(Vecotr3f(-400, 400, -300));
    mLight->setDiffuse(0.9, 0.9, 1);
    mLight->setSpecular(0.9, 0.9, 1);
    mLight->setRange(6000);
    mLight->setAttenuationConstant(1);
    mLight->setAttenuationLinear(0.001);
    mLight->setAttenuationQuadric(0);
    mLight = mSceneMgr->createLight("Light2");
    mLight->setPos(Vecotr3f(300, 200, 100));
    mLight->setDiffuse(1, 0.6, 0.5);
    mLight->setSpecular(0.9, 0.9, 1);
    mLight->setRange(6000);
    mLight->setAttenuationConstant(1);
    mLight->setAttenuationLinear(0.001);
    mLight->setAttenuationQuadric(0);

    MeshPtr msh = MeshManager::getSingleton().load("knot.mesh", TRANSIENT_RESOURCE_GROUP);
    msh->buildTangentBuffer();
    GeometrySpace * pEnt = mSceneMgr->createGeo( "3.5", "knot.mesh" );
    pEnt->setMaterial("Examples/OffsetMapping/Specular");
    static_cast<SpaceNode *>(mSceneMgr->getOriginNode()->create())->attachObject( pEnt );

    Plane plane;
    plane.normal = Vector3::Y;
    plane.d = 100;
    MeshPtr planeMesh = MeshManager::getSingleton().createPlane("Myplane",
    TRANSIENT_RESOURCE_GROUP, plane,
    1500,1500,100,100,true,1,15,15,Vector3::Z);
    planeMesh->buildTangentBuffer();
    GeometrySpace* pPlaneEnt = mSceneMgr->createGeo( "plane", "Myplane" );
    pPlaneEnt->setMaterial("Examples/OffsetMapping/Specular");
    pPlaneEnt->setCastShadow(false);
    static_cast<SpaceNode *>(mSceneMgr->getOriginNode()->create())->attachObject(pPlaneEnt);

    mCamera->setPos(Ogre::Vector3f(180, 34, 223));
    mCamera->lookAt(Ogre::Vector3f(0, 50, 0));
}
//----------------------------------------------------------------------------
//----------------------------------------------------------------------------

PlayPen_CustomSpaceObj2D::PlayPen_CustomSpaceObj2D()
{
    mInfo["Title"] = "PlayPen_CustomSpaceObj2D";
    mInfo["Description"] = "Tests 2d manual objects.";
    addScreenshotFrame(10);
}
//----------------------------------------------------------------------------

void PlayPen_CustomSpaceObj2D::setupContent()
{
    CustomSpaceObj* man = mSceneMgr->createCustomGeo("1");
    man->begin(GeometryRaw::OT_TRIANGLE_LIST, "Examples/OgreLogo");
    man->position( 0.0, 0.0, 0.0);
    man->textureCoord( 0, 1 );

    man->position( 0.1, 0.0, 0.0);
    man->textureCoord( 1, 1 );

    man->position( 0.1, 0.1, 0.0);
    man->textureCoord( 1, 0 );

    man->position( 0.0, 0.1, 0.0);
    man->textureCoord( 0, 0 );

    man->triangle( 0, 1, 2 );
    man->triangle( 0, 2, 3 );

    man->setRenderGroup(Ogre::RQG_Overlay -1);
    man->end();
    man->on(GeometryObj::M_IdentityProj);
    man->on(GeometryObj::M_IdentityView);
    man->setCullType(CT_Always);

    SpaceNode* sn = mSceneMgr->getOriginNode()->create();
    sn->setScale(Vector3f(5,5,1));
    sn->attachObject(man);
}
//----------------------------------------------------------------------------
//----------------------------------------------------------------------------

PlayPen_CustomSpaceObjIndexed::PlayPen_CustomSpaceObjIndexed()
{
    mInfo["Title"] = "PlayPen_CustomSpaceObjIndexed";
    mInfo["Description"] = "Tests indexed manual objects.";
    addScreenshotFrame(10);
}
//----------------------------------------------------------------------------

void PlayPen_CustomSpaceObjIndexed::setupContent()
{
    mSceneMgr->setAmbient(Colour(0.5, 0.5, 0.5));
    Vector3 dir(-1, -1, 0.5);
    dir.normalise();
    Light* l = mSceneMgr->createLight("light1");
    l->setType(LT_DIRECTIONAL);
    l->setDirection(dir);

    Plane plane;
    plane.normal = Vector3::Y;
    plane.d = 100;
    MeshManager::getSingleton().createPlane("Myplane",
    TRANSIENT_RESOURCE_GROUP, plane,
    1500,1500,10,10,true,1,5,5,Vector3::Z);
    GeometrySpace* pPlaneEnt = mSceneMgr->createGeo( "plane", "Myplane" );
    pPlaneEnt->setMaterial("2 - Default");
    pPlaneEnt->setCastShadow(false);
    static_cast<SpaceNode *>(mSceneMgr->getOriginNode()->create())->attachObject(pPlaneEnt);

    CustomSpaceObj* man = static_cast<CustomSpaceObj*>(
    mSceneMgr->createSpace("test", N_FACTORY_CUSTOMSPACE));

    man->begin(GeometryRaw::OT_TRIANGLE_LIST, "Examples/OgreLogo");
    // Define a 40x40 plane, indexed
    man->position(-20, 20, 20);
    man->normal(0, 0, 1);
    man->textureCoord(0, 0);

    man->position(-20, -20, 20);
    man->normal(0, 0, 1);
    man->textureCoord(0, 1);

    man->position(20, -20, 20);
    man->normal(0, 0, 1);
    man->textureCoord(1, 1);

    man->position(20, 20, 20);
    man->normal(0, 0, 1);
    man->textureCoord(1, 0);

    man->quad(0, 1, 2, 3);

    man->end();

    man->begin(GeometryRaw::OT_TRIANGLE_LIST, "Examples/BumpyMetal");

    // Define a 40x40 plane, indexed
    man->position(-20, 20, 20);
    man->normal(0, 1, 0);
    man->textureCoord(0, 0);

    man->position(20, 20, 20);
    man->normal(0, 1, 0);
    man->textureCoord(0, 1);

    man->position(20, 20, -20);
    man->normal(0, 1, 0);
    man->textureCoord(1, 1);

    man->position(-20, 20, -20);
    man->normal(0, 1, 0);
    man->textureCoord(1, 0);

    man->quad(0, 1, 2, 3);

    man->end();


    static_cast<SpaceNode *>(mSceneMgr->getOriginNode()->create())->attachObject(man);

    mCamera->setPos(Ogre::Vector3f(100, 100, 100);
    mCamera->lookAt(Ogre::Vector3f(0, 0, 0));

}
//----------------------------------------------------------------------------
//----------------------------------------------------------------------------

PlayPen_CustomSpaceObjIndexedUpdateLarger::PlayPen_CustomSpaceObjIndexedUpdateLarger()
{
    mInfo["Title"] = "PlayPen_CustomSpaceObjIndexedUpdateLarger";
    mInfo["Description"] = "Tests updating indexed manual objects.";
}
//----------------------------------------------------------------------------

void PlayPen_CustomSpaceObjIndexedUpdateLarger::setupContent()
{
    PlayPen_CustomSpaceObjIndexed::setupContent();
    CustomSpaceObj* man = static_cast<CustomSpaceObj*>(
    mSceneMgr->getSpace("test", N_FACTORY_CUSTOMSPACE));


    man->beginModify(0);
    // 1 quad larger
    man->position(-20, 20, 20);
    man->normal(0, 0, 1);
    man->textureCoord(0, 0);

    man->position(-20, -20, 20);
    man->normal(0, 0, 1);
    man->textureCoord(0, 1);

    man->position(20, -20, 20);
    man->normal(0, 0, 1);
    man->textureCoord(1, 1);

    man->position(20, 20, 20);
    man->normal(0, 0, 1);
    man->textureCoord(1, 0);


    man->position(-20, 40, 20);
    man->normal(0, 0, 1);
    man->textureCoord(0, 0);

    man->position(-20, 20, 20);
    man->normal(0, 0, 1);
    man->textureCoord(0, 1);

    man->position(20, 20, 20);
    man->normal(0, 0, 1);
    man->textureCoord(1, 1);

    man->position(20, 40, 20);
    man->normal(0, 0, 1);
    man->textureCoord(1, 0);

    man->quad(0, 1, 2, 3);
    man->quad(4, 5, 6, 7);

    man->end();

}
//----------------------------------------------------------------------------
//----------------------------------------------------------------------------

PlayPen_CustomSpaceObjIndexedUpdateSmaller::PlayPen_CustomSpaceObjIndexedUpdateSmaller()
{
    mInfo["Title"] = "PlayPen_CustomSpaceObjIndexedUpdateSmaller";
    mInfo["Description"] = "Tests updating indexed manual objects.";
}
//----------------------------------------------------------------------------

void PlayPen_CustomSpaceObjIndexedUpdateSmaller::setupContent()
{
    PlayPen_CustomSpaceObjIndexed::setupContent();
    CustomSpaceObj* man = static_cast<CustomSpaceObj*>(
    mSceneMgr->getSpace("test", N_FACTORY_CUSTOMSPACE));


    man->beginModify(0);
    // 1 tri smaller
    man->position(-20, 20, 20);
    man->normal(0, 0, 1);
    man->textureCoord(0, 0);

    man->position(-20, -20, 20);
    man->normal(0, 0, 1);
    man->textureCoord(0, 1);

    man->position(20, -20, 20);
    man->normal(0, 0, 1);
    man->textureCoord(1, 1);

    man->triangle(0, 1, 2);

    man->end();

}
//----------------------------------------------------------------------------
//----------------------------------------------------------------------------

PlayPen_CustomSpaceObjNonIndexed::PlayPen_CustomSpaceObjNonIndexed()
{
    mInfo["Title"] = "PlayPen_CustomSpaceObjNonIndexed";
    mInfo["Description"] = "Tests non-indexed manual objects.";
    addScreenshotFrame(10);
}
//----------------------------------------------------------------------------

void PlayPen_CustomSpaceObjNonIndexed::setupContent()
{
    mSceneMgr->setAmbient(Colour(0.5, 0.5, 0.5));
    Vector3 dir(-1, -1, 0.5);
    dir.normalise();
    Light* l = mSceneMgr->createLight("light1");
    l->setType(LT_DIRECTIONAL);
    l->setDirection(dir);

    Plane plane;
    plane.normal = Vector3::Y;
    plane.d = 100;
    MeshManager::getSingleton().createPlane("Myplane",
    TRANSIENT_RESOURCE_GROUP, plane,
    1500,1500,10,10,true,1,5,5,Vector3::Z);
    GeometrySpace* pPlaneEnt = mSceneMgr->createGeo( "plane", "Myplane" );
    pPlaneEnt->setMaterial("2 - Default");
    pPlaneEnt->setCastShadow(false);
    static_cast<SpaceNode *>(mSceneMgr->getOriginNode()->create())->attachObject(pPlaneEnt);

    CustomSpaceObj* man = static_cast<CustomSpaceObj*>(
        mSceneMgr->createSpace("test", N_FACTORY_CUSTOMSPACE));

    man->begin(GeometryRaw::OT_TRIANGLE_LIST, "Examples/OgreLogo");
    // Define a 40x40 plane, non-indexed
    man->position(-20, 20, 20);
    man->normal(0, 0, 1);
    man->textureCoord(0, 0);

    man->position(-20, -20, 20);
    man->normal(0, 0, 1);
    man->textureCoord(0, 1);

    man->position(20, 20, 20);
    man->normal(0, 0, 1);
    man->textureCoord(1, 0);

    man->position(-20, -20, 20);
    man->normal(0, 0, 1);
    man->textureCoord(0, 1);

    man->position(20, -20, 20);
    man->normal(0, 0, 1);
    man->textureCoord(1, 1);

    man->position(20, 20, 20);
    man->normal(0, 0, 1);
    man->textureCoord(1, 0);

    man->end();

    man->begin(GeometryRaw::OT_TRIANGLE_LIST, "Examples/BumpyMetal");

    // Define a 40x40 plane, non-indexed
    man->position(-20, 20, 20);
    man->normal(0, 1, 0);
    man->textureCoord(0, 0);

    man->position(20, 20, 20);
    man->normal(0, 1, 0);
    man->textureCoord(0, 1);

    man->position(20, 20, -20);
    man->normal(0, 1, 0);
    man->textureCoord(1, 1);

    man->position(20, 20, -20);
    man->normal(0, 1, 0);
    man->textureCoord(1, 1);

    man->position(-20, 20, -20);
    man->normal(0, 1, 0);
    man->textureCoord(1, 0);

    man->position(-20, 20, 20);
    man->normal(0, 1, 0);
    man->textureCoord(0, 0);

    man->end();

    static_cast<SpaceNode *>(mSceneMgr->getOriginNode()->create())->attachObject(man);
    mCamera->setPos(NII::Vector3f(100,100,100));
    mCamera->lookAt(Ogre::Vector3(0,0,0));
}
//----------------------------------------------------------------------------
//----------------------------------------------------------------------------

PlayPen_CustomSpaceObjNonIndexedUpdateLarger::PlayPen_CustomSpaceObjNonIndexedUpdateLarger()
{
    mInfo["Title"] = "PlayPen_CustomSpaceObjNonIndexedUpdateLarger";
    mInfo["Description"] = "Tests updating non-indexed manual objects.";
}
//----------------------------------------------------------------------------

void PlayPen_CustomSpaceObjNonIndexedUpdateLarger::setupContent()
{
    PlayPen_CustomSpaceObjNonIndexed::setupContent();
    CustomSpaceObj* man = static_cast<CustomSpaceObj*>(
    mSceneMgr->getSpace("test", N_FACTORY_CUSTOMSPACE));

    // Redefine but make larger (2 more tri)
    man->beginModify(0);

    man->position(-20, 20, 20);
    man->normal(0, 0, 1);
    man->textureCoord(0, 0);

    man->position(-20, -20, 20);
    man->normal(0, 0, 1);
    man->textureCoord(0, 1);

    man->position(20, 20, 20);
    man->normal(0, 0, 1);
    man->textureCoord(1, 0);

    man->position(-20, -20, 20);
    man->normal(0, 0, 1);
    man->textureCoord(0, 1);

    man->position(20, -20, 20);
    man->normal(0, 0, 1);
    man->textureCoord(1, 1);

    man->position(20, 20, 20);
    man->normal(0, 0, 1);
    man->textureCoord(1, 0);


    man->position(-20, 40, 20);
    man->normal(0, 0, 1);
    man->textureCoord(0, 0);

    man->position(-20, 20, 20);
    man->normal(0, 0, 1);
    man->textureCoord(0, 1);

    man->position(20, 40, 20);
    man->normal(0, 0, 1);
    man->textureCoord(1, 0);

    man->position(-20, 20, 20);
    man->normal(0, 0, 1);
    man->textureCoord(0, 1);

    man->position(20, 20, 20);
    man->normal(0, 0, 1);
    man->textureCoord(1, 1);

    man->position(20, 40, 20);
    man->normal(0, 0, 1);
    man->textureCoord(1, 0);


    man->end();

}
//----------------------------------------------------------------------------
//----------------------------------------------------------------------------

PlayPen_CustomSpaceObjNonIndexedUpdateSmaller::PlayPen_CustomSpaceObjNonIndexedUpdateSmaller()
{
    mInfo["Title"] = "PlayPen_CustomSpaceObjNonIndexedUpdateSmaller";
    mInfo["Description"] = "Tests updating non-indexed manual objects.";
}
//----------------------------------------------------------------------------

void PlayPen_CustomSpaceObjNonIndexedUpdateSmaller::setupContent()
{
    PlayPen_CustomSpaceObjNonIndexed::setupContent();
    CustomSpaceObj* man = static_cast<CustomSpaceObj*>(
    mSceneMgr->getSpace("test", N_FACTORY_CUSTOMSPACE));

    // Redefine but make smaller (one tri less)
    man->beginModify(0);

    man->position(-30, 30, 30);
    man->normal(0, 0, 1);
    man->textureCoord(0, 0);

    man->position(-30, -30, 30);
    man->normal(0, 0, 1);
    man->textureCoord(0, 1);

    man->position(90, 30, 30);
    man->normal(0, 0, 1);
    man->textureCoord(1, 0);

    man->end();
}
//----------------------------------------------------------------------------
//----------------------------------------------------------------------------
PlayPen_MaterialSchemes::PlayPen_MaterialSchemes()
{
    mInfo["Title"] = "PlayPen_MaterialSchemes";
    mInfo["Description"] = "Tests material scehemes in viewports.";
    addScreenshotFrame(10);
}
//----------------------------------------------------------------------------
void PlayPen_MaterialSchemes::setupContent()
{
    GeometrySpace * ent = mSceneMgr->createGeo("robot", "robot.mesh");
    static_cast<SpaceNode *>(mSceneMgr->getOriginNode()->create())->attachObject(ent);
    mSceneMgr->setAmbient(Colour(0.8, 0.8, 0.8));

    MaterialPtr mat = MaterialManager::getSingleton().create("schemetest",
    TRANSIENT_RESOURCE_GROUP);
    // default scheme
    mat->get(0)->get(0)->getTexture().create("GreenSkin.jpg");

    Technique * t = mat->createTechnique();
    t->setSchemeID("newscheme");
    t->create()->getTexture().create("rockwall.tga");
    ent->setMaterial("schemetest");

    // create a second viewport using alternate scheme
    Viewport * vp = mWindow->createViewport(mCamera, 0.75, 0, 0.25, 0.25, 1);
    vp->setMaterial("newscheme");
    vp->setOverlayEnable(false);

    mCamera->setPos(NII::Vector3f(0,75,200));
}
//----------------------------------------------------------------------------
//----------------------------------------------------------------------------

PlayPen_MaterialSchemesListener::PlayPen_MaterialSchemesListener()
{
    mInfo["Title"] = "PlayPen_MaterialSchemesListener";
    mInfo["Description"] = "Tests material scheme listener.";
    addScreenshotFrame(10);
}
//----------------------------------------------------------------------------

class TestMatMgrListener : public MaterialMatchListener
{
public:
    TestMatMgrListener() : mTech(0) {}
    Technique * mTech;

    Technique * miss(Material * mat, SchemeID sid, const GeometryObj * geo, unsigned short lod)
    {
        return mTech;
    }
};
TestMatMgrListener schemeListener;

void PlayPen_MaterialSchemesListener::setupContent()
{
    GeometrySpace *ent = mSceneMgr->createGeo("robot", "robot.mesh");
    static_cast<SpaceNode *>(mSceneMgr->getOriginNode()->create())->attachObject(ent);
    mSceneMgr->setAmbient(Colour(0.8, 0.8, 0.8));

    // create a second viewport using alternate scheme
    // notice it's not defined in a technique
    Viewport* vp = mWindow->createViewport(mCamera, 0.75, 0, 0.25, 0.25, 1);
    vp->setMaterial("newscheme");
    vp->setOverlayEnable(false);

    MaterialPtr mat = MaterialManager::getSingleton().create("schemetest",
    TRANSIENT_RESOURCE_GROUP);
    // default scheme
    mat->get(0)->get(0)->getTexture().create("GreenSkin.jpg");

    schemeListener.mTech = mat->get(0);

    MaterialManager::getSingleton().add(&schemeListener);

    mCamera->setPos(NII::Vector3f(0,75,200));
}
//----------------------------------------------------------------------------
//----------------------------------------------------------------------------

PlayPen_MaterialSchemesWithLOD::PlayPen_MaterialSchemesWithLOD()
{
    mInfo["Title"] = "PlayPen_MaterialSchemesWithLOD";
    mInfo["Description"] = "Tests material schemes with LODs.";
    addScreenshotFrame(10);
}
//----------------------------------------------------------------------------

void PlayPen_MaterialSchemesWithLOD::setupContent()
{

    GeometrySpace *ent = mSceneMgr->createGeo("robot", "robot.mesh");
    static_cast<SpaceNode *>(mSceneMgr->getOriginNode()->create())->attachObject(ent);
    mSceneMgr->setAmbient(Colour(0.8, 0.8, 0.8));

    MaterialPtr mat = MaterialManager::getSingleton().create("schemetest",
    TRANSIENT_RESOURCE_GROUP);
    // default scheme
    mat->get(0)->get(0)->getTexture().create("GreenSkin.jpg");

    // LOD 0, newscheme
    ShaderFusion * t = mat->createTechnique();
    t->setSchemeID("newscheme");
    t->create()->getTexture().create("rockwall.tga");
    ent->setMaterial("schemetest");

    // LOD 1, default
    t = mat->createTechnique();
    t->setLodIndex(1);
    t->create()->getTexture().create("Water02.jpg");

    // LOD 1, newscheme
    t = mat->createTechnique();
    t->setLodIndex(1);
    t->create()->getTexture().create("r2skin.jpg");
    t->setSchemeID("newscheme");

    Material::LodValueList ldl;
    //ldl.push_back(Math::Sqr(500.0f));
    ldl.push_back(150.0f);
    mat->setLodLevels(ldl);

    ent->setMaterial("schemetest");

    // create a second viewport using alternate scheme
    Viewport* vp = mWindow->createViewport(mCamera, 0.75, 0, 0.25, 0.25, 1);
    vp->setMaterial("newscheme");
    vp->setOverlayEnable(false);

    mCamera->setPos(NII::Vector3f(0,90,250));
    //mCamera->lookAt(Vector3(0,0,0));
}
//----------------------------------------------------------------------------
//----------------------------------------------------------------------------

PlayPen_MaterialSchemesWithMismatchedLOD::PlayPen_MaterialSchemesWithMismatchedLOD()
{
    mInfo["Title"] = "PlayPen_MaterialSchemesWithMismatchedLOD";
    mInfo["Description"] = "Tests material scehemes in viewports with mismatched LODs.";
    addScreenshotFrame(10);
}
//----------------------------------------------------------------------------

void PlayPen_MaterialSchemesWithMismatchedLOD::setupContent()
{

    GeometrySpace *ent = mSceneMgr->createGeo("robot", "robot.mesh");
    static_cast<SpaceNode *>(mSceneMgr->getOriginNode()->create())->attachObject(ent);
    mSceneMgr->setAmbient(Colour(0.8, 0.8, 0.8));

    MaterialPtr mat = MaterialManager::getSingleton().create("schemetest",
    TRANSIENT_RESOURCE_GROUP);
    // default scheme
    mat->get(0)->get(0)->getTexture().create("GreenSkin.jpg");

    // LOD 0, newscheme
    ShaderFusion * t = mat->createTechnique();
    t->setSchemeID("newscheme");
    t->create()->getTexture().create("rockwall.tga");
    ent->setMaterial("schemetest");

    // LOD 1, default
    t = mat->createTechnique();
    t->setLodIndex(1);
    t->create()->getTexture().create("Water02.jpg");

    // LOD 2, default
    t = mat->createTechnique();
    t->setLodIndex(2);
    t->create()->getTexture().create("clouds.jpg");

    // LOD 1, newscheme
    t = mat->createTechnique();
    t->setLodIndex(1);
    t->create()->getTexture().create("r2skin.jpg");
    t->setSchemeID("newscheme");

    // No LOD 2 for newscheme! Should fallback on LOD 1

    Material::LodValueList ldl;
    //ldl.push_back(Math::Sqr(250.0f));
    //ldl.push_back(Math::Sqr(500.0f));
    ldl.push_back(150.0f);
    ldl.push_back(300.0f);
    mat->setLodLevels(ldl);

    ent->setMaterial("schemetest");

    // create a second viewport using alternate scheme
    Viewport* vp = mWindow->createViewport(mCamera, 0.75, 0, 0.25, 0.25, 1);
    vp->setMaterial("newscheme");
    vp->setOverlayEnable(false);

    mCamera->setPos(NII::Vector3f(0,90,350));
}
//----------------------------------------------------------------------------
//----------------------------------------------------------------------------

/*PlayPen_MRTCompositorScript::PlayPen_MRTCompositorScript()
{
    mInfo["Title"] = "PlayPen_MRTCompositorScript";
    mInfo["Description"] = "Tests MRT compositor.";
    addScreenshotFrame(250);
}
//----------------------------------------------------------------------------

void PlayPen_MRTCompositorScript::setupContent()
{

    GeometrySpace* e = mSceneMgr->createGeo("e1", "knot.mesh");
    e->setMaterial("Ogre/MRTtest/scene");
    static_cast<SpaceNode *>(mSceneMgr->getOriginNode()->create())->attachObject(e);
    mCamera->setPos(NII::Vector3f(0, 0, -100));
    mCamera->lookAt(Vector3::ZERO);

    CompositorInstance* compInst =
    CompositorManager::getSingleton().addCompositor(mWindow->getViewport(0), "TestMRT");
    CompositorManager::getSingleton().setCompositorEnabled(mWindow->getViewport(0), "TestMRT", true);

    // Set up debug panels for each of the MRT outputs
    String texName = compInst->getTextureInstanceName("mrt0", 0);
    addTextureDebugOverlay(TextureManager::getSingleton().getByName(texName), 0);
    texName = compInst->getTextureInstanceName("mrt0", 1);
    addTextureDebugOverlay(TextureManager::getSingleton().getByName(texName), 1);
    texName = compInst->getTextureInstanceName("mrt0", 2);
    addTextureDebugOverlay(TextureManager::getSingleton().getByName(texName), 2);
    texName = compInst->getTextureInstanceName("mrt0", 3);
    addTextureDebugOverlay(TextureManager::getSingleton().getByName(texName), 3);
}*/
//----------------------------------------------------------------------------
//----------------------------------------------------------------------------

/*PlayPen_MRT::PlayPen_MRT()
{
    mInfo["Title"] = "PlayPen_MRT";
    mInfo["Description"] = "Tests MRT.";
    addScreenshotFrame(250);
}
//----------------------------------------------------------------------------

void PlayPen_MRT::setupContent()
{
    TexturePtr Tex[2];
    MultiTextureFrame* mrtTex;

    Viewport* viewport = mWindow->getViewport(0);
    int width = viewport->getPixelWidth();
    int height = viewport->getPixelHeight();

    Tex[0] = N_Only(TextureManager).createTexture( "diffusemap", TRANSIENT_RESOURCE_GROUP, TEX_TYPE_2D,
    width,height,0,PF_R8G8B8A8ui,Texture::MM_FRAME_RGB);
    Tex[1] = N_Only(TextureManager).createTexture( "normalmap",TRANSIENT_RESOURCE_GROUP, TEX_TYPE_2D,
    width,height,0,PF_R8G8B8A8ui,Texture::MM_FRAME_RGB);

    //    assert(Tex[0]->getFormat() == PF_R16G16B16A16);

    mrtTex = Ogre::Root::getSingleton().getRender()->createMultiFrame("MRT");
    TextureFrame* rTex[2];
    rTex[0] = Tex[0]->getBuffer()->getBuffer();
    rTex[1] = Tex[1]->getBuffer()->getBuffer();

    rTex[0]->setAutoFlush(false);
    rTex[1]->setAutoFlush(false);
    mrtTex->attach(0, rTex[0]);
    mrtTex->attach(1, rTex[1]);
    mrtTex->setAutoFlush(true);

    Viewport *v = mrtTex->createViewport(mCamera);
    v->setMaterial("MRT");
    v->setAutoClear(true);
    v->setOverlayEnable(false);
    v->setSkyEnable(false);
    v->setBgColour(Colour(0,0,0,0));

    // Create texture overlay here
    Overlay *debugOverlay = OverlayManager::getSingleton().create("Core/DebugOverlay");
    MaterialPtr debugMat = MaterialManager::getSingleton().create("DebugRTTMat1", TRANSIENT_RESOURCE_GROUP);
    debugMat->get(0)->get(0)->setLight(false);
    ShaderChTextureUnit *t = debugMat->get(0)->get(0)->getTexture().create("normalmap");

    t->setUAddressing(TAM_CLAMP);
    t->setVAddressing(TAM_CLAMP);
    t->setWAddressing(TAM_CLAMP);
    OverlayView *debugPanel = (OverlayView *) N_Only(Overlay).createGeo("Panel","DebugRTTPanel1");
    debugPanel->setUnitPos(0.8,0);
    debugPanel->setUnitSize(0.2,0.3);
    debugPanel->setMaterial(debugMat->getName());
    debugOverlay->add(debugPanel);

    debugMat = MaterialManager::getSingleton().create("DebugRTTMat2", TRANSIENT_RESOURCE_GROUP);
    debugMat->get(0)->get(0)->setLight(false);
    t = debugMat->get(0)->get(0)->getTexture().create("diffusemap");
    t->setUAddressing(TAM_CLAMP);
    t->setVAddressing(TAM_CLAMP);
    t->setWAddressing(TAM_CLAMP);
    debugPanel = (OverlayView *) N_Only(Overlay).createGeo("Panel","DebugRTTPanel2");
    debugPanel->setUnitPos(0.8,0.3);
    debugPanel->setUnitSize(0.2,0.3);
    debugPanel->setMaterial(debugMat->getName());
    debugOverlay->add(debugPanel);
    // Create scene items

    // Create a material to render differently to MRT compared to main viewport
    MaterialPtr mat = MaterialManager::getSingleton().create("MRTTest",
    TRANSIENT_RESOURCE_GROUP);
    // normal technique (0), leave as default
    Technique* mrtTech = mat->createTechnique();
    mrtTech->setSchemeID("MRT");
    ShaderCh * mrtPass = mrtTech->create();
    mrtPass->getProgram().set(ST_VS, 0, "DeferredShading/material/hlsl/vs");
    mrtPass->getProgram().set(ST_FS, 0, "DeferredShading/material/hlsl/ps");
    mrtPass->getTexture().create("rockwall.tga");
    mat->load();

    GeometrySpace* ent = mSceneMgr->createGeo("knot", "knot.mesh");
    ent->setMaterial("MRTTest");
    static_cast<SpaceNode *>(mSceneMgr->getOriginNode()->create())->attachObject(ent);

    mCamera->setPos(NII::Vector3f(0, 0, 200));
    mCamera->lookAt(Vector3::ZERO);

}*/
//----------------------------------------------------------------------------
//----------------------------------------------------------------------------

PlayPen_MultiSceneManagersSimple::PlayPen_MultiSceneManagersSimple()
{
    mInfo["Title"] = "PlayPen_MultiSceneManagersSimple";
    mInfo["Description"] = "Tests multiple scene managers.";
    addScreenshotFrame(10);
}
//----------------------------------------------------------------------------

void PlayPen_MultiSceneManagersSimple::setupContent()
{
    // Create a secondary scene manager with it's own camera
    SpaceManager* sm2 = Root::getSingleton().createSpaceManager(SpaceTypeVerbose::ST_Normal);
    Camera* camera2 = sm2->createCamera("cam2");
    camera2->setPos(NII::Vector3f(0,0,-500));
    camera2->lookAt(Vector3::ZERO);
    GeometrySpace* ent = sm2->createGeo("knot2", "knot.mesh");
    static_cast<SpaceNode *>(sm2->getOriginNode()->create())->attachObject(ent);
    Light* l = sm2->createLight("l2");
    l->setPos(Vecotr3f(100, 50, -100));
    l->setDiffuse(Colour::Green);
    sm2->setAmbient(Colour(0.2, 0.2, 0.2));

    Viewport* vp = mWindow->createViewport(camera2, 0.67, 0, 0.33, 0.25, 1);
    vp->setOverlayEnable(false);
    vp->setBgColour(Colour(1,0,0));

    // Use original SM for normal scene
    ent = mSceneMgr->createGeo("head", "ogrehead.mesh");
    static_cast<SpaceNode *>(mSceneMgr->getOriginNode()->create())->attachObject(ent);
    l = mSceneMgr->createLight("l2"); // note same name, will work since different SM
    l->setPos(Vecotr3f(100, 50, -100));
    l->setDiffuse(Colour::Red);
    mSceneMgr->setAmbient(Colour(0.2, 0.2, 0.2));
    mCamera->setPos(NII::Vector3f(0,0,500));
}
//----------------------------------------------------------------------------
//----------------------------------------------------------------------------

PlayPen_MultiViewports::PlayPen_MultiViewports()
{
    mInfo["Title"] = "PlayPen_MultiViewports";
    mInfo["Description"] = "Tests multiple viewports.";
    addScreenshotFrame(10);
}
//----------------------------------------------------------------------------

void PlayPen_MultiViewports::setupContent()
{
    SpaceNode * mTestNode[3];

    // Set ambient light
    mSceneMgr->setAmbient(Colour(0.5, 0.5, 0.5));

    // Create a point light
    Light * l = mSceneMgr->createLight("MainLight");
    l->setType(LT_DIRECTIONAL);
    l->setDirection(-Vector3::Y);

    GeometrySpace * pEnt = mSceneMgr->createGeo( "1", "knot.mesh" );
    static_cast<SpaceNode *>(mSceneMgr->getOriginNode()->create(Vector3(-30,0,-50)))->attachObject(pEnt);

    mTestNode[0] = mSceneMgr->getOriginNode()->create();

    pEnt = mSceneMgr->createGeo( "2", "ogrehead.mesh" );
    mTestNode[0]->attachObject( pEnt );
    mTestNode[0]->translate(Vector3f(0, 0, 200));

    Ogre::Frustum * frustum = new Frustum();
    //frustum->setVisible(true);
    frustum->setFarClipDistance(5000);
    frustum->setNearClipDistance(100);
    mTestNode[0]->attachObject(frustum);

    Viewport * vp = mRoot->getView()->createViewport(mCamera, 0.5, 0.5, 0.5, 0.5, 1);
    vp->setOverlayEnable(false);
    vp->setBgColour(Colour(1,0,0));

    mCamera->setPos(NII::Vector3f(0,0,500));

}
//----------------------------------------------------------------------------
//----------------------------------------------------------------------------

PlayPen_NegativeScale::PlayPen_NegativeScale()
{
    mInfo["Title"] = "PlayPen_NegativeScale";
    mInfo["Description"] = "Tests negative scaling.";
    addScreenshotFrame(10);
}
//----------------------------------------------------------------------------

void PlayPen_NegativeScale::setupContent()
{
    mSceneMgr->setAmbient(Colour(0.2, 0.2, 0.2));
    Light* l = mSceneMgr->createLight("l1");
    l->setPos(Vecotr3f(500, 500, 200));
    l->setDiffuse(Colour::White);

    //mSceneMgr->setNegScaleFlipCull(false);

    GeometrySpace *e = mSceneMgr->createGeo("1", "knot.mesh");

    static_cast<SpaceNode *>(mSceneMgr->getOriginNode()->create())->attachObject(e);

    // one reflection
    e = mSceneMgr->createGeo("2", "knot.mesh");
    SpaceNode * n = mSceneMgr->getOriginNode()->create();
    n->translate(Vector3f(-200, 0, 0));
    n->scale(Vector3f(-1, 1, 1));
    n->attachObject(e);

    // three reflections - will need flipping
    e = mSceneMgr->createGeo("3", "knot.mesh");
    n = mSceneMgr->getOriginNode()->create();
    n->translate(Vector3f(200, 0, 0));
    n->scale(Vector3f(-1, -1, -1));
    n->attachObject(e);

    // two reflections - won't need flipping
    e = mSceneMgr->createGeo("4", "knot.mesh");
    n = mSceneMgr->getOriginNode()->create();
    n->translate(Vector3f(400, 0, 0));
    n->scale(Vector3f(-1, 1, -1));
    n->attachObject(e);

    mWindow->getViewport(0)->setBgColour(Colour::Red);

    mCamera->setPos(NII::Vector3f(0,0,300));
    mCamera->lookAt(Vector3::ZERO);

}
//----------------------------------------------------------------------------
//----------------------------------------------------------------------------

PlayPen_NormalMapMirroredUVs::PlayPen_NormalMapMirroredUVs()
{
    mInfo["Title"] = "PlayPen_NormalMapMirroredUVs";
    mInfo["Description"] = "Tests mirrored UVs with normal mapping shader.";
    addScreenshotFrame(10);
}
//----------------------------------------------------------------------------

void PlayPen_NormalMapMirroredUVs::setupContent()
{
    Ogre::ResourceSchemeManager::getSingleton().setup("Tests");

    // this mesh has been generated with 4-component tangents, including a parity in w
    GeometrySpace* e = mSceneMgr->createGeo("2", "testmirroreduvmesh.mesh");
    e->setMaterial("Examples/BumpMapping/MultiLightTangentParity");
    // here's what it looks like without the parity
    //e->setMaterial("Examples/BumpMapping/MultiLight");

    static_cast<SpaceNode *>(mSceneMgr->getOriginNode()->create())->attachObject(e);

    Light* l = mSceneMgr->createLight("3");
    l->setPos(Vecotr3f(1000, 500, 1000));

    mCamera->setPos(NII::Vector3f(0, 200, 50));
    mCamera->lookAt(Vector3::ZERO);

    mSceneMgr->setAmbient(Colour(0.2, 0.2, 0.2));
}
//----------------------------------------------------------------------------
//----------------------------------------------------------------------------

PlayPen_Ortho::PlayPen_Ortho()
{
    mInfo["Title"] = "PlayPen_Ortho";
    mInfo["Description"] = "Tests orthographic rendering.";
    addScreenshotFrame(10);
}
//----------------------------------------------------------------------------

void PlayPen_Ortho::setupContent()
{
    SpaceNode* mTestNode[3];

    // Set ambient light
    mSceneMgr->setAmbient(Colour(0.0, 0.0, 0.0));

    // Create a point light
    Light* l = mSceneMgr->createLight("MainLight");
    l->setPos(Vecotr3f(800, 600, 0));

    mTestNode[0] = mSceneMgr->getOriginNode()->create();
    SpaceNode* mLightNode = mSceneMgr->getOriginNode()->create();

    GeometrySpace* pEnt = mSceneMgr->createGeo( "3", "knot.mesh" );
    mTestNode[1] = mSceneMgr->getOriginNode()->create(Vector3(-200, 0, -200));
    mTestNode[1]->attachObject( pEnt );

    pEnt = mSceneMgr->createGeo( "4", "knot.mesh" );
    mTestNode[2] = mSceneMgr->getOriginNode()->create(Vector3(100, 0, 200));
    mTestNode[2]->attachObject( pEnt );

    BoxSky * mBoxSky = N_new BoxSky(mSceneMgr);
    mBoxSky->setMaterial();
    mBoxSky->setRenderGroup(RQG_Sky);
    mSceneMgr->setSkyBox(true, "Examples/CloudyNoonSkyBox");


    Plane plane;
    plane.normal = Vector3::Y;
    plane.d = 100;
    MeshManager::getSingleton().createPlane("Myplane",
    TRANSIENT_RESOURCE_GROUP, plane,
    1500,1500,10,10,true,1,5,5,Vector3::Z);
    GeometrySpace* pPlaneEnt = mSceneMgr->createGeo( "plane", "Myplane" );
    pPlaneEnt->setMaterial("2 - Default");
    pPlaneEnt->setCastShadow(false);
    static_cast<SpaceNode *>(mSceneMgr->getOriginNode()->create())->attachObject(pPlaneEnt);

    mCamera->setCustomYaw(false);
    mCamera->setProjType(Frustum::T_Orthogonal);
    mCamera->setPos(NII::Vector3f(0,10000,0));
    mCamera->lookAt(Ogre::Vector3f(0,0,0));
    mCamera->setNearClipDistance(1000);

}
//----------------------------------------------------------------------------
//----------------------------------------------------------------------------

PlayPen_PointSprites::PlayPen_PointSprites()
{
    mInfo["Title"] = "PlayPen_PointSprites";
    mInfo["Description"] = "Tests point sprites.";
    addScreenshotFrame(10);
}
//----------------------------------------------------------------------------
void PlayPen_PointSprites::setupContent()
{
    Material * mat = MaterialManager::getSingleton().create("spriteTest1",
        TRANSIENT_RESOURCE_GROUP);
    Pass * p = mat->get(0)->get(0);
    p->setPoint(ShaderCh::SOT_Set)->setSpritesEnable(true);
    p->getTexture().create("flare.png");
    p->setLight(false);
    p->setStencil(ShaderCh::SOT_Set)->setDepthWrite(false);
    p->setBlend(ShaderCh::SOT_Set)->setBlend(FBM_ADD);
    p->setPoint(ShaderCh::SOT_Set)->setAttenuateEnable(true);
    p->getPoint(ShaderCh::SOT_Get)->getSize(1);

    CustomSpaceObj * man = mSceneMgr->createCustomGeo("man");
    man->begin(GeometryRaw::OT_POINT_LIST, "spriteTest1");

    for(size_t i = 0; i < 1000; ++i)
    {
        man->position(Math::randomNegPos() * 500,
        Math::randomNegPos() * 500,
        Math::randomNegPos() * 500);
        man->colour(Math::random(0.5f, 1.0f),
        Math::random(0.5f, 1.0f), Math::random(0.5f, 1.0f));
    }

    /*for (size_t i = 0; i < 20; ++i)
    {
        for (size_t j = 0; j < 20; ++j)
        {
            for (size_t k = 0; k < 20; ++k)
            {
                if(rand()%10 == 0)
                    man->position(i * 30, j * 30, k * 30);
            }
        }
    }*/

    man->end();
    static_cast<SpaceNode *>(mSceneMgr->getOriginNode()->create())->attachObject(man);

    mCamera->setPos(NII::Vector3f(0,0,1000));

}
//----------------------------------------------------------------------------
//----------------------------------------------------------------------------
PlayPen_Projection::PlayPen_Projection()
{
    mInfo["Title"] = "PlayPen_Projection";
    mInfo["Description"] = "Tests projection.";
    addScreenshotFrame(10);
}
//----------------------------------------------------------------------------
void PlayPen_Projection::setupContent()
{
    SpaceNode* mTestNode[3];

    // Set ambient light
    mSceneMgr->setAmbient(Colour(0.5, 0.5, 0.5));

    // Create a point light
    Light* l = mSceneMgr->createLight("MainLight");
    l->setType(LT_DIRECTIONAL);
    l->setDirection(-Vector3::Y);

    GeometrySpace* pEnt;

    // Define a floor plane mesh
    Plane p;
    p.normal = Vector3::Z;
    p.d = 200;
    MeshManager::getSingleton().createPlane("WallPlane",
    TRANSIENT_RESOURCE_GROUP,
    p,1500,1500,1,1,true,1,5,5,Vector3::Y);
    pEnt = mSceneMgr->createGeo( "5", "WallPlane" );
    pEnt->setMaterial("Examples/OgreLogo");
    static_cast<SpaceNode *>(mSceneMgr->getOriginNode()->create())->attachObject(pEnt);


    mTestNode[0] = mSceneMgr->getOriginNode()->create();

    //pEnt = mSceneMgr->createGeo( "2", "ogrehead.mesh" );
    //mTestNode[0]->attachObject( pEnt );
    mTestNode[0]->translate(Vector3f(0, 0, 750));

    Ogre::Frustum * frustum = new Frustum();
    frustum->setVisible(true);
    frustum->setFarClipDistance(5000);
    frustum->setNearClipDistance(200);
    frustum->setAspectRatio(1);
    frustum->setProjType(Frustum::T_Orthogonal);
    mTestNode[0]->attachObject(frustum);

    // Hook the frustum up to the material
    MaterialPtr mat = MaterialManager::getSingleton().getByName("Examples/OgreLogo");
    ShaderChTextureUnit * t = mat->get(0)->get(0)->getTexture().get(0);
    t->setProjTexture(true);
    t->setProjFrustum(frustum);
}
//----------------------------------------------------------------------------
//----------------------------------------------------------------------------
PlayPen_RaySpaceQuery::PlayPen_RaySpaceQuery()
{
    mInfo["Title"] = "PlayPen_RaySpaceQuery";
    mInfo["Description"] = "Tests ray scene query.";
    addScreenshotFrame(10);
}
//----------------------------------------------------------------------------
bool PlayPen_RaySpaceQuery::onPreRender(const RenderFrameArgs * evt)
{
    rayQuery->setRay(mCamera->getRay(0.5, 0.5));
    RaySpaceQueryResult & results = rayQuery->execute();
    for(RaySpaceQueryResult::iterator mov = results.begin(); mov != results.end(); ++mov)
    {
        if (mov->movable)
        {
            if (mov->movable->getFactoryID() == N_FACTORY_GEOSPACE)
            {
                GeometrySpace* ent = static_cast<GeometrySpace*>(mov->movable);
                ent->setMaterial("Examples/RustySteel");
            }
        }
    }
    return true;
}
//----------------------------------------------------------------------------
void PlayPen_RaySpaceQuery::setupContent()
{
    mCamera->setPos(NII::Vector3f(0,0,500));
    mCamera->lookAt(Ogre::Vector3f(0,0,0));

    // Set ambient light
    mSceneMgr->setAmbient(Colour(0.5, 0.5, 0.5));

    // Create a point light
    Light* l = mSceneMgr->createLight("MainLight");
    l->setType(LT_DIRECTIONAL);
    l->setDirection(-Vector3::Y);

    // Create a set of random balls
    GeometrySpace* ent = mSceneMgr->createGeo("Ball", "sphere.mesh");
    static_cast<SpaceNode *>(mSceneMgr->getOriginNode()->create())->attachObject(ent);
    createRandomEntityClones(ent, 100, Vector3(-1000,-1000,-1000), Vector3(1000,1000,1000), mSceneMgr);

    // stick one at the origin so one will always be hit
    static_cast<SpaceNode *>(mSceneMgr->getOriginNode()->create())
        ->attachObject(mSceneMgr->createGeo("Ball_origin", "sphere.mesh"));

    rayQuery = mSceneMgr->createRayQuery(mCamera->getRay(0.5, 0.5));
    rayQuery->setSortDistance(true);
    rayQuery->setMaxResult(1);
    bool val = true;
    mSceneMgr->setProperty("ShowOctree", &val);

    //mCamera->setFarClipDistance(0);
}
//----------------------------------------------------------------------------
//----------------------------------------------------------------------------
PlayPen_ReflectedBillboards::PlayPen_ReflectedBillboards()
{
    mInfo["Title"] = "PlayPen_ReflectedBillboards";
    mInfo["Description"] = "Tests reflected billboards.";
    addScreenshotFrame(175); // needs to run for a bit so there are particles to be reflected...
}
//----------------------------------------------------------------------------
void PlayPen_ReflectedBillboards::setupContent()
{
    Camera * reflectCam = 0;
    // Set ambient light
    mSceneMgr->setAmbient(Colour(0.2, 0.2, 0.2));

    // Create a light
    Light * l = mSceneMgr->createLight("MainLight");
    l->setType(LT_DIRECTIONAL);
    Vector3 dir(0.5, -1, 0);
    dir.normalise();
    l->setDirection(dir);
    l->setDiffuse(1.0f, 1.0f, 0.8f);
    l->setSpecular(1.0f, 1.0f, 1.0f);
    // Create a prefab plane
    Plane plane;
    plane.d = 0;
    plane.normal = Vector3::Y;
    MeshManager::getSingleton().createPlane("ReflectionPlane",
    TRANSIENT_RESOURCE_GROUP,
    plane, 2000, 2000,
    1, 1, true, 1, 1, 1, Vector3::Z);
    GeometrySpace * planeEnt = mSceneMgr->createGeo( "Plane", "ReflectionPlane" );

    // Attach the rtt entity to the root of the scene
    SpaceNode * rootNode = mSceneMgr->getOriginNode();
    SpaceNode * planeNode = rootNode->create();

    // Attach both the plane entity, and the plane definition
    planeNode->attachObject(planeEnt);

    mCamera->setPos(NII::Vector3f(-50, 100, 500));
    mCamera->lookAt(Ogre::Vector3f(0,0,0));

    TexturePtr rttTex = N_Only(TextureManager).createTexture( "RttTex",
        TRANSIENT_RESOURCE_GROUP, TEX_TYPE_2D,
            512, 512, 1, 0, PF_R8G8B8, Texture::MM_FRAME_RGB);
    {
        reflectCam = mSceneMgr->createCamera("ReflectCam");
        reflectCam->setNearClipDistance(mCamera->getNearClipDistance());
        reflectCam->setFarClipDistance(mCamera->getFarClipDistance());
        reflectCam->setAspectRatio(
        (NIIf)mWindow->getViewport(0)->getPixelWidth() /
        (NIIf)mWindow->getViewport(0)->getPixelHeight());

        reflectCam->setPos(mCamera->getPos());
        reflectCam->setOri(mCamera->getOri());

        Viewport *v = rttTex->getBuffer()->getBuffer()->createViewport(reflectCam);
        v->setAutoClear(true);
        v->setBgColour(Colour::Black);

        MaterialPtr mat = MaterialManager::getSingleton().create("RttMat",
        TRANSIENT_RESOURCE_GROUP);
        ShaderChTextureUnit * t = mat->get(0)->get(0)->getTexture().create("RustedMetal.jpg");
        t = mat->get(0)->get(0)->getTexture().create("RttTex");
        // Blend with base texture
        t->getColourBlend()->setBlend(TBS_TEXTURE, TBS_PRE_TEXTURE, 0.25);
        t->setUAddressing(TAM_CLAMP);
        t->setVAddressing(TAM_CLAMP);
        t->setWAddressing(TAM_CLAMP);
        t->setProjTexture(true);
        t->setProjFrustum(reflectCam);
        // set up linked reflection
        reflectCam->setReflection(true, plane);
        // Also clip
        reflectCam->setCustomNearClip(true, plane);
    }

    // Give the plane a texture
    planeEnt->setMaterial("RttMat");

    // point billboards
    ParticleSpace * pSys2 = mSceneMgr->createParticleSpace("fountain1", "Examples/Smoke");
    // Point the fountain at an angle
    SpaceNode * fNode = static_cast<SpaceNode*>(rootNode->create());
    fNode->attachObject(pSys2);

    // oriented_self billboards
    ParticleSpace * pSys3 = mSceneMgr->createParticleSpace("fountain2",
    "Examples/PurpleFountain");
    // Point the fountain at an angle
    fNode = rootNode->create();
    fNode->translate(Vector3f(-200, -100, 0));
    fNode->rotate(Vector3::Z, Angle(-20));
    fNode->attachObject(pSys3);

    // oriented_common billboards
    ParticleSpace * pSys4 = mSceneMgr->createParticleSpace("rain", "Examples/Rain");
    SpaceNode * rNode = mSceneMgr->getOriginNode()->create();
    rNode->translate(Vector3f(0, 1000, 0));
    rNode->attachObject(pSys4);
    // Fast-forward the rain so it looks more natural
    pSys4->_forward(5);
}
//----------------------------------------------------------------------------
//----------------------------------------------------------------------------

PlayPen_ReinitialiseEntityAlteredMesh::PlayPen_ReinitialiseEntityAlteredMesh()
{
    mInfo["Title"] = "PlayPen_ReinitialiseEntityAlteredMesh";
    mInfo["Description"] = "Tests updating an entity while rendering.";
    addScreenshotFrame(100);
    mTimer = 0.5f;
}
//----------------------------------------------------------------------------
bool PlayPen_ReinitialiseEntityAlteredMesh::onPreRender(const RenderFrameArgs * evt)
{
    if(mTimer > 0.f)
    {
        mTimer -= evt->mCurrent;
        if(mTimer <= 0.f)
        {
            // change the mesh, add a new submesh

            // Load another mesh
            MeshPtr msh = MeshManager::getSingleton().load("ogrehead.mesh", GroupDefault);
            for(unsigned short e = 0; e < msh->getSubCount(); ++e)
            {
                SubMesh * sm = msh->getSub(e);
                SubMesh * newsm = mUpdate->createSub();
                newsm->setSelfVertex(true);
                newsm->setGeometryType(sm->getGeometryType());
                newsm->setVertexData(sm->getVertexData()->clone());
                newsm->setIndexData(0, sm->getIndexData(0)->clone());
            }
            mTimer = -5.f;
        }
    }
    return true;
}
//----------------------------------------------------------------------------
void PlayPen_ReinitialiseEntityAlteredMesh::setupContent()
{
    // test whether an GeometrySpace picks up that Mesh has changed
    // and therefore rebuild SubEntities

    mSceneMgr->setAmbient(Colour(0.5, 0.5, 0.5));

    Light* l = mSceneMgr->createLight("l1");
    l->setPos(Vecotr3f(200, 300, 0));

    NII::N_Only(Mesh).load("knot.mesh", GroupDefault)->clone("knot_REINIT.mesh");

    GeometrySpace* pEnt = mSceneMgr->createGeo("testEnt", "knot_REINIT.mesh");
    mUpdate = pEnt->getMesh().get();

    mSceneMgr->getOriginNode()->attachObject(pEnt);

    mCamera->setPos(NII::Vector3f(0,0,200));
}
//----------------------------------------------------------------------------
//----------------------------------------------------------------------------

PlayPen_ReloadResources::PlayPen_ReloadResources()
{
    mInfo["Title"] = "PlayPen_ReloadResources";
    mInfo["Description"] = "Tests unloading and reloading resources.";
    addScreenshotFrame(100);
    mReloadTimer = 0.5f;
}
//----------------------------------------------------------------------------

bool PlayPen_ReloadResources::onPreRender(const RenderFrameArgs * evt)
{
    if(mReloadTimer > 0.f)
    {
        mReloadTimer -= evt->mCurrent;

        if(mReloadTimer <= 0.f)
        {
            // unload
            GeometrySpace* e = mSceneMgr->getGeo("1");
            e->getSceneNode()->detach("1");
            mSceneMgr->destroyAllGeo();
            ResourceSchemeManager::getSingleton().unloadResourceGroup("TestReload");

            // reload
            e = mSceneMgr->createGeo("1", "UniqueModel.MESH");
            static_cast<SpaceNode *>(mSceneMgr->getOriginNode()->create())->attachObject(e);

            mReloadTimer = -5.f;
        }
    }
    return true;
}
//----------------------------------------------------------------------------

void PlayPen_ReloadResources::setupContent()
{
    mSceneMgr->setAmbient(Colour::White);

    // get path to test resources
    VFS * vfs = N_Only(ResourceScheme).getVFS("", "Tests");
    Ogre::String testResourcePath = vfs->getName();

    // add a new group
    Ogre::String meshFilePath = testResourcePath + "/TestReload";
    Ogre::ResourceSchemeManager& resMgr = Ogre::ResourceSchemeManager::getSingleton();
    String newGroup = meshFilePath;
    resMgr.create("TestReload", false);
    resMgr.add(meshFilePath, "FileSystem", "TestReload");
    resMgr.setup("TestReload");

    MeshManager& mmgr = MeshManager::getSingleton();
    mmgr.load("UniqueModel.MESH", "TestReload");

    GeometrySpace* e = mSceneMgr->createGeo("1", "UniqueModel.MESH");
    static_cast<SpaceNode *>(mSceneMgr->getOriginNode()->create())->attachObject(e);

    mCamera->setPos(NII::Vector3f(0, 0, 200));
}
//----------------------------------------------------------------------------
//----------------------------------------------------------------------------

PlayPen_PixelOrbit::PlayPen_PixelOrbit()
{
    mInfo["Title"] = "PlayPen_PixelOrbit";
    mInfo["Description"] = "Tests ribbon trail effect.";
    addScreenshotFrame(150);
}
//----------------------------------------------------------------------------

void PlayPen_PixelOrbit::setupContent()
{
    mSceneMgr->setAmbient(Colour(0.5, 0.5, 0.5));
    Vector3 dir(-1, -1, 0.5);
    dir.normalise();
    Light* l = mSceneMgr->createLight("light1");
    l->setType(LT_DIRECTIONAL);
    l->setDirection(dir);

    PropertyData pairList;
    pairList["numberOfChains"] = "2";
    pairList["maxElements"] = "80";
    PixelOrbit* trail = static_cast<PixelOrbit*>(
    mSceneMgr->createSpace(1, N_FACTORY_PIXELORBIT, &pairList));
    trail->setMaterial("Examples/LightPixelOrbit");
    trail->setOrbitLength(400);
    //mPixelOrbit = trail;


    static_cast<SpaceNode *>(mSceneMgr->getOriginNode()->create())->attachObject(trail);

    // Create 3 nodes for trail to follow
    SpaceNode* animNode = mSceneMgr->getOriginNode()->create();
    animNode->setPos(Vecotr3f(0, 20, 0));
    Animation* anim = mSceneMgr->createAnimation("an1", 10);
    anim->setInterpolationMode(NodeFusion::M_SPLINE);
    NodeKeyFrameTrack * track = N_new NodeKeyFrameTrack(anim, 1);
    track->setAssociatedNode(animNode);
    NodeKeyFrame* kf = static_cast<NodeKeyFrame *>(track->create(0));
    kf->setTranslate(Vector3::ZERO);
    kf = static_cast<NodeKeyFrame *>(track->create(2));
    kf->setTranslate(Vector3(100, 0, 0));
    kf = static_cast<NodeKeyFrame *>(track->create(4));
    kf->setTranslate(Vector3(200, 0, 300));
    kf = static_cast<NodeKeyFrame *>(track->create(6));
    kf->setTranslate(Vector3(0, 20, 500));
    kf = static_cast<NodeKeyFrame *>(track->create(8));
    kf->setTranslate(Vector3(-100, 10, 100));
    kf = static_cast<NodeKeyFrame *>(track->create(10));
    kf->setTranslate(Vector3::ZERO);
    track->buildSpline();
    //testremoveNode = animNode;

    AnimationFusion* animState = mSceneMgr->createFusion("an1");
    animState->setEnabled(true);
    mAnimStateList.push_back(animState);

    trail->attachNode(animNode);
    trail->setColour(0, 1.0, 0.8, 0);
    trail->setColourFade(0, 0.5, 0.5, 0.5, 0.5);
    trail->setDim(0, 5);

    // Add light
    Light* l2 = mSceneMgr->createLight("l2");
    l2->setDiffuse(trail->getColour(0));
    animNode->attachObject(l2);

    // Add billboard
    ParticleCtrl* bbs = mSceneMgr->createParticleCtrl("bb", 1);
    bbs->create(Vector3::ZERO, trail->getColour(0));
    bbs->setMaterial("Examples/Flare");
    animNode->attachObject(bbs);

    animNode = mSceneMgr->getOriginNode()->create();
    animNode->setPos(Vecotr3f(-50, 10, 0));
    anim = mSceneMgr->createAnimation("an2", 10);
    anim->setInterpolationMode(NodeFusion::M_SPLINE);
    NodeKeyFrameTrack * track = N_new NodeKeyFrameTrack(anim, 1);
    track->setAssociatedNode(animNode);
    kf = static_cast<NodeKeyFrame *>(track->create(0));
    kf->setTranslate(Vector3::ZERO);
    kf = static_cast<NodeKeyFrame *>(track->create(2));
    kf->setTranslate(Vector3(-100, 150, -30));
    kf = static_cast<NodeKeyFrame *>(track->create(4));
    kf->setTranslate(Vector3(-200, 0, 40));
    kf = static_cast<NodeKeyFrame *>(track->create(6));
    kf->setTranslate(Vector3(0, -150, 70));
    kf = static_cast<NodeKeyFrame *>(track->create(8));
    kf->setTranslate(Vector3(50, 0, 30));
    kf = static_cast<NodeKeyFrame *>(track->create(10));
    kf->setTranslate(Vector3::ZERO);
    track->buildSpline();
    animState = mSceneMgr->createFusion("an2");
    animState->setEnabled(true);
    mAnimStateList.push_back(animState);

    trail->attachNode(animNode);
    trail->setColour(1, 0.0, 1.0, 0.4);
    trail->setColourFade(1, 0.5, 0.5, 0.5, 0.5);
    trail->setDim(1, 5);


    // Add light
    l2 = mSceneMgr->createLight("l3");
    l2->setDiffuse(trail->getColour(1));
    animNode->attachObject(l2);

    // Add billboard
    bbs = mSceneMgr->createParticleCtrl("bb2", 1);
    bbs->create(Vector3::ZERO, trail->getColour(1));
    bbs->setMaterial("Examples/Flare");
    animNode->attachObject(bbs);
    mCamera->setPos(NII::Vector3f(0,0,500));
    //mSceneMgr->setAABBView(true);
}
//----------------------------------------------------------------------------
//----------------------------------------------------------------------------

PlayPen_SerialisedColour::PlayPen_SerialisedColour()
{
    mInfo["Title"] = "PlayPen_SerialisedColour";
    mInfo["Description"] = "Tests serializing mesh color.";
    addScreenshotFrame(10);
}
//----------------------------------------------------------------------------

void PlayPen_SerialisedColour::setupContent()
{
    mSceneMgr->setAmbient(Colour(0.5, 0.5, 0.5));
    Vector3 dir(-1, -1, 0.5);
    dir.normalise();
    Light* l = mSceneMgr->createLight("light1");
    l->setType(LT_DIRECTIONAL);
    l->setDirection(dir);

    Plane plane;
    plane.normal = Vector3::Y;
    plane.d = 100;
    MeshManager::getSingleton().createPlane("Myplane",
    TRANSIENT_RESOURCE_GROUP, plane,
    1500,1500,10,10,true,1,5,5,Vector3::Z);
    GeometrySpace* pPlaneEnt = mSceneMgr->createGeo( "plane", "Myplane" );
    pPlaneEnt->setMaterial("2 - Default");
    pPlaneEnt->setCastShadow(false);
    static_cast<SpaceNode *>(mSceneMgr->getOriginNode()->create())->attachObject(pPlaneEnt);


    CustomSpaceObj* man = static_cast<CustomSpaceObj*>(
    mSceneMgr->createSpace("test", N_FACTORY_CUSTOMSPACE));

    man->begin(GeometryRaw::OT_TRIANGLE_LIST, MaterialManager::WhiteColour->getOriginID());
    // Define a 40x40 plane, non-indexed
    // Define a 40x40 plane, indexed
    man->position(-20, 20, 20);
    man->colour(1, 0, 0);

    man->position(-20, -20, 20);
    man->colour(1, 0, 0);

    man->position(20, -20, 20);
    man->colour(1, 0, 0);

    man->position(20, 20, 20);
    man->colour(1, 0, 0);

    man->quad(0, 1, 2, 3);
    man->end();

    Mesh * mesh = man->createMesh("colourtest.mesh");
    mesh->ref(false);
    MeshSerializer ms;
    ms.exportMesh(mesh.getPointer(), "colourtest.mesh");

    static_cast<SpaceNode *>(mSceneMgr->getOriginNode()->create())->attachObject(man);

    GeometrySpace* c = mSceneMgr->createGeo("1", "colourtest.mesh");
    static_cast<SpaceNode *>(mSceneMgr->getOriginNode()->create())->attachObject(c);

    mCamera->setPos(NII::Vector3f(0,0,120));

}
//----------------------------------------------------------------------------
//----------------------------------------------------------------------------

PlayPen_ShadowLod::PlayPen_ShadowLod()
{
    mInfo["Title"] = "PlayPen_ShadowLod";
    mInfo["Description"] = "Tests whether LOD is based on shadow cam or main cam.";
    addScreenshotFrame(10);
}
//----------------------------------------------------------------------------

void PlayPen_ShadowLod::cleanupContent()
{
    clearDebugTextureOverlays();
}
//----------------------------------------------------------------------------

void PlayPen_ShadowLod::setupContent()
{
    SpaceNode* mTestNode[10];

    // Test that LOD is based on main camera, not shadow camera

    mSceneMgr->getRenderPattern()->setTextureDim(1024);
    mSceneMgr->setShadowTechnique(SHADOWTYPE_TEXTURE_MODULATIVE);

    //FocusedShadowSetup * lispsmSetup = N_new FocusedShadowSetup();
    //LiSPSMShadowSetup * lispsmSetup = N_new LiSPSMShadowSetup();
    //lispsmSetup->setOptimalAdjustFactor(1.5);
    //mSceneMgr->setShadowGenCamera(lispsmSetup);

    mSceneMgr->setShadowColour(Colour(0.35, 0.35, 0.35));
    // Set ambient light
    mSceneMgr->setAmbient(Colour(0.3, 0.3, 0.3));

    Light* mLight = mSceneMgr->createLight("MainLight");

    // Directional test
    if (false)
    {
        mLight->setType(LT_DIRECTIONAL);
        Vector3 vec(-1,-1,0);
        vec.normalise();
        mLight->setDirection(vec);
    }
    // Spotlight test
    else
    {
        mLight->setType(LT_SPOT);
        mLight->setRange(10000);
        mLight->setAttenuationConstant(1);
        mLight->setAttenuationLinear(0);
        mLight->setAttenuationQuadric(0);
        mLight->setDiffuse(1.0, 1.0, 0.8);
        mTestNode[0] = mSceneMgr->getOriginNode()->create();
        mTestNode[0]->setPos(Vecotr3f(400, 300, 0));
        mTestNode[0]->lookAt(Vector3(0,0,0), PosNode::SM_Space, Vector3::Z);
        mTestNode[0]->attachObject(mLight);
    }

    mTestNode[1] = mSceneMgr->getOriginNode()->create();


    GeometrySpace* pEnt;
    pEnt = mSceneMgr->createGeo( "1", "knot.mesh" );
    // rendering distance should also be based on main cam
    //pEnt->setVisibleDistanceLimit(100);
    //pEnt->setMaterial("2 - Default");
    mTestNode[1]->attachObject( pEnt );
    //mTestNode[1]->translate(Vector3f(0, -100, 0));
    /*
    pEnt = mSceneMgr->createGeo( "3", "knot.mesh" );
    mTestNode[2] = mSceneMgr->getOriginNode()->create(Vector3(-200, 0, -200));
    mTestNode[2]->attachObject( pEnt );


    createRandomEntityClones(pEnt, 20, Vector3(-1000,0,-1000), Vector3(1000,0,1000));


    // Transparent object (can force cast shadows)
    pEnt = mSceneMgr->createGeo( "3.5", "knot.mesh" );
    MaterialPtr tmat = MaterialManager::getSingleton().create("TestAlphaTransparency",
    TRANSIENT_RESOURCE_GROUP);
    tmat->setAlphaShadowCast(true);
    Pass * tpass = tmat->get(0)->get(0);
    tpass->setColour(ShaderCh::SOT_Set)->setAlphaReject(CM_GREATER);
    tpass->setColour(ShaderCh::SOT_Set)->setValue(150);
    tpass->setColour(ShaderCh::SOT_Set)->setAlphaCoverage(false);
    tpass->setBlend(ShaderCh::SOT_Set)->setBlend(FBM_INV_ALPHA);
    tpass->getTexture().create("gras_02.png");
    tpass->setCullingMode(CM_None);

    pEnt->setMaterial("TestAlphaTransparency");
    mTestNode[3] = mSceneMgr->getOriginNode()->create(Vector3(350, 0, -200));
    mTestNode[3]->attachObject( pEnt );

    MeshPtr msh = MeshManager::getSingleton().load("knot.mesh", TRANSIENT_RESOURCE_GROUP);
    msh->buildTangentBuffer(VT_Tangent);
    pEnt = mSceneMgr->createGeo( "4", "knot.mesh" );
    //pEnt->setMaterial("Examples/BumpMapping/MultiLightSpecular");
    mTestNode[2] = mSceneMgr->getOriginNode()->create(Vector3(100, 0, 200));
    mTestNode[2]->attachObject( pEnt );
    BoxSky * mBoxSky = N_new BoxSky(mSceneMgr);
    mBoxSky->setMaterial();
    mBoxSky->setRenderGroup(RQG_Sky);
    mSceneMgr->setSkyBox(true, "Examples/CloudyNoonSkyBox");
    */

    MovablePlane movablePlane(Vector3::Y, 100);
    MeshManager::getSingleton().createPlane("Myplane",
    TRANSIENT_RESOURCE_GROUP, movablePlane,
    2500,2500,10,10,true,1,5,5,Vector3::Z);
    GeometrySpace* pPlaneEnt;
    pPlaneEnt = mSceneMgr->createGeo( "plane", "Myplane" );
    if (SHADOWTYPE_TEXTURE_MODULATIVE & SHADOWDETAILTYPE_INTEGRATED)
    {
        pPlaneEnt->setMaterial("Examples/Plane/IntegratedShadows");
    }
    else
    {
        pPlaneEnt->setMaterial("2 - Default");
    }
    pPlaneEnt->setCastShadow(false);
    static_cast<SpaceNode *>(mSceneMgr->getOriginNode()->create())->attachObject(pPlaneEnt);

    addTextureShadowDebugOverlay(1, mSceneMgr);


    /*
    ParticleSpace* pSys2 = mSceneMgr->createParticleSpace("smoke",
    "Examples/Smoke");
    mTestNode[4] = mSceneMgr->getOriginNode()->create(Vector3(-300, -100, 200));
    mTestNode[4]->attachObject(pSys2);
    */

    mCamera->setPos(NII::Vector3f(0, 1000, 500));
    mCamera->lookAt(Ogre::Vector3f(0,0,0));
    mCamera->setFarClipDistance(10000);

}
//----------------------------------------------------------------------------
//----------------------------------------------------------------------------

PlayPen_SkeletalAnimation::PlayPen_SkeletalAnimation()
{
    mInfo["Title"] = "PlayPen_SkeletalAnimation";
    mInfo["Description"] = "Tests skeletal animation.";
    addScreenshotFrame(100);
}
//----------------------------------------------------------------------------

void PlayPen_SkeletalAnimation::setupContent()
{
    // Set ambient light
    mSceneMgr->setAmbient(Colour(0.5, 0.5, 0.5));
    //mWindow->getViewport(0)->setBgColour(Colour::White);



    GeometrySpace *ent = mSceneMgr->createGeo("robot", "robot.mesh");
    //ent->setBoneView(true);
    // Uncomment the below to test software skinning
    ent->setMaterial("Examples/Rocky");
    // Add entity to the scene node
    static_cast<SpaceNode *>(mSceneMgr->getOriginNode()->create())->attachObject(ent);
    Ogre::AnimationFusion* mAnimState = ent->getFusion("Walk");
    mAnimState->setEnabled(true);

    // Give it a little ambience with lights
    Light* l;
    l = mSceneMgr->createLight("BlueLight");
    l->setPos(Vecotr3f(-200,-80,-100));
    l->setDiffuse(0.5, 0.5, 1.0);

    l = mSceneMgr->createLight("GreenLight");
    l->setPos(Vecotr3f(0,0,-100));
    l->setDiffuse(0.5, 1.0, 0.5);

    // Position the camera
    mCamera->setPos(NII::Vector3f(200,50,0));
    mCamera->lookAt(Ogre::Vector3f(0,50,0));

    mAnimStateList.push_back(mAnimState);
}
//----------------------------------------------------------------------------
//----------------------------------------------------------------------------

PlayPen_SkeletonAnimationOptimise::PlayPen_SkeletonAnimationOptimise()
{
    mInfo["Title"] = "PlayPen_SkeletonAnimationOptimise";
    mInfo["Description"] = "Tests skeletal animation with hardware and software.";
    addScreenshotFrame(100);
}
//----------------------------------------------------------------------------

void PlayPen_SkeletonAnimationOptimise::setupContent()
{
    SpaceNode* mTestNode[5];
    mSceneMgr->getRenderPattern()->setTextureDim(512);
    mSceneMgr->setShadowTechnique(SHADOWTYPE_STENCIL_ADDITIVE);
    mSceneMgr->getRenderPattern()->setMaxExtent(1500);
    mSceneMgr->setShadowColour(Colour(0.35, 0.35, 0.35));
    //mSceneMgr->getRenderPattern()->setMaxExtent(800);
    // Set ambient light
    mSceneMgr->setAmbient(Colour(0.3, 0.3, 0.3));

    Light* mLight = mSceneMgr->createLight("MainLight");

    /*/
    // Directional test
    mLight->setType(LT_DIRECTIONAL);
    Vector3 vec(-1,-1,0);
    vec.normalise();
    mLight->setDirection(vec);
    /*/
    // Point test
    mLight->setType(LT_POINT);
    mLight->setPos(Vecotr3f(0, 200, 0));
    //*/

    GeometrySpace* pEnt;

    // Hardware animation
    pEnt = mSceneMgr->createGeo( "1", "robot.mesh" );
    AnimationFusion* a = pEnt->getFusion("Walk");
    a->setEnabled(true);
    mAnimStateList.push_back(a);
    mTestNode[0] = mSceneMgr->getOriginNode()->create();
    mTestNode[0]->attachObject( pEnt );
    mTestNode[0]->translate(Vector3f(100,-100,0));

    // Software animation
    pEnt = mSceneMgr->createGeo( "2", "robot.mesh" );
    pEnt->setMaterial("BaseWhite");
    a = pEnt->getFusion("Walk");
    a->setEnabled(true);
    mAnimStateList.push_back(a);

    mTestNode[1] = mSceneMgr->getOriginNode()->create();
    mTestNode[1]->attachObject( pEnt );
    mTestNode[1]->translate(Vector3f(-100, -100, 0));


    Plane plane;
    plane.normal = Vector3::Y;
    plane.d = 100;
    MeshManager::getSingleton().createPlane("Myplane",
    TRANSIENT_RESOURCE_GROUP, plane,
    1500,1500,10,10,true,1,5,5,Vector3::Z);
    GeometrySpace* pPlaneEnt;
    pPlaneEnt = mSceneMgr->createGeo( "plane", "Myplane" );
    pPlaneEnt->setMaterial("2 - Default");
    pPlaneEnt->setCastShadow(false);
    static_cast<SpaceNode *>(mSceneMgr->getOriginNode()->create())->attachObject(pPlaneEnt);

    mCamera->setPos(NII::Vector3f(0,0,300));
}
//----------------------------------------------------------------------------
//----------------------------------------------------------------------------

PlayPen_SpotlightViewProj::PlayPen_SpotlightViewProj()
{
    mInfo["Title"] = "PlayPen_SpotlightViewProj";
    mInfo["Description"] = "Tests spotlight camera projection.";
    addScreenshotFrame(10);
}
//----------------------------------------------------------------------------

void PlayPen_SpotlightViewProj::setupContent()
{
    SpaceNode* mTestNode[10];
    bool worldViewProj = true;
    // Define programs that use spotlight projection

    String vpStr;
    vpStr =
    "void vp(float4 position : POSITION,\n"
    "out float4 oPosition : POSITION,\n"
    "out float4 oUV : TEXCOORD0,\n";
    if (!worldViewProj)
    {
        vpStr += "uniform float4x4 world,\n"
        "uniform float4x4 spotlightViewProj,\n";
    }
    else
    {
        vpStr += "uniform float4x4 spotlightWorldViewProj,\n";
    }
    vpStr += "uniform float4x4 worldViewProj)\n"
    "{\n"
    "    oPosition = mul(worldViewProj, position);\n";
    if (worldViewProj)
    {
        vpStr += "    oUV = mul(spotlightWorldViewProj, position);\n";
    }
    else
    {
        vpStr += "    float4 worldPos = mul(world, position);\n"
        "    oUV = mul(spotlightViewProj, worldPos);\n";
    }
    vpStr += "}\n";

    String fpStr =
    "void fp(\n"
    "float4 uv : TEXCOORD0,\n"
    "uniform sampler2D tex : register(s0),\n"
    "out float4 oColor : COLOR)\n"
    "{\n"
    "   uv = uv / uv.w;\n"
    "    oColor = tex2D(tex, uv.xy);\n"
    "}\n";

    HighLevelGpuProgramPtr vp = HighLevelGpuProgramManager::getSingleton()
        .createProgram("testvp", TRANSIENT_RESOURCE_GROUP, "cg", GPT_VERTEX_PROGRAM);
    vp->setProgramCode(vpStr);
    vp->set("profiles", "vs_1_1 arbvp1");
    vp->set("entry_point", "vp");
    vp->load();

    HighLevelGpuProgramPtr fp = HighLevelGpuProgramManager::getSingleton()
        .createProgram("testfp", TRANSIENT_RESOURCE_GROUP, "cg", GPT_FRAGMENT_PROGRAM);
    fp->setProgramCode(fpStr);
    fp->set("profiles", "ps_2_0 arbfp1");
    fp->set("entry_point", "fp");
    fp->load();

    MaterialPtr mat = MaterialManager::getSingleton().create("TestSpotlightProj",
        TRANSIENT_RESOURCE_GROUP);
    Pass * p = mat->get(0)->get(0);
    p->getProgram().set(ST_VS, 0, "testvp");
    GpuProgramParam * param;
    p->getProgram().get(0, ST_VS, NULL, param);
    param->set("worldViewProj", GpuProgramParam::GSP_Matrix_Proj_X_View_X_Space);

    if(worldViewProj)
    {
        param->set(
            "spotlightWorldViewProj", GpuProgramParam::GSP_Light_Spot_Matrix_Proj_X_View_X_Space);
    }
    else
    {
        param->set("world", GpuProgramParam::GSP_Matrix_Space);
        param->set("spotlightViewProj", GpuProgramParam::GSP_Light_Spot_Matrix_Proj_X_View_ParamIndex);
    }
    p->getProgram().set(ST_FS, 0, "testfp");
    p->getTexture().create("ogrelogo.png");

    GeometrySpace* pEnt;

    // Define a plane mesh, use the above material
    Plane plane;
    plane.normal = Vector3::Z;
    plane.d = 200;
    MeshManager::getSingleton().createPlane("WallPlane", TRANSIENT_RESOURCE_GROUP,
    plane,1500,1500,100,100,true,1,5,5,Vector3::Y);
    pEnt = mSceneMgr->createGeo( "5", "WallPlane" );
    pEnt->setMaterial(mat->getName());
    static_cast<SpaceNode *>(mSceneMgr->getOriginNode()->create())->attachObject(pEnt);


    mTestNode[0] = mSceneMgr->getOriginNode()->create();

    mTestNode[0]->translate(Vector3f(0, 0, 750));

    Light* spot = mSceneMgr->createLight("l1");
    spot->setType(LT_SPOT);
    spot->setDirection(Vector3::INV_Z);

    mTestNode[0]->attachObject(spot);


}
//----------------------------------------------------------------------------
//----------------------------------------------------------------------------

PlayPen_SRGBtexture::PlayPen_SRGBtexture()
{
    mInfo["Title"] = "PlayPen_SRGBtexture";
    mInfo["Description"] = "Tests sRGB textures.";
    addScreenshotFrame(10);
}
//----------------------------------------------------------------------------

void PlayPen_SRGBtexture::setupContent()
{
    // NOTE: enable flag only turns on SRGB for texture sampling, you may
    // need to configure the window for the reverse conversion for consistency!
    MaterialPtr mat = MaterialManager::getSingleton().create("testsrgb",
    TRANSIENT_RESOURCE_GROUP);
    Pass * p = mat->get(0)->get(0);
    p->setLight(false);
    p->setCullingMode(CM_None);
    ShaderChTextureUnit * t = p->getTexture().create("ogrelogo.png");
    t->setHardwareSRGB(true);
    GeometrySpace *e = mSceneMgr->createGeo("Plane", GSP_Plane);
    e->setMaterial(mat->getName());
    static_cast<SpaceNode *>(mSceneMgr->getOriginNode()->create())->attachObject(e);
    mWindow->getViewport(0)->setBgColour(Colour::Red);

    mCamera->setPos(NII::Vector3f(0,0,300));
    mCamera->lookAt(Vector3::ZERO);

}
//----------------------------------------------------------------------------
//----------------------------------------------------------------------------

PlayPen_StaticSpace::PlayPen_StaticSpace()
{
    mInfo["Title"] = "PlayPen_StaticSpace";
    mInfo["Description"] = "Tests static geometry.";
    addScreenshotFrame(10);
}
//----------------------------------------------------------------------------

void PlayPen_StaticSpace::setupContent()
{

    // Set ambient light
    mSceneMgr->setAmbient(Colour(0, 0, 0));

    // Create a point light
    Light* l = mSceneMgr->createLight("MainLight");
    l->setDiffuse(0.4, 0.4, 0.4);
    l->setSpecular(Colour::White);

    SpaceNode* animNode = mSceneMgr->getOriginNode()->create();
    Animation* anim = mSceneMgr->createAnimation("an1", 20);
    anim->setInterpolationMode(NodeFusion::M_SPLINE);
    NodeKeyFrameTrack * track = N_new NodeKeyFrameTrack(anim, 1);
    track->setAssociatedNode(animNode);
    NodeKeyFrame* kf = static_cast<NodeKeyFrame *>(track->create(0));
    kf->setTranslate(Vector3(2300, 600, 2300));
    kf = static_cast<NodeKeyFrame *>(track->create(5));
    kf->setTranslate(Vector3(-2300, 600, 2300));
    kf = static_cast<NodeKeyFrame *>(track->create(10));
    kf->setTranslate(Vector3(-2300, 600, -2300));
    kf = static_cast<NodeKeyFrame *>(track->create(15));
    kf->setTranslate(Vector3(2300, 600, -2300));
    kf = static_cast<NodeKeyFrame *>(track->create(20));
    kf->setTranslate(Vector3(2300, 600, 2300));
    track->buildSpline();
    //animNode->attachObject(l);
    l->setPos(Vecotr3f(0, 600, 0));
    l->setRange(10000);
    l->setAttenuationConstant(1);
    l->setAttenuationLinear(0);
    l->setAttenuationQuadric(0);

    AnimationFusion * animState = mSceneMgr->createFusion("an1");
    animState->setEnabled(true);
    mAnimStateList.push_back(animState);

    Plane plane;
    plane.normal = Vector3::Y;
    plane.d = 0;
    MeshManager::getSingleton().createPlane("Myplane",
    TRANSIENT_RESOURCE_GROUP, plane,
    4500,4500,10,10,true,1,5,5,Vector3::Z);
    GeometrySpace* pPlaneEnt = mSceneMgr->createGeo( "plane", "Myplane" );
    pPlaneEnt->setMaterial("Examples/GrassFloor");
    pPlaneEnt->setCastShadow(false);
    static_cast<SpaceNode *>(mSceneMgr->getOriginNode()->create())->attachObject(pPlaneEnt);
    Vector3 min(-2000,30,-2000);
    Vector3 max(2000,30,2000);

    MeshPtr msh = MeshManager::getSingleton().load("ogrehead.mesh", TRANSIENT_RESOURCE_GROUP);
    msh->buildTangentBuffer();

    GeometrySpace* e = mSceneMgr->createGeo("1", "ogrehead.mesh");
    e->setMaterial("Examples/BumpMapping/MultiLightSpecular");

    StaticSpace* s = mSceneMgr->createStaticSpace("bing");
    s->setCastShadow(true);
    s->setRegionDimensions(Vector3(500,500,500));
    for (int i = 0; i < 10; ++i)
    {
        Vector3 pos;
        pos.x = Math::random(min.x, max.x);
        pos.y = Math::random(min.y, max.y);
        pos.z = Math::random(min.z, max.z);

        s->addEntity(e, pos);
        GeometrySpace* e2 = e->clone("clone" + StrConv::conv(i));
        static_cast<SpaceNode *>(mSceneMgr->getOriginNode()->create(pos+Vector3(0,60,0)))->attachObject(e2);

    }

    s->build();
    mCamera->setLodBias(0.5);
    mCamera->setPos(NII::Vector3f(0, 400, 1200));
    mCamera->setDirection(NII::Vector3f(0, -0.3f, -1.2f));

    //mTestNode[0] = s->getRegionIterator().getAndNext()->getSceneNode();
}
//----------------------------------------------------------------------------
//----------------------------------------------------------------------------

PlayPen_StaticSpaceWithLOD::PlayPen_StaticSpaceWithLOD()
{
    mInfo["Title"] = "PlayPen_StaticSpaceWithLOD";
    mInfo["Description"] = "Tests static geometry with LODs.";
    addScreenshotFrame(10);
}
//----------------------------------------------------------------------------

void PlayPen_StaticSpaceWithLOD::setupContent()
{
    //if (stencilShadows)
    //{
    //    mSceneMgr->setShadowTechnique(SHADOWTYPE_STENCIL_MODULATIVE);
    //}
    // Set ambient light
    mSceneMgr->setAmbient(Colour(0, 0, 0));

    // Create a point light
    Light* l = mSceneMgr->createLight("MainLight");
    l->setDiffuse(0.4, 0.4, 0.4);
    l->setSpecular(Colour::White);

    SpaceNode* animNode = mSceneMgr->getOriginNode()->create();
    Animation* anim = mSceneMgr->createAnimation("an1", 20);
    anim->setInterpolationMode(NodeFusion::M_SPLINE);
    NodeKeyFrameTrack * track = N_new NodeKeyFrameTrack(anim, 1);
    track->setAssociatedNode(animNode);
    NodeKeyFrame * kf = static_cast<NodeKeyFrame *>(track->create(0));
    kf->setTranslate(Vector3(2300, 600, 2300));
    kf = static_cast<NodeKeyFrame *>(track->create(5));
    kf->setTranslate(Vector3(-2300, 600, 2300));
    kf = static_cast<NodeKeyFrame *>(track->create(10));
    kf->setTranslate(Vector3(-2300, 600, -2300));
    kf = static_cast<NodeKeyFrame *>(track->create(15));
    kf->setTranslate(Vector3(2300, 600, -2300));
    kf = static_cast<NodeKeyFrame *>(track->create(20));
    kf->setTranslate(Vector3(2300, 600, 2300));
    track->buildSpline();
    //animNode->attachObject(l);
    l->setPos(Vecotr3f(0, 600, 0));
    l->setRange(10000);
    l->setAttenuationConstant(1);
    l->setAttenuationLinear(0);
    l->setAttenuationQuadric(0);

    AnimationFusion* animState = mSceneMgr->createFusion("an1");
    animState->setEnabled(true);
    mAnimStateList.push_back(animState);



    Plane plane;
    plane.normal = Vector3::Y;
    plane.d = 0;
    MeshManager::getSingleton().createPlane("Myplane",
    TRANSIENT_RESOURCE_GROUP, plane,
    4500,4500,10,10,true,1,5,5,Vector3::Z);
    GeometrySpace* pPlaneEnt = mSceneMgr->createGeo( "plane", "Myplane" );
    pPlaneEnt->setMaterial("Examples/GrassFloor");
    pPlaneEnt->setCastShadow(false);
    static_cast<SpaceNode *>(mSceneMgr->getOriginNode()->create())->attachObject(pPlaneEnt);

    Vector3 min(-2000,30,-2000);
    Vector3 max(2000,30,2000);


    MeshPtr msh = MeshManager::getSingleton().load("knot.mesh", TRANSIENT_RESOURCE_GROUP);

    GeometrySpace* e = mSceneMgr->createGeo("1", msh->getName());

    StaticSpace* s = mSceneMgr->createStaticSpace("bing");
    s->setCastShadow(true);
    s->setRegionDimensions(Vector3(500,500,500));
    for (int i = 0; i < 10; ++i)
    {
        Vector3 pos;
        pos.x = Math::random(min.x, max.x);
        pos.y = Math::random(min.y, max.y);
        pos.z = Math::random(min.z, max.z);

        s->addEntity(e, pos);

    }

    s->build();
    mCamera->setLodBias(0.5);
    mCamera->setPos(NII::Vector3f(0, 400, 1200));
    mCamera->setDirection(NII::Vector3f(0, -0.3f, -1.2f));

    //mTestNode[0] = s->getRegionIterator().getAndNext()->getSceneNode();
}
//----------------------------------------------------------------------------
//----------------------------------------------------------------------------

// render queues
#define RENDER_QUEUE_OUTLINE_GLOW_OBJECTS    RQG_User + 1
#define RENDER_QUEUE_OUTLINE_GLOW_GLOWS        RQG_User + 2
#define RENDER_QUEUE_FULL_GLOW_ALPHA_GLOW    RQG_User + 3
#define RENDER_QUEUE_FULL_GLOW_GLOW            RQG_User + 4
#define LAST_STENCIL_OP_RENDER_QUEUE        RENDER_QUEUE_FULL_GLOW_GLOW

// stencil values
#define STENCIL_VALUE_FOR_OUTLINE_GLOW 1
#define STENCIL_VALUE_FOR_FULL_GLOW 2
#define STENCIL_FULL_MASK 0xFFFFFFFF

// a Render queue listener to change the stencil mode
class StencilOpQueueListener : public NII::RenderListener
{
public:
    virtual bool renderBegin(Ogre::GroupID queueGroupId)
    {
        if (queueGroupId == RENDER_QUEUE_OUTLINE_GLOW_OBJECTS) // outline glow object
        {
            Ogre::RenderSystem * rendersys = Ogre::Root::getSingleton().getRender();

            rendersys->clearBuffer(Ogre::FBT_STENCIL);
            rendersys->setStencilTest(true);
            rendersys->setStencil(false, STENCIL_FULL_MASK, STENCIL_FULL_MASK,
                Ogre::CM_ALWAYS_PASS, STENCIL_VALUE_FOR_OUTLINE_GLOW,
                Ogre::SOT_KEEP,Ogre::SOT_KEEP,Ogre::SOT_REPLACE);
        }
        if (queueGroupId == RENDER_QUEUE_OUTLINE_GLOW_GLOWS)  // outline glow
        {
            Ogre::RenderSystem * rendersys = Ogre::Root::getSingleton().getRender();
            rendersys->setStencilTest(true);
            rendersys->setStencil(false, STENCIL_FULL_MASK, STENCIL_FULL_MASK,
                Ogre::CM_NOT_EQUAL, STENCIL_VALUE_FOR_OUTLINE_GLOW,
                Ogre::SOT_KEEP,Ogre::SOT_KEEP,Ogre::SOT_REPLACE);
        }
        if (queueGroupId == RENDER_QUEUE_FULL_GLOW_ALPHA_GLOW)  // full glow - alpha glow
        {
            Ogre::RenderSystem * rendersys = Ogre::Root::getSingleton().getRender();
            rendersys->setStencilTest(true);
            rendersys->setStencil(false, STENCIL_FULL_MASK, STENCIL_FULL_MASK,
                Ogre::CM_ALWAYS_PASS, STENCIL_VALUE_FOR_FULL_GLOW,
                Ogre::SOT_KEEP,Ogre::SOT_KEEP,Ogre::SOT_REPLACE);
        }

        if (queueGroupId == RENDER_QUEUE_FULL_GLOW_GLOW)  // full glow - glow
        {
            Ogre::RenderSystem * rendersys = Ogre::Root::getSingleton().getRender();
            rendersys->setStencilTest(true);
            rendersys->setStencil(false, STENCIL_FULL_MASK, STENCIL_FULL_MASK,
                Ogre::CM_EQUAL, STENCIL_VALUE_FOR_FULL_GLOW,
                    Ogre::SOT_KEEP,Ogre::SOT_KEEP,Ogre::SOT_ZERO);
        }
        return true;

    }

    virtual void renderEnd(Ogre::GroupID queueGroupId)
    {
        if((queueGroupId == LAST_STENCIL_OP_RENDER_QUEUE))
        {
            Ogre::RenderSystem * rendersys = Ogre::Root::getSingleton().getRender();
            rendersys->setStencilTest(false);
            rendersys->setStencil();
        }
        return false;
    }

};
//---------------------------------------------------------------------------

PlayPen_StencilGlow::PlayPen_StencilGlow()
    :mStencilListener(0)
{
    mInfo["Title"] = "PlayPen_StencilGlow";
    mInfo["Description"] = "Tests stencil glow effect.";
    addScreenshotFrame(50);
}
//---------------------------------------------------------------------------

PlayPen_StencilGlow::~PlayPen_StencilGlow()
{
    if(mStencilListener)
        delete mStencilListener;
}
//---------------------------------------------------------------------------

void PlayPen_StencilGlow::setupContent(void)
{
    // test media
    Ogre::ResourceSchemeManager::getSingleton().setup("Tests");

    // Set ambient light
    mSceneMgr->setAmbient(Colour(0.5, 0.5, 0.5));

    // Create a point light
    Light* l = mSceneMgr->createLight("MainLight");
    // Accept default settings: point light, white diffuse, just set position
    // NB I could attach the light to a SpaceNode if I wanted it to move automatically with
    //  other objects, but I don't
    l->setPos(Vecotr3f(20, 80, 50));


    // outline glow entity
    GeometrySpace *outlineGlowEntity = mSceneMgr->createGeo("outlineGlow", "ogrehead.mesh");
    outlineGlowEntity->setRenderGroup(RENDER_QUEUE_OUTLINE_GLOW_OBJECTS);
    static_cast<SpaceNode *>(mSceneMgr->getOriginNode()->create())->attachObject(outlineGlowEntity);


    // outline glow entity actual glow
    Ogre::GeometrySpace* actualOutlineGlowEntity = outlineGlowEntity->clone(outlineGlowEntity->getName() + "_glow");
    actualOutlineGlowEntity->setRenderGroup(RENDER_QUEUE_OUTLINE_GLOW_GLOWS);
    actualOutlineGlowEntity->setMaterial("cg/glow");
    Ogre::SpaceNode* actualOutlineGlowNode = outlineGlowEntity->getSceneNode()->create("outlineGlowNode");
    actualOutlineGlowNode->attachObject(actualOutlineGlowEntity);


    // normal entity
    GeometrySpace *normalOgreEntity = mSceneMgr->createGeo("normalOgreEntity", "ogrehead.mesh");
    Ogre::SpaceNode* normalOgreNode = mSceneMgr->getOriginNode()->create();
    normalOgreNode->attachObject(normalOgreEntity);
    normalOgreNode->setPos(Vecotr3f(80, 0, 0));

    // full glow entity
    GeometrySpace *fullGlowEntity = mSceneMgr->createGeo("fullGlowEntity", "ogrehead.mesh");
    Ogre::SpaceNode* fullGlowNode = mSceneMgr->getOriginNode()->create();
    fullGlowNode->attachObject(fullGlowEntity);
    fullGlowNode->setPos(Vecotr3f(-80, 0, 0));

    // full glow alpha glow
    Ogre::GeometrySpace* alphaFullGlowEntity = fullGlowEntity->clone(fullGlowEntity->getName() + "_alphaGlow");
    alphaFullGlowEntity->setRenderGroup(RENDER_QUEUE_FULL_GLOW_ALPHA_GLOW);
    alphaFullGlowEntity->setMaterial("cg/alpha_glow");
    Ogre::SpaceNode* alphaFullGlowNode = fullGlowEntity->getSceneNode()->create("fullGlowAlphaNode");
    alphaFullGlowNode->attachObject(alphaFullGlowEntity);

    // full glow alpha glow
    Ogre::GeometrySpace* glowFullGlowEntity = fullGlowEntity->clone(fullGlowEntity->getName() + "_glow");
    glowFullGlowEntity->setRenderGroup(RENDER_QUEUE_FULL_GLOW_GLOW);
    glowFullGlowEntity->setMaterial("cg/no_depth_check_glow");
    Ogre::SpaceNode* glowFullGlowNode = fullGlowEntity->getSceneNode()->create("fullGlowGlowNode");
    glowFullGlowNode->attachObject(glowFullGlowEntity);

    mCamera->setPos(NII::Vector3f(0, 0, 200));
    mCamera->setDirection(NII::Vector3f(0, 0, -1));

    mStencilListener = new StencilOpQueueListener();
    mSceneMgr->add(mStencilListener);
}
//----------------------------------------------------------------------------
//----------------------------------------------------------------------------

PlayPen_StencilShadows::PlayPen_StencilShadows()
{
    mInfo["Title"] = "PlayPen_StencilShadows";
    mInfo["Description"] = "Tests stencil shadows.";
    addScreenshotFrame(20);
}
//----------------------------------------------------------------------------

void PlayPen_StencilShadows::setupContent()
{
    SpaceNode* mTestNode[10];
    Light* mLight = 0;

    mSceneMgr->setShadowTechnique(SHADOWTYPE_STENCIL_ADDITIVE);
    //mSceneMgr->getRenderPattern()->setDebugShadow(true);
    mSceneMgr->getRenderPattern()->setExtent(1000);
    //mSceneMgr->setShadowColour(Colour(0.4, 0.25, 0.25));

    //mSceneMgr->getRenderPattern()->setMaxExtent(800);
    // Set ambient light
    mSceneMgr->setAmbient(Colour(0.0, 0.0, 0.0));

    // Point light
    //if(pointLight)
    //{
        mLight = mSceneMgr->createLight("MainLight");
        mLight->setPos(Vecotr3f(-400, 400, -300));
        mLight->setDiffuse(0.9, 0.9, 1);
        mLight->setSpecular(0.9, 0.9, 1);
        mLight->setRange(6000);
        mLight->setAttenuationConstant(1);
        mLight->setAttenuationLinear(0.001);
        mLight->setAttenuationQuadric(0);
    //}
    // Directional light
    //if (directionalLight)
    //{
        mLight = mSceneMgr->createLight("Light2");
        Vector3 dir(-1,-1,0);
        dir.normalise();
        mLight->setType(LT_DIRECTIONAL);
        mLight->setDirection(dir);
        mLight->setDiffuse(1, 1, 0.8);
        mLight->setSpecular(1, 1, 1);
    //}

    mTestNode[0] = mSceneMgr->getOriginNode()->create();

    // Hardware skin
    GeometrySpace* pEnt;
    pEnt = mSceneMgr->createGeo( "1", "robot.mesh" );
    AnimationFusion* anim = pEnt->getFusion("Walk");
    anim->setEnabled(true);
    mAnimStateList.push_back(anim);
    mTestNode[0]->attachObject( pEnt );

    // Software skin
    pEnt = mSceneMgr->createGeo( "12", "robot.mesh" );
    anim = pEnt->getFusion("Walk");
    anim->setEnabled(true);
    mAnimStateList.push_back(anim);
    static_cast<SpaceNode *>(mSceneMgr->getOriginNode()->create(Vector3(100, 0, 0)))->attachObject(pEnt);
    pEnt->setMaterial("Examples/Rocky");


    // Does not receive shadows
    pEnt = mSceneMgr->createGeo( "3", "knot.mesh" );
    pEnt->setMaterial("Examples/EnvMappedRustySteel");
    MaterialPtr mat2 = MaterialManager::getSingleton().getByName("Examples/SphereMappedRustySteel");
    mat2->setReceiveShadow(false);
    mTestNode[2] = mSceneMgr->getOriginNode()->create(Vector3(-200, 0, -200));
    mTestNode[2]->attachObject( pEnt );

    // Transparent object
    pEnt = mSceneMgr->createGeo( "3.5", "knot.mesh" );
    pEnt->setMaterial("Examples/TransparentTest");
    MaterialPtr mat3 = MaterialManager::getSingleton().getByName("Examples/TransparentTest");
    pEnt->setCastShadow(false);
    mTestNode[3] = mSceneMgr->getOriginNode()->create(Vector3(350, 0, -200));
    mTestNode[3]->attachObject( pEnt );

    MeshPtr msh = MeshManager::getSingleton().load("knot.mesh",
    TRANSIENT_RESOURCE_GROUP);
    unsigned short src, dest;
    if (!msh->checkTangentBuffer(false))
    {
        msh->buildTangentBuffer(VT_Tangent);
    }
    pEnt = mSceneMgr->createGeo( "4", "knot.mesh" );
    pEnt->setMaterial("Examples/BumpMapping/MultiLightSpecular");
    mTestNode[2] = mSceneMgr->getOriginNode()->create(Vector3(100, 0, 200));
    mTestNode[2]->attachObject( pEnt );

    // controller based material
    pEnt = mSceneMgr->createGeo( "432", "knot.mesh" );
    pEnt->setMaterial("Examples/TextureEffect2");
    static_cast<SpaceNode *>(mSceneMgr->getOriginNode()->create(Vector3(100, 200, 200)))->attachObject( pEnt );

    ParticleSpace* pSys2 = mSceneMgr->createParticleSpace("smoke",
    "Examples/Smoke");
    mTestNode[4] = mSceneMgr->getOriginNode()->create(Vector3(-300, -100, 200));
    mTestNode[4]->attachObject(pSys2);

    BoxSky * mBoxSky = N_new BoxSky(mSceneMgr);
    mBoxSky->setMaterial();
    mBoxSky->setRenderGroup(RQG_Sky);
    mSceneMgr->setSkyBox(true, "Examples/CloudyNoonSkyBox");


    Plane plane;
    plane.normal = Vector3::Y;
    plane.d = 100;
    MeshManager::getSingleton().createPlane("Myplane",
    TRANSIENT_RESOURCE_GROUP, plane,
    1500,1500,10,10,true,1,5,5,Vector3::Z);
    GeometrySpace* pPlaneEnt = mSceneMgr->createGeo( "plane", "Myplane" );
    pPlaneEnt->setMaterial("2 - Default");
    pPlaneEnt->setCastShadow(false);
    static_cast<SpaceNode *>(mSceneMgr->getOriginNode()->create())->attachObject(pPlaneEnt);

    //mCamera->setPos(180, 34, 223);
    //mCamera->setOri(Quaternion(0.7265, -0.2064, 0.6304, 0.1791));

    mCamera->setPos(NII::Vector3f(0, 0, 400));
    mCamera->setDirection(NII::Vector3f(0, 0, -1));

    // Create a render texture
/*  TexturePtr rtt = N_Only(TextureManager).createTexture("rtt0", TRANSIENT_RESOURCE_GROUP,
        TEX_TYPE_2D, 512, 512, 0, PF_R8G8B8, Texture::MM_FRAME_RGB);
    rtt->getBuffer()->getBuffer()->createViewport(mCamera);
    // Create an overlay showing the rtt
    MaterialPtr debugMat = MaterialManager::getSingleton().create(
    "DebugRTT", TRANSIENT_RESOURCE_GROUP);
    debugMat->get(0)->get(0)->setLight(false);
    ShaderChTextureUnit *t = debugMat->get(0)->get(0)->getTexture().create("rtt0");
    OverlayView* debugPanel = (OverlayView*)OverlayManager::getSingleton().createGeo("Panel", "Ogre/DebugShadowPanel");
    debugPanel->setUnitPos(0.6, 0);
    debugPanel->setUnitSize(0.4, 0.6);
    debugPanel->setMaterial("DebugRTT");
    Overlay* debugOverlay = OverlayManager::getSingleton().getByName("Core/DebugOverlay");
    debugOverlay->add(debugPanel);*/


}
//----------------------------------------------------------------------------
//----------------------------------------------------------------------------

PlayPen_StencilShadowsMixedOpSubMeshes::PlayPen_StencilShadowsMixedOpSubMeshes()
{
    mInfo["Title"] = "PlayPen_StencilShadowsMixedOpSubMeshes";
    mInfo["Description"] = "Tests mixed operation submeshes.";
    addScreenshotFrame(20);
}
//----------------------------------------------------------------------------
void PlayPen_StencilShadowsMixedOpSubMeshes::setupContent()
{
    //mSceneMgr->setShadowTechnique(SHADOWTYPE_STENCIL_MODULATIVE);
    mSceneMgr->setShadowTechnique(SHADOWTYPE_STENCIL_ADDITIVE);
    //mSceneMgr->getRenderPattern()->setDebugShadow(true);
    mSceneMgr->getRenderPattern()->setExtent(1000);

    //mSceneMgr->getRenderPattern()->setMaxExtent(800);
    // Set ambient light
    mSceneMgr->setAmbient(Colour(0.0, 0.0, 0.0));

    Light* mLight;

    // Point light
    //if(pointLight)
    //{
        mLight = mSceneMgr->createLight("MainLight");
        mLight->setPos(Vecotr3f(-400, 400, -300));
        mLight->setDiffuse(0.9, 0.9, 1);
        mLight->setSpecular(0.9, 0.9, 1);
        mLight->setRange(6000);
        mLight->setAttenuationConstant(1);
        mLight->setAttenuationLinear(0.001);
        mLight->setAttenuationQuadric(0);
    //}
    // Directional light
    //if (directionalLight)
    //{
        /*mLight = mSceneMgr->createLight("Light2");
        Vector3 dir(-1,-1,0);
        dir.normalise();
        mLight->setType(LT_DIRECTIONAL);
        mLight->setDirection(dir);
        mLight->setDiffuse(1, 1, 0.8);
        mLight->setSpecular(1, 1, 1);*/
    //}
    BoxSky * mBoxSky = N_new BoxSky(mSceneMgr);
    mBoxSky->setMaterial();
    mBoxSky->setRenderGroup(RQG_Sky);
    mSceneMgr->setSkyBox(true, "Examples/CloudyNoonSkyBox");


    Plane plane;
    plane.normal = Vector3::Y;
    plane.d = 100;
    MeshManager::getSingleton().createPlane("Myplane",
    TRANSIENT_RESOURCE_GROUP, plane,
    1500,1500,10,10,true,1,5,5,Vector3::Z);
    GeometrySpace* pPlaneEnt = mSceneMgr->createGeo( "plane", "Myplane" );
    pPlaneEnt->setMaterial("2 - Default");
    pPlaneEnt->setCastShadow(false);
    static_cast<SpaceNode *>(mSceneMgr->getOriginNode()->create())->attachObject(pPlaneEnt);

    //mCamera->setPos(180, 34, 223);
    //mCamera->setOri(Quaternion(0.7265, -0.2064, 0.6304, 0.1791));


    CustomSpaceObj* man = mSceneMgr->createCustomGeo("testMO_");
    man->begin(GeometryRaw::OT_TRIANGLE_LIST,"2 - Default");
    man->position(0, 200, 0);
    man->position(0, 50, 100);
    man->position(100, 50, -100);
    man->position(-100, 50, -100);
    man->triangle(0, 1, 2);
    man->triangle(0, 2, 3);
    man->triangle(0, 3, 1);
    man->end();
    man->begin(GeometryRaw::OT_LINE_STRIP, "2 - Default");
    man->position(0, 200, 0);
    man->position(50, 250, 0);
    man->position(200, 300, 0);
    man->index(0);
    man->index(1);
    man->index(2);
    man->end();
    Mesh * msh = man->createMesh("testMO.mesh_2");
    msh->ref(false);
    GeometrySpace* e = mSceneMgr->createGeo("34", "testMO.mesh_2");
    static_cast<SpaceNode *>(mSceneMgr->getOriginNode()->create())->attachObject(e);

    mCamera->setPos(NII::Vector3f(100,320,600));
    mCamera->lookAt(Ogre::Vector3f(0,120,0));

}
//----------------------------------------------------------------------------
//----------------------------------------------------------------------------

PlayPen_SubEntityVisibility::PlayPen_SubEntityVisibility()
{
    mInfo["Title"] = "PlayPen_SubEntityVisibility";
    mInfo["Description"] = "Tests sub entity visibility settings.";
    addScreenshotFrame(250);
}
//----------------------------------------------------------------------------

void PlayPen_SubEntityVisibility::setupContent()
{
    SpaceNode* mTestNode[5];
    // Set ambient light
    mSceneMgr->setAmbient(Colour(0.5, 0.5, 0.5));

    // Create a point light
    Light* l = mSceneMgr->createLight("MainLight");
    l->setType(LT_DIRECTIONAL);
    l->setDirection(-Vector3::Y);

    mTestNode[0] = (SpaceNode*)mSceneMgr->getOriginNode()->create();

    GeometrySpace* pEnt = mSceneMgr->createGeo( "1", "ogrehead.mesh" );
    mTestNode[0]->attachObject( pEnt );

    pEnt->getCom(1)->setVisible(false);

    mCamera->setPos(NII::Vector3f(0,0,125));
}
//----------------------------------------------------------------------------
//----------------------------------------------------------------------------

PlayPen_SuppressedShadows::PlayPen_SuppressedShadows()
{
    mInfo["Title"] = "PlayPen_SuppressedShadows";
    mInfo["Description"] = "Tests suppressing shadows for a viewport.";
    addScreenshotFrame(10);
}
//----------------------------------------------------------------------------

void PlayPen_SuppressedShadows::setupContent()
{
    mSceneMgr->setShadowTechnique(SHADOWTYPE_TEXTURE_ADDITIVE);

    // Setup lighting
    mSceneMgr->setAmbient(Colour(0.2, 0.2, 0.2));
    Light * light = mSceneMgr->createLight("MainLight");
    light->setType(LT_DIRECTIONAL);
    Vector3 dir(-1, -1, 0.5);
    dir.normalise();
    light->setDirection(dir);

    // Create a floor plane mesh
    Plane plane(Vector3::Y, 0.0);
    MeshManager::getSingleton().createPlane("FloorPlane", TRANSIENT_RESOURCE_GROUP,
        plane, 200000, 200000, 20, 20, true, 1, 500, 500, Vector3::Z);

    // Add a floor to the scene
    GeometrySpace * entity = mSceneMgr->createGeo("floor", "FloorPlane");
    entity->setMaterial("Examples/RustySteel");
    static_cast<SpaceNode *>(mSceneMgr->getOriginNode()->create())->attachObject(entity);
    entity->setCastShadow(false);

    // Add the mandatory ogre head
    entity = mSceneMgr->createGeo("head", "ogrehead.mesh");
    static_cast<SpaceNode *>(mSceneMgr->getOriginNode()->create(Vector3(0.0, 10.0, 0.0)))->attachObject(entity);

    // Position and orient the camera
    mCamera->setPos(NII::Vector3f(-100.0, 50.0, 90.0));
    mCamera->lookAt(Ogre::Vector3f(0.0, 10.0, -35.0));

    // Add an additional viewport on top of the other one
    Viewport * pip = mWindow->createViewport(mCamera, 0.7, 0.0, 0.3, 0.3, 1);

    // Create a render queue invocation sequence for the pip viewport
    RenderQueueFusion * invocationSequence = mRoot->createQueueFusion(21);

    // Add an invocation to the sequence
    RenderGroupFusion * invocation = invocationSequence->add(RQG_User, "main");

    invocation->setShadowEnable(false);

    // Set the render queue invocation sequence for the pip viewport
    pip->setCustomRender(21); /// ????
}
//----------------------------------------------------------------------------
//----------------------------------------------------------------------------


PlayPen_TextureShadows::PlayPen_TextureShadows()
{
    mInfo["Title"] = "PlayPen_TextureShadows";
    mInfo["Description"] = "Tests texture shadows.";
    addScreenshotFrame(10);
}
//----------------------------------------------------------------------------

void PlayPen_TextureShadows::cleanupContent()
{
    clearDebugTextureOverlays();
}
//----------------------------------------------------------------------------

void PlayPen_TextureShadows::setupContent()
{
    SpaceNode* mTestNode[10];

    mSceneMgr->getRenderPattern()->setTextureDim(1024);
    mSceneMgr->getRenderPattern()->setTextureCount(1);
    //mSceneMgr->setShadowTechnique(tech);
    mSceneMgr->setShadowTechnique(SHADOWTYPE_TEXTURE_ADDITIVE);

    //FocusedShadowSetup* lispsmSetup = N_new FocusedShadowSetup();
    //LiSPSMShadowSetup* lispsmSetup = N_new LiSPSMShadowSetup();
    //lispsmSetup->setOptimalAdjustFactor(1.5);
    //mSceneMgr->setShadowGenCamera(lispsmSetup);

    mSceneMgr->getRenderPattern()->setMaxExtent(1000);
    mSceneMgr->setShadowColour(Colour(0.35, 0.35, 0.35));
    //mSceneMgr->getRenderPattern()->setMaxExtent(800);
    // Set ambient light
    mSceneMgr->setAmbient(Colour(0.3, 0.3, 0.3));

    Light* mLight = mSceneMgr->createLight("MainLight");


    // Directional test
    //if (directional)
    //{
        mLight->setType(LT_DIRECTIONAL);
        Vector3 vec(-1,-1,0);
        vec.normalise();
        mLight->setDirection(vec);
    //}
    // Spotlight test
    /*else
    {
        mLight->setType(LT_SPOT);
        mLight->setRange(1500);
        mLight->setAttenuationConstant(1);
        mLight->setAttenuationLinear(0);
        mLight->setAttenuationQuadric(0);
        mLight->setDiffuse(1.0, 1.0, 0.8);
        mTestNode[0] = mSceneMgr->getOriginNode()->create();
        mTestNode[0]->setPos(Vecotr3f(800, 600, 0));
        mTestNode[0]->lookAt(Vector3(0,0,0), PosNode::SM_Space, Vector3::Z);
        mTestNode[0]->attachObject(mLight);
    }*/

    mTestNode[1] = mSceneMgr->getOriginNode()->create();


    GeometrySpace * pEnt;
    pEnt = mSceneMgr->createGeo( "1", "robot.mesh" );
    //pEnt->setVisibleDistanceLimit(100);
    AnimationFusion* mAnimState = pEnt->getFusion("Walk");
    mAnimState->setEnabled(true);
    mAnimStateList.push_back(mAnimState);
    //pEnt->setMaterial("2 - Default");
    mTestNode[1]->attachObject( pEnt );
    mTestNode[1]->translate(Vector3f(0, -100, 0));

    Quaternion quat1 = Quaternion::IDENTITY;
    Quaternion quat2;
    quat2.from(Angle(360), Vector3::Y);

    pEnt = mSceneMgr->createGeo( "3", "knot.mesh" );
    mTestNode[2] = mSceneMgr->getOriginNode()->create(Vector3(-200, 0, -200));
    mTestNode[2]->attachObject( pEnt );

    createRandomEntityClones(pEnt, 20, Vector3(-1000,0,-1000), Vector3(1000,0,1000), mSceneMgr);


    // Transparent object (can force cast shadows)
    pEnt = mSceneMgr->createGeo( "3.5", "knot.mesh" );
    Material* tmat = MaterialManager::getSingleton().create("TestAlphaTransparency", TRANSIENT_RESOURCE_GROUP);
    tmat->setAlphaShadowCast(true);
    Pass * tpass = tmat->get(0)->get(0);
    tpass->setColour(ShaderCh::SOT_Set)->setAlphaReject(CM_GREATER);
    tpass->setColour(ShaderCh::SOT_Set)->setValue(150);
    tpass->setColour(ShaderCh::SOT_Set)->setAlphaCoverage(false);
    tpass->setBlend(ShaderCh::SOT_Set)->setBlend(FBM_INV_ALPHA);
    tpass->getTexture().create("gras_02.png");
    tpass->setCullingMode(CM_None);

    pEnt->setMaterial("TestAlphaTransparency");
    mTestNode[3] = mSceneMgr->getOriginNode()->create(Vector3(350, 0, -200));
    mTestNode[3]->attachObject( pEnt );

    MeshPtr msh = MeshManager::getSingleton().load("knot.mesh", TRANSIENT_RESOURCE_GROUP);
    msh->buildTangentBuffer(VT_Tangent);
    pEnt = mSceneMgr->createGeo( "4", "knot.mesh" );
    //pEnt->setMaterial("Examples/BumpMapping/MultiLightSpecular");
    mTestNode[2] = mSceneMgr->getOriginNode()->create(Vector3(100, 0, 200));
    mTestNode[2]->attachObject( pEnt );

    BoxSky * mBoxSky = N_new BoxSky(mSceneMgr);
    mBoxSky->setMaterial();
    mBoxSky->setRenderGroup(RQG_Sky);
    mSceneMgr->setSkyBox(true, "Examples/CloudyNoonSkyBox");


    MovablePlane movablePlane(Vector3::Y, 100);
    MeshManager::getSingleton().createPlane("Myplane",
    TRANSIENT_RESOURCE_GROUP, movablePlane,
    2500,2500,10,10,true,1,5,5,Vector3::Z);
    GeometrySpace* pPlaneEnt;
    pPlaneEnt = mSceneMgr->createGeo( "plane", "Myplane" );
    if (SHADOWTYPE_TEXTURE_ADDITIVE & SHADOWDETAILTYPE_INTEGRATED)
    {
      pPlaneEnt->setMaterial("Examples/Plane/IntegratedShadows");
    }
    else
    {
        pPlaneEnt->setMaterial("2 - Default");
    }
    pPlaneEnt->setCastShadow(false);
    static_cast<SpaceNode *>(mSceneMgr->getOriginNode()->create())->attachObject(pPlaneEnt);

    addTextureShadowDebugOverlay(1,mSceneMgr);


    /*
    ParticleSpace* pSys2 = mSceneMgr->createParticleSpace("smoke",
    "Examples/Smoke");
    mTestNode[4] = mSceneMgr->getOriginNode()->create(Vector3(-300, -100, 200));
    mTestNode[4]->attachObject(pSys2);
    */

    mCamera->setPos(NII::Vector3f(0, 1000, 500));
    mCamera->lookAt(Ogre::Vector3f(0,0,0));
    mCamera->setFarClipDistance(10000);


}
//----------------------------------------------------------------------------
//----------------------------------------------------------------------------

PlayPen_TextureShadowsCustomCasterMat::PlayPen_TextureShadowsCustomCasterMat()
{
    mInfo["Title"] = "PlayPen_TextureShadowsCustomCasterMat";
    mInfo["Description"] = "Tests texture shadows with a custom caster material.";
    addScreenshotFrame(10);
}
//----------------------------------------------------------------------------

void PlayPen_TextureShadowsCustomCasterMat::setupContent()
{
    PlayPen_TextureShadows::setupContent();

    String customCasterMatVp =
    "void customCasterVp(float4 position : POSITION,\n"
    "out float4 oPosition : POSITION,\n"
    "uniform float4x4 worldViewProj)\n"
    "{\n"
    "    oPosition = mul(worldViewProj, position);\n"
    "}\n";
    String customCasterMatFp =
    "void customCasterFp(\n"
    "out float4 oColor : COLOR)\n"
    "{\n"
    "    oColor = float4(1,1,0,1); // just a test\n"
    "}\n";

    HighLevelGpuProgramPtr vp = HighLevelGpuProgramManager::getSingleton()
        .createProgram("CustomShadowCasterVp",
            TRANSIENT_RESOURCE_GROUP, "cg", GPT_VERTEX_PROGRAM);
    vp->setProgramCode(customCasterMatVp);
    vp->set("profiles", "vs_1_1 arbvp1");
    vp->set("entry_point", "customCasterVp");
    vp->load();

    HighLevelGpuProgramPtr fp = HighLevelGpuProgramManager::getSingleton()
        .createProgram("CustomShadowCasterFp", TRANSIENT_RESOURCE_GROUP, "cg",
            GPT_FRAGMENT_PROGRAM);
    fp->setProgramCode(customCasterMatFp);
    fp->set("profiles", "ps_1_1 arbfp1");
    fp->set("entry_point", "customCasterFp");
    fp->load();

    MaterialPtr mat = MaterialManager::getSingleton().create("CustomShadowCaster",
    TRANSIENT_RESOURCE_GROUP);
    Pass * p = mat->get(0)->get(0);
    GpuProgramParam * param;
    p->getProgram().set(ST_VS, 0, "CustomShadowCasterVp")
    p->getProgram().get(0, ST_VS, NULL, param);
    param->set("worldViewProj", GpuProgramParam::GSP_Matrix_Proj_X_View_X_Space);
    p->getProgram().set(ST_FS, 0, "CustomShadowCasterFp");

    mSceneMgr->getRenderPattern()->setTextureCasterMaterial("CustomShadowCaster");
}
//----------------------------------------------------------------------------
//----------------------------------------------------------------------------
PlayPen_TextureShadowsCustomReceiverMat::PlayPen_TextureShadowsCustomReceiverMat()
{
    mInfo["Title"] = "PlayPen_TextureShadowsCustomReceiverMat";
    mInfo["Description"] = "Tests texture shadows with a custom reciever material.";
    addScreenshotFrame(10);
}
//----------------------------------------------------------------------------

void PlayPen_TextureShadowsCustomReceiverMat::setupContent()
{
    PlayPen_TextureShadows::setupContent();

    String customReceiverMatVp =
    "void customReceiverVp(float4 position : POSITION,\n"
    "out float4 oPosition : POSITION,\n"
    "out float2 oUV : TEXCOORD0,\n"
    "uniform float4x4 texViewProj,\n"
    "uniform float4x4 worldViewProj)\n"
    "{\n"
    "    oPosition = mul(worldViewProj, position);\n"
    "    float4 suv = mul(texViewProj, position);\n"
    "    oUV = suv.xy / suv.w;\n"
    "}\n";
    String customReceiverMatFp =
    "void customReceiverFp(\n"
    "float2 uv : TEXCOORD0,\n"
    "uniform sampler2D shadowTex : register(s0),\n"
    "out float4 oColor : COLOR)\n"
    "{\n"
    "    float4 shadow = tex2D(shadowTex, uv);\n"
    "    oColor = shadow * float4(1,0,1,1); // just a test\n"
    "}\n";

    HighLevelGpuProgramPtr vp = HighLevelGpuProgramManager::getSingleton()
        .createProgram("CustomShadowReceiverVp",
            TRANSIENT_RESOURCE_GROUP, "cg", GPT_VERTEX_PROGRAM);
    vp->setProgramCode(customReceiverMatVp);
    vp->set("profiles", "vs_1_1 arbvp1");
    vp->set("entry_point", "customReceiverVp");
    vp->load();

    HighLevelGpuProgramPtr fp = HighLevelGpuProgramManager::getSingleton()
        .createProgram("CustomShadowReceiverFp",
            TRANSIENT_RESOURCE_GROUP, "cg", GPT_FRAGMENT_PROGRAM);
    fp->setProgramCode(customReceiverMatFp);
    fp->set("profiles", "ps_1_1 arbfp1");
    fp->set("entry_point", "customReceiverFp");
    fp->load();
    GpuProgramParam * param;
    MaterialPtr mat = N_Only(Material).create("CustomShadowReceiver", TRANSIENT_RESOURCE_GROUP);
    Pass * p = mat->get(0)->get(0);
    p->getProgram().set(ST_VS, 0, "CustomShadowReceiverVp");
    p->getProgram().get(0, ST_VS, NULL, param);
    param->set("worldViewProj", GpuProgramParam::GSP_Matrix_Proj_X_View_X_Space);
    param->set("texViewProj", GpuProgramParam::GSP_Texture_Matrix_Proj_X_View_ParamIndex);
    p->getProgram().set(ST_FS, 0, "CustomShadowReceiverFp");
    p->getTexture().create(); // shadow texture will populate

    mSceneMgr->getRenderPattern()->setTextureReceiverMaterial("CustomShadowReceiver");
}
//----------------------------------------------------------------------------
//----------------------------------------------------------------------------

PlayPen_TextureShadowsIntegrated::PlayPen_TextureShadowsIntegrated()
{
    mInfo["Title"] = "PlayPen_TextureShadowsIntegrated";
    mInfo["Description"] = "Tests integrated texture shadows.";
    addScreenshotFrame(10);
}
//----------------------------------------------------------------------------

void PlayPen_TextureShadowsIntegrated::cleanupContent()
{
    clearDebugTextureOverlays();
}
//----------------------------------------------------------------------------

void PlayPen_TextureShadowsIntegrated::setupContent()
{
    mSceneMgr->setShadowTechnique(SHADOWTYPE_TEXTURE_ADDITIVE_INTEGRATED);
    //mSceneMgr->setShadowTechnique(SHADOWTYPE_TEXTURE_MODULATIVE);
    MaterialManager::getSingleton().setTextureFilter(TFM_ANISOTROPIC);
    MaterialManager::getSingleton().setTextureAniso(5);

    mSceneMgr->setTextureConfig(1024, 1024, 2);

    mSceneMgr->setAmbient(Colour::Black);
    Light * l = mSceneMgr->createLight("Spot1");
    l->setType(LT_SPOT);
    l->setRange(5000);
    l->setAttenuationConstant(1);
    l->setAttenuationLinear(0);
    l->setAttenuationQuadric(0);
    l->setSpotlightInner(Angle(30));
    l->setSpotlightOuter(Angle(45));
    l->setSpotlightFalloff(1.0f);
    SpaceNode * lightNode1 = mSceneMgr->getOriginNode()->create();
    lightNode1->attachObject(l);
    lightNode1->setPos(Vecotr3f(400, 250, 500));
    lightNode1->lookAt(Vector3(0,-200,0), PosNode::SM_Space);
    l->setDirection(Vector3::INV_Z);
    l->setDiffuse(0.7, 0.7, 0.5);

    l = mSceneMgr->createLight("Spot2");
    l->setRange(5000);
    l->setAttenuationConstant(1);
    l->setAttenuationLinear(0);
    l->setAttenuationQuadric(0);
    /* // spotlight */
    l->setType(LT_SPOT);
    l->setSpotlightInner(Angle(30));
    l->setSpotlightOuter(Angle(45));
    l->setSpotlightFalloff(1.0f);
    /**/
    // point
    SpaceNode* lightNode2 = mSceneMgr->getOriginNode()->create();
    lightNode2->attachObject(l);
    lightNode2->setPos(Vecotr3f(-500, 200, 500));
    lightNode2->lookAt(Vector3(0,-200,0), PosNode::SM_Space);
    l->setDirection(Vector3::INV_Z);
    /* // directional
    l->setType(LT_DIRECTIONAL);
    Vector3 dir(0.5, -1, 0.5);
    dir.normalise();
    l->setDirection(dir);
    */
    l->setDiffuse(1, 0.2, 0.2);

    /*
    // Test spot 3
    l = mSceneMgr->createLight("Spot3");
    l->setType(LT_SPOT);
    l->setRange(5000);
    l->setAttenuationConstant(1);
    l->setAttenuationLinear(0);
    l->setAttenuationQuadric(0);
    l->setSpotlightInner(Angle(30));
    l->setSpotlightOuter(Angle(45));
    l->setSpotlightFalloff(1.0f);
    SpaceNode* lightNode3 = mSceneMgr->getOriginNode()->create();
    lightNode3->attachObject(l);
    lightNode3->setPos(Vecotr3f(700, 250, 500));
    lightNode3->lookAt(Vector3(0,-200,0), PosNode::SM_Space);
    l->setDirection(Vector3::INV_Z);
    l->setDiffuse(0.0, 0.7, 1.0);
    */

    // Create a basic plane to have something in the scene to look at
    Plane plane;
    plane.normal = Vector3::Y;
    plane.d = 100;
    MeshPtr msh = MeshManager::getSingleton().createPlane("Myplane_IS",
        TRANSIENT_RESOURCE_GROUP, plane, 4500,4500,100,100,true,1,40,40,Vector3::Z);
    msh->buildTangentBuffer(VT_Tangent);
    GeometrySpace * pPlaneEnt;
    pPlaneEnt = mSceneMgr->createGeo( "plane", "Myplane_IS" );
    //pPlaneEnt->setMaterial("Examples/OffsetMapping/Specular");
    pPlaneEnt->setMaterial("Examples/OffsetMapping/IntegratedShadows");
    pPlaneEnt->setCastShadow(false);
    static_cast<SpaceNode *>(mSceneMgr->getOriginNode()->create()))->attachObject(pPlaneEnt);

    pPlaneEnt = mSceneMgr->createGeo( "plane2", "Myplane_IS" );
    //pPlaneEnt->setMaterial("Examples/OffsetMapping/Specular");
    pPlaneEnt->setMaterial("Examples/OffsetMapping/IntegratedShadows");
    pPlaneEnt->setCastShadow(false);
    SpaceNode* n = mSceneMgr->getOriginNode()->create();
    n->roll(Angle(90));
    n->translate(Vector3f(100, 0, 0));
    //n->attachObject(pPlaneEnt);

    pPlaneEnt = mSceneMgr->createGeo( "plane3", "Myplane_IS" );
    //pPlaneEnt->setMaterial("Examples/OffsetMapping/Specular");
    pPlaneEnt->setMaterial("Examples/OffsetMapping/IntegratedShadows");
    pPlaneEnt->setCastShadow(false);
    n = mSceneMgr->getOriginNode()->create();
    n->pitch(Angle(90));
    n->yaw(Angle(-90));
    n->translate(Vector3f(0, 0, -100));
    n->attachObject(pPlaneEnt);

    mCamera->setPos(NII::Vector3f(-50, 500, 1000));
    mCamera->lookAt(Vector3(-50,-100,0));

    GeometrySpace* ent = mSceneMgr->createGeo("athene", "athene.mesh");
    ent->setMaterial("Examples/Athene/NormalMapped");
    static_cast<SpaceNode *>(mSceneMgr->getOriginNode()->create(Vector3(0,-20,0)))->attachObject(ent);

    addTextureShadowDebugOverlay(2, mSceneMgr);
}
//----------------------------------------------------------------------------
//----------------------------------------------------------------------------

PlayPen_TextureShadowsIntegratedPSSM::PlayPen_TextureShadowsIntegratedPSSM()
{
    mInfo["Title"] = "PlayPen_TextureShadowsIntegratedPSSM";
    mInfo["Description"] = "Tests integrated parallel split shadow mapping.";
    addScreenshotFrame(10);
}
//----------------------------------------------------------------------------

void PlayPen_TextureShadowsIntegratedPSSM::cleanupContent()
{
    clearDebugTextureOverlays();
}
//----------------------------------------------------------------------------

void PlayPen_TextureShadowsIntegratedPSSM::setupContent()
{
    mSceneMgr->setShadowTechnique(SHADOWTYPE_TEXTURE_ADDITIVE_INTEGRATED);

    // 3 textures per directional light
    mSceneMgr->getRenderPattern()->setTextureCount(Ogre::LT_DIRECTIONAL, 3);
    mSceneMgr->setTextureConfig(512, 512, 3, PF_R32);
    mSceneMgr->setSelfShadow(true);
    // Set up caster material - this is just a standard depth/shadow map caster
    mSceneMgr->getRenderPattern()->setTextureCasterMaterial("PSSM/shadow_caster");

    // shadow camera setup
    PSSMShadowSetup* pssmSetup = N_new PSSMShadowSetup();
    pssmSetup->calculateSplitPoints(3, mCamera->getNearClipDistance(), mCamera->getFarClipDistance());
    pssmSetup->setSplitPadding(10);
    pssmSetup->setOptimalAdjustFactor(0, 2);
    pssmSetup->setOptimalAdjustFactor(1, 1);
    pssmSetup->setOptimalAdjustFactor(2, 0.5);

    mSceneMgr->setShadowGenCamera(pssmSetup);


    mSceneMgr->setAmbient(Colour(0.3, 0.3, 0.3));
    Light* l = mSceneMgr->createLight("Dir");
    l->setType(LT_DIRECTIONAL);
    Vector3 dir(0.3, -1, 0.2);
    dir.normalise();
    l->setDirection(dir);


    // Create a basic plane to have something in the scene to look at
    Plane plane;
    plane.normal = Vector3::Y;
    plane.d = 100;
    MeshPtr msh = MeshManager::getSingleton().createPlane("Myplane",
        TRANSIENT_RESOURCE_GROUP, plane, 4500,4500,100,100,true,1,40,40,Vector3::Z);
    msh->buildTangentBuffer(VT_Tangent);
    GeometrySpace* pPlaneEnt;
    pPlaneEnt = mSceneMgr->createGeo( "plane", "Myplane" );
    pPlaneEnt->setMaterial("PSSM/Plane");
    static_cast<SpaceNode *>(mSceneMgr->getOriginNode()->create())->attachObject(pPlaneEnt);

    mCamera->setPos(NII::Vector3f(-50, 500, 1000));
    mCamera->lookAt(Vector3(-50,-100,0));

    GeometrySpace* ent = mSceneMgr->createGeo("knot", "knot.mesh");
    ent->setMaterial("PSSM/Knot");
    static_cast<SpaceNode *>(mSceneMgr->getOriginNode()->create(Vector3(0,0,0)))->attachObject(ent);
    createRandomEntityClones(ent, 20, Vector3(-1000,0,-1000), Vector3(1000,0,1000), mSceneMgr);

    GpuProgramParam * param;
    Vector4 splitPoints;
    const PSSMShadowSetup::SplitPointList & splitPointList = pssmSetup->getSplitPoints();
    for (int i = 0; i < 3; ++i)
    {
        splitPoints[i] = splitPointList[i];
    }
    MaterialPtr mat = N_Only(Material).getByName("PSSM/Plane");
    mat->get(0)->get(0)->getProgram().get(0, ST_FS, NULL, param);
    param->set("pssmSplitPoints", splitPoints);
    mat = MaterialManager::getSingleton().getByName("PSSM/Knot");
    mat->get(0)->get(0)->getProgram().get(0, ST_FS, NULL, param);
    param->set("pssmSplitPoints", splitPoints);

    addTextureShadowDebugOverlay(3, mSceneMgr);
}
//----------------------------------------------------------------------------
//----------------------------------------------------------------------------

PlayPen_TextureShadowsTransparentCaster::PlayPen_TextureShadowsTransparentCaster()
{
    mInfo["Title"] = "PlayPen_TextureShadowsTransparentCaster";
    mInfo["Description"] = "Tests transparent shadow casters.";
    addScreenshotFrame(10);
}
//----------------------------------------------------------------------------
void PlayPen_TextureShadowsTransparentCaster::setupContent()
{
    mSceneMgr->setShadowTechnique(SHADOWTYPE_TEXTURE_ADDITIVE);

    LiSPSMShadowSetup *mLiSPSMSetup = N_new LiSPSMShadowSetup();
    //mLiSPSMSetup->setUseAggressiveFocusRegion(false);
    CameraSetup * mCurrentShadowGenCamera = mLiSPSMSetup;
    //CameraSetup  * mCurrentShadowGenCamera = N_new PlaneOptimalShadowGenCamera(mPlane);
    mSceneMgr->setShadowGenCamera(mCurrentShadowGenCamera);

    PixelFormat pxFmt = PF_L8ui;
    if (Root::getSingleton().getRender()->getFeature()->hasCapability(GF_Tex_Float))
    {
        if (Root::getSingleton().getRender()->getName().find("GL") != String::npos)
        {
            // GL performs much better if you pick half-float format
            pxFmt = PF_R16;
        }
        else
        {
            // D3D is the opposite - if you ask for PF_R16 you
            // get an integer format instead! You can ask for PF_G16R16
            // but the precision doesn't work well
            pxFmt = PF_R32;
        }
    }
    mSceneMgr->setTextureConfig(1024, 1024, 1, pxFmt);

    // New depth shadow mapping
    String CUSTOM_ROCKWALL_MATERIAL("Ogre/DepthShadowmap/Receiver/RockWall");
    String CUSTOM_CASTER_MATERIAL("Ogre/DepthShadowmap/Caster/Float");
    String CUSTOM_RECEIVER_MATERIAL("Ogre/DepthShadowmap/Receiver/Float");

    mSceneMgr->getRenderPattern()->setTextureCasterMaterial(CUSTOM_CASTER_MATERIAL);
    mSceneMgr->getRenderPattern()->setTextureReceiverMaterial(CUSTOM_RECEIVER_MATERIAL);
    mSceneMgr->setSelfShadow(true);

    mSceneMgr->getRenderPattern()->setFadeBegin(1.0);
    mSceneMgr->getRenderPattern()->setFadeEnd(1.0);

    mSceneMgr->setSelfShadow(true);

    MaterialManager::getSingleton().setTextureFilter(TFM_ANISOTROPIC);
    MaterialManager::getSingleton().setTextureAniso(5);

    mSceneMgr->getRenderPattern()->setExtentOffsetFactor(0.2);
    mSceneMgr->getRenderPattern()->setMaxExtent(150);
    //mSceneMgr->setBackFaceInCast(false);

    // Create a basic plane to have something in the scene to look at
    Plane plane;
    plane.normal = Vector3::Y;
    plane.d = 100;
    MeshPtr msh = MeshManager::getSingleton().createPlane("Myplane",
        TRANSIENT_RESOURCE_GROUP, plane, 4500,4500,100,100,true,1,40,40,Vector3::Z);
    msh->buildTangentBuffer(VT_Tangent);
    GeometrySpace * pPlaneEnt;
    pPlaneEnt = mSceneMgr->createGeo( "plane", "Myplane" );

    pPlaneEnt->setMaterial(CUSTOM_ROCKWALL_MATERIAL);
    pPlaneEnt->setCastShadow(false);
    static_cast<SpaceNode *>(mSceneMgr->getOriginNode()->create())->attachObject(pPlaneEnt);

    // Reorient the plane and create a plane mesh for the test planes
    plane.normal = Vector3::Z;
    MeshManager::getSingleton().createPlane("Test_Plane", TRANSIENT_RESOURCE_GROUP,
        plane, 50.0, 50.0, 1, 1, true);

    const String GRASSMAT("Examples/GrassBladesAdditiveFloatTransparent");
    //const String GRASSMAT("Examples/DepthShadowmap/CasterReceiver/GrassBlades");
    //const String GRASSMAT("tree4324");//"tree1.tga");

    // Add test plane entities to the scene
    GeometrySpace * entity = mSceneMgr->createGeo("GrassBlades0", "Test_Plane");
    entity->setMaterial(GRASSMAT);
    static_cast<SpaceNode *>(mSceneMgr->getOriginNode()->create(
        Vector3(0.0, -100.0+25.0, 0.0)))->attachObject(entity);

    entity = mSceneMgr->createGeo("GrassBlades1", "Test_Plane");
    entity->setMaterial(GRASSMAT);
    static_cast<SpaceNode *>(mSceneMgr->getOriginNode()->create(
        Vector3(0.0, -100.0+25.0, -20.0)))->attachObject(entity);

    entity = mSceneMgr->createGeo("GrassBlades2", "Test_Plane");
    entity->setMaterial(GRASSMAT);
    static_cast<SpaceNode *>(mSceneMgr->getOriginNode()->create(
        Vector3(0.0, -100.0+25.0, -40.0)))->attachObject(entity);

    // Add test plane entities to the scene, shadowed partially by athene mesh
    entity = mSceneMgr->createGeo("GrassBlades3", "Test_Plane");
    entity->setMaterial(GRASSMAT);
    static_cast<SpaceNode *>(mSceneMgr->getOriginNode()->create(
        Vector3(-80.0, -100.0+25.0, 0.0)))->attachObject(entity);

    entity = mSceneMgr->createGeo("GrassBlades4", "Test_Plane");
    entity->setMaterial(GRASSMAT);
    static_cast<SpaceNode *>(mSceneMgr->getOriginNode()->create(
        Vector3(-130.0, -100.0+25.0, -20.0)))->attachObject(entity);

    entity = mSceneMgr->createGeo("GrassBlades5", "Test_Plane");
    entity->setMaterial(GRASSMAT);
    static_cast<SpaceNode *>(mSceneMgr->getOriginNode()->create(
        Vector3(-180.0, -100.0+25.0, -40.0)))->attachObject(entity);

    GeometrySpace * ent = mSceneMgr->createGeo("athene", "athene.mesh");
    ent->setMaterial(CUSTOM_ROCKWALL_MATERIAL);
    //ent->setMaterial(GRASSMAT);
    static_cast<SpaceNode *>(mSceneMgr->getOriginNode()->create(Vector3(0,-20,-20)))->attachObject(ent);

    // Add test plane entities to the scene, one after another
    entity = mSceneMgr->createGeo("GrassBlades6", "Test_Plane");
    entity->setMaterial(GRASSMAT);
    static_cast<SpaceNode *>(mSceneMgr->getOriginNode()->create(
    Vector3(-260.0, -100.0+25.0, 0.0)))->attachObject(entity);

    entity = mSceneMgr->createGeo("GrassBlades7", "Test_Plane");
    entity->setMaterial(GRASSMAT);
    static_cast<SpaceNode *>(mSceneMgr->getOriginNode()->create(
        Vector3(-260.0, -100.0+25.0, -10.0)))->attachObject(entity);

    entity = mSceneMgr->createGeo("GrassBlades8", "Test_Plane");
    entity->setMaterial(GRASSMAT);
    static_cast<SpaceNode *>(mSceneMgr->getOriginNode()->create(
        Vector3(-260.0, -100.0+25.0, -20.0)))->attachObject(entity);

    // Add test plane entities to the scene, alone with other material

    const String GRASSMAT_CUSTOM_DEFAULT_CUSTOM("Examples/GrassBladesAdditiveFloat");
    const String GRASSMAT_CUSTOM_NOSPECIAL_CUSTOM("Examples/GrassBladesAdditive");
    const String GRASSMAT_ORIG("Examples/GrassBlades");

    entity = mSceneMgr->createGeo("GrassBlades9", "Test_Plane");
    entity->setMaterial(GRASSMAT_CUSTOM_DEFAULT_CUSTOM);
    static_cast<SpaceNode *>(mSceneMgr->getOriginNode()->create(
        Vector3(-80.0, -100.0+25.0, -80.0)))->attachObject(entity);

    entity = mSceneMgr->createGeo("GrassBlades10", "Test_Plane");
    entity->setMaterial(GRASSMAT_CUSTOM_NOSPECIAL_CUSTOM);
    static_cast<SpaceNode *>(mSceneMgr->getOriginNode()->create(
        Vector3(-130.0, -100.0+25.0, -90.0)))->attachObject(entity);

    entity = mSceneMgr->createGeo("GrassBlades11", "Test_Plane");
    entity->setMaterial(GRASSMAT_ORIG);
    static_cast<SpaceNode *>(mSceneMgr->getOriginNode()->create(
        Vector3(-180.0, -100.0+25.0, -90.0)))->attachObject(entity);

    // Position and orient the camera
    //mCamera->setPos(NII::Vector3f(-55.0, 40.0, 100.0));
    //mCamera->lookAt(NII::Vector3f(-10.0, 20.0, -35.0));
    //mCamera->setPos(NII::Vector3f(-75.0, 30.0, 150.0));
    //mCamera->lookAt(NII::Vector3f(0.0, 20.0, -35.0));
    mCamera->setPos(NII::Vector3f(100, 50, 150));
    mCamera->lookAt(Ogre::Vector3f(0, 0, 0));

    //mSceneMgr->setAmbient(Colour::Black);
    Light* l;

    l = mSceneMgr->createLight("Dir1");
    l->setType(LT_DIRECTIONAL);
    //l->setRange(5000);
    //l->setAttenuationConstant(1);
    //l->setAttenuationLinear(0);
    //l->setAttenuationQuadric(0);
    Vector3 dir1(0.0, -0.7, -0.5);
    dir1.normalise();
    l->setDirection(dir1);
    l->setCastShadow(true);

    l->setDiffuse(Colour(1.0, 1.0, 1.0));


    mSceneMgr->setAmbient(Colour(0.0, 0.0, 0.2));

    //         l = mSceneMgr->createLight("Spot2");
    //         l->setRange(5000);
    //         l->setAttenuationConstant(1);
    //         l->setAttenuationLinear(0);
    //         l->setAttenuationQuadric(0);
    //         /* // spotlight */
    //         l->setType(LT_SPOT);
    //         l->setSpotlightInner(Angle(30));
    //         l->setSpotlightOuter(Angle(45));
    //         l->setSpotlightFalloff(1.0f);
    //
    //
    //         SpaceNode* lightNode2 = mSceneMgr->getOriginNode()->create();
    //         lightNode2->attachObject(l);
    //         lightNode2->setPos(Vecotr3f(-500, 200, 500));
    //         lightNode2->lookAt(Vector3(0,-200,0), PosNode::SM_Space);
    //         l->setDirection(Vector3::INV_Z);
    //lightNode2->setPos(Vecotr3f(-75.0, 30.0, 150.0));
    //lightNode2->lookAt(Vector3(.0, 20.0, -35.0), PosNode::SM_Space);


    //addTextureShadowDebugOverlay(1, mSceneMgr);

    // not completely necessary, and can't guarantee determinism easily
    //Root::getSingleton().addFrameListener(new GrassListener(mSceneMgr));

}
//----------------------------------------------------------------------------
//----------------------------------------------------------------------------

PlayPen_TransparencyMipMaps::PlayPen_TransparencyMipMaps()
{
    mInfo["Title"] = "PlayPen_TransparencyMipMaps";
    mInfo["Description"] = "Tests transparent materials with mipmaps.";
    addScreenshotFrame(10);
}
//----------------------------------------------------------------------------

void PlayPen_TransparencyMipMaps::setupContent()
{
    MaterialPtr mat = MaterialManager::getSingleton().create("test",
    TRANSIENT_RESOURCE_GROUP);
    // known png with alpha
    Pass* pass = mat->get(0)->get(0);
    pass->getTexture().create("sdk_logo.png");
    pass->setBlend(ShaderCh::SOT_Set)->setBlend(FBM_INV_ALPHA);
    // alpha blend
    pass->setStencil(ShaderCh::SOT_Set)->setDepthWrite(false);

    // alpha reject
    //pass->setStencil(ShaderCh::SOT_Set)->setDepthWrite(true);

    //pass->setColour(ShaderCh::SOT_Set)->setAlphaReject(CM_LESS);
    //pass->setColour(ShaderCh::SOT_Set)->setValue(128);
    //pass->setColour(ShaderCh::SOT_Set)->setAlphaCoverage(false);
    // Define a floor plane mesh
    Plane p;
    p.normal = Vector3::Y;
    p.d = 200;
    MeshManager::getSingleton().createPlane("FloorPlane",
        TRANSIENT_RESOURCE_GROUP, p,2000,2000,1,1,true,1,5,5,Vector3::Z);

    // Create an entity (the floor)
    GeometrySpace * ent = mSceneMgr->createGeo("floor", "FloorPlane");
    ent->setMaterial("test");
    static_cast<SpaceNode *>(mSceneMgr->getOriginNode()->create())->attachObject(ent);
    DomeSky * mDomeSky = N_new DomeSky(mSceneMgr);
    mDomeSky->setMaterial("Examples/CloudySky");
    mDomeSky->setRenderGroup(RQG_Sky);
    mSceneMgr->buildGeo(5, 1000, 8, 8);
    mSceneMgr->addSky(mDomeSky);
    mSceneMgr->setAmbient(Colour::White);

    {
        NIIf alphaLevel = 0.5f;
        MaterialPtr alphamat = MaterialManager::getSingleton().create("testy",
        TRANSIENT_RESOURCE_GROUP);
        Pass * pass = alphamat->get(0)->get(0);
        pass->setBlend(ShaderCh::SOT_Set)->setBlend(FBM_INV_ALPHA);
        pass->setStencil(ShaderCh::SOT_Set)->setDepthWrite(false);
        ShaderChTextureUnit * t = pass->getTexture().create();
        t->getAlphaBlend()->setBlend(TBO_OPERAND1, alphaLevel, TBS_PRE_TEXTURE);

        ent = mSceneMgr->createGeo("asd", "ogrehead.mesh");
        ent->setMaterial("testy");
        static_cast<SpaceNode *>(mSceneMgr->getOriginNode()->create())->attachObject(ent);
    }
    mCamera->setPos(NII::Vector3f(0, 0, 1000));
}
//----------------------------------------------------------------------------
//----------------------------------------------------------------------------
PlayPen_VertexTexture::PlayPen_VertexTexture()
{
    mInfo["Title"] = "PlayPen_VertexTexture";
    mInfo["Description"] = "Tests vertex texture rendering (DX only).";
    addScreenshotFrame(10);
}
//----------------------------------------------------------------------------
void PlayPen_VertexTexture::setupContent()
{
    // NOTE: DirectX only right now

    Light * l = mSceneMgr->createLight("MainLight");
    l->setType(LT_POINT);
    l->setPos(Vecotr3f(0, 200, 00);

    // Create single-channel floating point texture, no mips
    Texture * tex = N_Only(TextureManager).createTexture( "vertexTexture",
        TRANSIENT_RESOURCE_GROUP, TEX_TYPE_2D, 128, 128, 0, PF_R32);
    float * pData = static_cast<float *>(tex->getBuffer()->lock(Buffer::MM_WHOLE));
    // write concentric circles into the texture
    for (int y  = -64; y < 64; ++y)
    {
        for (int x = -64; x < 64; ++x)
        {

            float val = Math::sqrt(x*x + y*y);
            // repeat every 20 pixels
            val = val * Math::PI2X / 20.0f;
            *pData++ = Math::Sin(val);
        }
    }
    tex->getBuffer()->unlock();

    String progSource =
    "void main(\n"
    "float4 pos : POSITION,\n"
    "float2 uv1 : TEXCOORD0,\n"
    "uniform float4x4 world, \n"
    "uniform float4x4 viewProj,\n"
    "uniform float heightscale,\n"
    "uniform sampler2D heightmap,\n"
    "out float4 oPos : POSITION,\n"
    "out float2 oUv1 : TEXCOORD1,\n"
    "out float4 col : COLOR)\n"
    "{\n"
    "oPos = mul(world, pos);\n"
    "// tex2Dlod since no mip\n"
    "float4 t = float4(0,0,0,0);\n"
    "t.xy = uv1.xy;\n"
    "float height = tex2Dlod(heightmap, t);\n"
    "oPos.y = oPos.y + (height * heightscale);\n"
    "oPos = mul(viewProj, oPos);\n"
    "oUv1 = uv1;\n"
    "col = float4(1,1,1,1);\n"
    "}\n";
    HighLevelGpuProgramPtr prog = HighLevelGpuProgramManager::getSingleton().createProgram(
        "TestVertexTextureFetch", TRANSIENT_RESOURCE_GROUP, "hlsl", GPT_VERTEX_PROGRAM);
    prog->setProgramCode(progSource);
    prog->set("target", "vs_3_0");
    prog->setVertexTextureFetch(true);
    prog->set("entry_point", "main");
    prog->load();

    MaterialPtr mat = N_Only(Material).create("TestVertexTexture", TRANSIENT_RESOURCE_GROUP);
    Pass * pass = mat->get(0)->get(0);
    pass->setLight(false);
    pass->getProgram().set(ST_VS, 0, "TestVertexTextureFetch");
    GpuProgramParam * vp;
    pass->getProgram().get(0, ST_VS, NULL, vp);
    vp->set("world", GpuProgramParam::GSP_Matrix_Space);
    vp->set("viewProj", GpuProgramParam::GSP_Matrix_Proj_X_View);
    vp->set("heightscale", 30.0f);
    // vertex texture
    ShaderChTextureUnit * t = pass->getTexture().create("vertexTexture");
    t->setFetchType(VDF_VS);
    // regular texture
    pass->getTexture().create("BumpyMetal.jpg");

    Plane plane;
    plane.normal = Vector3::Y;
    plane.d = 100;
    // 128 x 128 segment plane
    MeshManager::getSingleton().createPlane("Myplane",
    TRANSIENT_RESOURCE_GROUP, plane,
    1500,1500,128,128,true,1,1,1,Vector3::Z);
    GeometrySpace * pPlaneEnt;
    pPlaneEnt = mSceneMgr->createGeo( "plane", "Myplane" );
    pPlaneEnt->setMaterial("TestVertexTexture");
    pPlaneEnt->setCastShadow(false);
    static_cast<SpaceNode *>(mSceneMgr->getOriginNode()->create())->attachObject(pPlaneEnt);
}
//----------------------------------------------------------------------------
//----------------------------------------------------------------------------

PlayPen_ViewportNoShadows::PlayPen_ViewportNoShadows()
{
    mInfo["Title"] = "PlayPen_ViewportNoShadows";
    mInfo["Description"] = "Tests disabling shadows for a viewport.";
    addScreenshotFrame(10);
}
//----------------------------------------------------------------------------

void PlayPen_ViewportNoShadows::setupContent()
{
    mSceneMgr->setShadowTechnique(SHADOWTYPE_TEXTURE_ADDITIVE);

    // Setup lighting
    mSceneMgr->setAmbient(Colour(0.2, 0.2, 0.2));
    Light* light = mSceneMgr->createLight("MainLight");
    light->setType(LT_DIRECTIONAL);
    Vector3 dir(-1, -1, 0.5);
    dir.normalise();
    light->setDirection(dir);

    // Create a floor plane mesh
    Plane plane(Vector3::Y, 0.0);
    MeshManager::getSingleton().createPlane(
    "FloorPlane", TRANSIENT_RESOURCE_GROUP,
    plane, 200000, 200000, 20, 20, true, 1, 500, 500, Vector3::Z);


    // Add a floor to the scene
    GeometrySpace* entity = mSceneMgr->createGeo("floor", "FloorPlane");
    entity->setMaterial("Examples/RustySteel");
    static_cast<SpaceNode *>(mSceneMgr->getOriginNode()->create())->attachObject(entity);
    entity->setCastShadow(false);

    // Add the mandatory ogre head
    entity = mSceneMgr->createGeo("head", "ogrehead.mesh");
    static_cast<SpaceNode *>(mSceneMgr->getOriginNode()->create(Vector3(0.0, 10.0, 0.0)))->attachObject(entity);

    // Position and orient the camera
    mCamera->setPos(Ogre::Vector3f(-100.0, 50.0, 90.0));
    mCamera->lookAt(Ogre::Vector3f(0.0, 10.0, -35.0));

    // Add an additional viewport on top of the other one
    Viewport * pip = mWindow->createViewport(mCamera, 0.7, 0.0, 0.3, 0.3, 1);
    pip->setShadowEnable(false);
}
//----------------------------------------------------------------------------
//----------------------------------------------------------------------------

PlayPen_WindowedViewportMode::PlayPen_WindowedViewportMode()
{
    mInfo["Title"] = "PlayPen_WindowedViewportMode";
    mInfo["Description"] = "Tests windowed viewport.";
    addScreenshotFrame(10);
}
//----------------------------------------------------------------------------

void PlayPen_WindowedViewportMode::setupContent()
{
    Ogre::SpaceNode* mTestNode[5];

    // Set ambient light
    mSceneMgr->setAmbient(Colour(0.5, 0.5, 0.5));

    // Create a point light
    Light * l = mSceneMgr->createLight("MainLight");
    l->setType(LT_DIRECTIONAL);
    l->setDirection(-Vector3::Y);

    mTestNode[0] = (SpaceNode *)mSceneMgr->getOriginNode()->create();

    GeometrySpace * pEnt = mSceneMgr->createGeo( "1", "ogrehead.mesh" );
    mTestNode[0]->attachObject( pEnt );

    mCamera->setSubMode(true);
    mCamera->setSubView(0, 0, 0.5, 0.5);
    mCamera->setPos(NII::Vector3f(0, 0, 125));
}
//-----------------------------------------------------------------------
//-----------------------------------------------------------------------

void addTextureDebugOverlay(const Ogre::String& texname, size_t i)
{
    Ogre::Overlay* debugOverlay = Ogre::OverlayManager::getSingleton().getByName("Core/DebugOverlay");

    if(!debugOverlay)
        debugOverlay = Ogre::OverlayManager::getSingleton().create("Core/DebugOverlay");

    debugOverlay->show();

    // Set up a debug panel to display the shadow
    Ogre::MaterialPtr debugMat = Ogre::MaterialManager::getSingleton().create(
        "Ogre/DebugTexture" + Ogre::StrConv::conv(i),
        VisualTest::TRANSIENT_RESOURCE_GROUP);
    debugMat->get(0)->get(0)->setLight(false);
    Ogre::ShaderChTextureUnit * t = debugMat->get(0)->get(0)->getTexture().create(texname);
    t->setUAddressing(TAM_CLAMP);
    t->setVAddressing(TAM_CLAMP);
    t->setWAddressing(TAM_CLAMP);

    Ogre::OverlayView* debugPanel = (Ogre::OverlayView*)
        Ogre::OverlayManager::getSingleton().createGeo("Panel", "Ogre/DebugTexPanel" + Ogre::StrConv::conv(i));
    debugPanel->setUnitPos(0.8, i * 0.25);
    debugPanel->setUnitSize(0.2, 0.24);
    debugPanel->setMaterial(debugMat->getName());
    debugOverlay->add(debugPanel);
}
//-----------------------------------------------------------------------
void clearDebugTextureOverlays()
{
    Ogre::Overlay * debugOverlay = Ogre::OverlayManager::getSingleton().getByName("Core/DebugOverlay");

    if(debugOverlay)
        Ogre::OverlayManager::getSingleton().destroy("Core/DebugOverlay");
        //debugOverlay->hide();

    for(int i = 0; i < 10; ++i)
    {
        if(Ogre::OverlayManager::getSingleton().isGeoExist(
            "Ogre/DebugTexPanel" + Ogre::StrConv::conv(i)))
        {
            OverlayManager::getSingleton().destroyGeo(
                "Ogre/DebugTexPanel" + Ogre::StrConv::conv(i));
            Ogre::MaterialManager::getSingleton().remove("Ogre/DebugTexture" + Ogre::StrConv::conv(i));
        }
    }
}
//-----------------------------------------------------------------------

void addTextureDebugOverlay(Ogre::TexturePtr tex, size_t i)
{
    addTextureDebugOverlay(tex->getName(), i);
}
//-----------------------------------------------------------------------

void addTextureShadowDebugOverlay(size_t num, Ogre::SpaceManager* mgr)
{
    for (size_t i = 0; i < num; ++i)
    {
        Ogre::TexturePtr shadowTex = mgr->getRenderPattern()->getTexture(i);
        addTextureDebugOverlay(shadowTex, i);
    }
}
//-----------------------------------------------------------------------
