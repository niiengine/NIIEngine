/*
-----------------------------------------------------------------------------
A
     __      _   _   _   ______
    |   \   | | | | | | |  ____)                    _
    | |\ \  | | | | | | | |         ___      ___   (_)   ___
    | | \ \ | | | | | | | |____    / _ \   / ___ \  _   / _ \   ___
    | |  \ \| | | | | | |  ____)  | / \ | | |  | | | | | / \ | / _ )
    | |   \ | | | | | | | |_____  | | | | | |__| | | | | | | | | __/
    |_|    \ _| |_| |_| |_______) |_| |_|  \___| | |_| |_| |_| |___|
                                             __/ |                 
                                            \___/   
                                                
                                                
                                                                 F i l e


Copyright: NIIEngine Team Group

Home page: www.niiengine.com 

Email: niiengine@gmail.com OR niiengine@163.com

Licence: commerce(www.niiengine.com/license)(Three kinds)
------------------------------------------------------------------------------
*/
#include "OgreShaderMaterialSerializerListener.h"
#include "OgreShaderGenerator.h"
#include "OgreMaterialManager.h"


namespace Ogre
{
namespace RTShader
{
    //-----------------------------------------------------------------------------
    SGMaterialSerializerListener::SGMaterialSerializerListener()
    {
        mSourceMaterial = NULL;
    }
    //-----------------------------------------------------------------------------
    SGMaterialSerializerListener::~SGMaterialSerializerListener()
    {
    }
    //-----------------------------------------------------------------------------
    void SGMaterialSerializerListener::materialEventRaised(MaterialSerializer * ser,
        MaterialSerializer::SerializeEvent event, bool & skip, const Material * mat)
    {
        if(event == MaterialSerializer::MSE_PRE_WRITE)
        {
            MaterialPtr matPtr = MaterialManager::getSingleton().getByName(mat->getName());
            mSourceMaterial = matPtr.get();
            createSGPassList(mSourceMaterial, mSGPassList);
        }

        if(event == MaterialSerializer::MSE_POST_WRITE)
        {
            mSourceMaterial = NULL;
            mSGPassList.clear();
        }
    }
    //-----------------------------------------------------------------------------
    void SGMaterialSerializerListener::techniqueEventRaised(MaterialSerializer * ser,
        MaterialSerializer::SerializeEvent event, bool & skip, const ShaderFusion * tech)
    {
        // Pre technique write event.
        if(event == MaterialSerializer::MSE_PRE_WRITE)
        {
            void * techUserData = tech->getExtData(ShaderGenerator::SGTechnique::UserKey);

            // Skip writing this technique since it was generated by the Shader Generator.
            if(techUserData != 0)
            {
                skip = true;
                return;
            }
        }
    }
    //-----------------------------------------------------------------------------
    void SGMaterialSerializerListener::passEventRaised(MaterialSerializer * ser,
        MaterialSerializer::SerializeEvent event, bool & skip, const ShaderCh * pass)
    {
        // End of pass writing event.
        if (event == MaterialSerializer::MSE_WRITE_END)
        {
            // Grab the shader generator pass instance.
            ShaderGenerator::SGPass * passEntry = getShaderGeneratedPass(pass);

            // Case this pass use as source pass for shader generated pass.
            if (passEntry != NULL)
                ShaderGenerator::getSingleton().serializePassAttributes(ser, passEntry);
        }
    }

    //-----------------------------------------------------------------------------
    void SGMaterialSerializerListener::textureUnitStateEventRaised(MaterialSerializer * ser,
        MaterialSerializer::SerializeEvent event, bool & skip, const ShaderChTextureUnit * textureUnit)
    {
        // End of pass writing event.
        if(event == MaterialSerializer::MSE_WRITE_END)
        {
            // Grab the shader generator pass instance.
            ShaderGenerator::SGPass * passEntry = getShaderGeneratedPass(textureUnit->getParent());

            // Case this pass use as source pass for shader generated pass.
            if (passEntry)
                ShaderGenerator::getSingleton().serializeTextureUnitStateAttributes(ser, passEntry, textureUnit);
        }
    }
    //-----------------------------------------------------------------------------
    void SGMaterialSerializerListener::createSGPassList(Material * mat, SGPassList & passList)
    {
        NCount index, iend = mat->getCount();
        for(index = 0; index < iend; ++index)
        {
            ShaderFusion * sf = mat->get(index);
            for(NCount passIndex = 0; passIndex < sf->getCount(); ++passIndex)
            {
                ShaderCh * curPass = sf->get(passIndex);
                void * passUserData = curPass->getExtData(ShaderGenerator::SGPass::UserKey);

                // Case this pass created by the shader generator.
                if(passUserData != 0)
                {
                    ShaderGenerator::SGPass * passEntry =
                        static_cast<ShaderGenerator::SGPass *>(passUserData);

                    passList.push_back(passEntry);
                }
            }
        }
    }
    //-----------------------------------------------------------------------------
    ShaderGenerator::SGPass * SGMaterialSerializerListener::getShaderGeneratedPass(const ShaderCh * srcPass)
    {
        SGPassListIterator it = mSGPassList.begin();
        SGPassListIterator itEnd = mSGPassList.end();

        for(; it != itEnd; ++it)
        {
            ShaderGenerator::SGPass* currPassEntry = *it;

            if(currPassEntry->getSrcPass() == srcPass)
            {
                return currPassEntry;
            }
        }
        return NULL;
    }
}
}